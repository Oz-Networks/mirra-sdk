/**
 * Auto-Generated SDK Adapter Methods
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * Generated from adapter operation schemas
 * Run: npm run generate:llm-api
 */

import { MirraSDK } from '../client';

// ============================================================================
// Base Result Type
// ============================================================================

/**
 * Structured data for rich UI rendering in chat messages
 */
export interface ToolResultStructuredData {
  displayType: 'list' | 'card' | 'table' | 'chart' | 'code' | 'markdown';
  templateId?: string;
  data: any;
  metadata?: Record<string, any>;
}

/**
 * Base result type for all adapter operations
 */
export interface AdapterResultBase<T = any> {
  id: string;
  status: 'success' | 'pending' | 'failed';
  timestamp: string;
  data: T;
  structuredData?: ToolResultStructuredData[];
  metadata?: {
    executionMode: 'standard' | 'delegated' | 'service';
    actorId?: string;
    adapter?: string;
    [key: string]: any;
  };
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

// ============================================================================
// Type Definitions
// ============================================================================

// Flows Adapter Types
export interface FlowsCreateFlowArgs {
  title?: string; // Flow title. Required if providing inline code.
  description?: string; // Detailed description of what the flow does
  code?: string; // Inline script code. If provided, auto-creates, deploys, and links the script. Cannot use with scriptId.
  scriptId?: string; // ID of existing deployed script. Cannot use with code.
  schedule?: string; // Cron expression for time-based flows (e.g., "0 9 * * *"). Cannot use with eventType/eventFilter/trigger.
  eventType?: string; // Event type shorthand (e.g., "telegram.message", "gmail.email_received"). Creates an eventFilter matching this type.
  eventFilter?: any; // Full event filter with operator and conditions array for complex filtering.
  trigger?: any; // Legacy nested trigger structure. Prefer eventType or eventFilter instead.
  scriptInput?: any; // Optional static input data for the script
  enabled?: boolean; // Whether the flow is enabled (default: true)
}
export interface FlowsCreateTimeFlowArgs {
  title: string; // Flow title
  description: string; // Detailed description of what the flow does
  schedule: string; // Cron expression for scheduling (e.g., "0 9 * * *" for daily at 9am)
  scriptId: string; // ID of the script to execute when triggered
  scriptInput?: any; // Optional static input data for the script
}
export interface FlowsCreateEventFlowArgs {
  title: string; // Flow title
  description: string; // Detailed description of what the flow does
  trigger: any; // Event filter conditions that determine WHEN the script runs. Add ALL filtering logic here to minimize Lambda invocations. Must have type:"event" and config.eventFilter with operator and conditions array.
  scriptId: string; // ID of the script to execute when triggered
  scriptInput?: any; // Optional static input data for the script
}
export interface FlowsListFlowsArgs {
  status?: string; // Filter by status: active, paused, completed, failed
}
export interface FlowsGetFlowArgs {
  id: string; // Flow ID
}
export interface FlowsUpdateFlowArgs {
  id: string; // Flow ID to update
  title?: string; // New title
  description?: string; // New description
  trigger?: any; // New trigger configuration
  scriptId?: string; // New script ID
  scriptInput?: any; // New script input data
  status?: string; // New status: active, paused, completed, failed
}
export interface FlowsDeleteFlowArgs {
  id: string; // Flow ID to delete
}
export interface FlowsPauseFlowArgs {
  id: string; // Flow ID to pause
}
export interface FlowsResumeFlowArgs {
  id: string; // Flow ID to resume
}
export interface FlowsSearchFlowsArgs {
  status?: string; // Filter by status (or array of statuses)
  triggerType?: string; // Filter by trigger type: time or event
  limit?: number; // Maximum number of results (default: 100)
  offset?: number; // Pagination offset (default: 0)
}
export interface FlowsRecordExecutionArgs {
  id: string; // Flow ID
  success: boolean; // Whether execution succeeded
  result?: any; // Execution result data
  error?: string; // Error message if execution failed
}
export interface FlowsListEventTypesArgs {
  includeTemplates?: boolean; // Include condition templates for each event type
}
export interface FlowsTestFlowArgs {
  flowId: string; // ID of the flow to test
  dryRun?: boolean; // If true (default), only validate trigger matching without executing script. If false, execute the script (causes side effects).
  eventOverrides?: any; // Custom field values to merge into the generated test event (e.g., {"content.text": "custom message"})
}
export interface FlowsValidateTriggerArgs {
  flowId: string; // ID of the flow
  event: any; // Event object to test against the trigger (must match IntegrationEvent structure)
}
export interface FlowsGetFlowsByEventTypeArgs {
  eventType: string; // Event type to filter by (e.g., "call.action", "call.ended", "telegram.message")
}
export interface FlowsCreateBatchOperationArgs {
  title: string; // Human-readable title for this batch operation (e.g., "Leave 100 Telegram groups")
  operations: any[]; // Array of operations to execute. Each item must have adapter, operation, and args properties.
  batchSize?: number; // Number of operations to process per execution (default: 5)
  intervalSeconds?: number; // Seconds between batch executions (default: 60, minimum: 60)
}

// User Adapter Types
export interface UserUpdateProfileArgs {
  username?: string; // New username (3-30 characters, alphanumeric with underscores/hyphens)
  email?: string; // New email address
  timezone?: string; // IANA timezone identifier (e.g., America/Los_Angeles)
  phoneNumber?: string; // Phone number (7-15 digits with optional formatting)
}
export interface UserUpdatePreferencesArgs {
  timezone?: string; // Preferred timezone for scheduling
  socials?: any; // Social media links (twitter, discord)
}
export interface UserDeactivateAccountArgs {
  confirm: boolean; // Must be true to confirm account deactivation
}

// Contacts Adapter Types
export interface ContactsListContactsArgs {
  limit?: number; // Maximum number of contacts to return (default: 100)
  offset?: number; // Number of contacts to skip for pagination (default: 0)
}
export interface ContactsGetContactArgs {
  contactId?: string; // The contact user ID (MongoDB ObjectId)
  username?: string; // The contact username
}
export interface ContactsAddContactArgs {
  username: string; // Username of the user to add as a contact
}
export interface ContactsRemoveContactArgs {
  contactId?: string; // The contact user ID to remove
  username?: string; // The contact username to remove
}
export interface ContactsSearchContactsArgs {
  query: string; // Search query - can be username, email, phone, or wallet address
  searchType?: string; // Type of search to perform: all, username, email, phone, or wallet (default: all)
  limit?: number; // Maximum number of results (default: 20)
}
export interface ContactsBlockContactArgs {
  contactId?: string; // The user ID to block
  username?: string; // The username to block
}
export interface ContactsUnblockContactArgs {
  contactId?: string; // The user ID to unblock
  username?: string; // The username to unblock
}
export interface ContactsGetBlockedContactsArgs {
  limit?: number; // Maximum number of results (default: 100)
  offset?: number; // Number of items to skip for pagination (default: 0)
}
export interface ContactsGetContactRequestsArgs {
  type?: string; // Type of requests to retrieve: all, sent, or received (default: all)
  status?: string; // Filter by request status: pending, accepted, or rejected (default: pending)
}

// Memory Adapter Types
export interface MemoryCreateArgs {
  type: string; // Memory subtype: "note" (general notes), "idea" (concepts/ideas), "shopping_item" (shopping list), "topic" (general knowledge), "document" (documents), "contact" (people), "event" (calendar items). For tasks with assignment, use createTask instead.
  content: string; // Main content/description of the memory
  metadata?: any; // Additional metadata (e.g., priority, deadline, tags, etc.)
}
export interface MemoryCreateTaskArgs {
  content: string; // Task description/title - what needs to be done. IMPORTANT: Write task content from a neutral perspective without possessive pronouns (his/her/their). The assignee will see this exact text, so "fold dresses" is correct, NOT "fold her dresses". Avoid phrases like "remind him to", "help her with", etc.
  assignedTo?: string; // Username of the person to assign this task to (group contexts only). System resolves username to user ID.
  dueAt?: string; // Due date/time in ISO 8601 format (e.g., "2024-01-15T10:00:00Z") or natural language that will be parsed
  priority?: string; // Task priority: "high", "medium", or "low"
  tags?: any[]; // Tags/labels for categorization (e.g., ["work", "urgent"])
}
export interface MemorySearchArgs {
  query: string; // Search query text for semantic matching
  types?: any[]; // Filter by entity types (e.g., ["TASK", "NOTE", "IDEA"])
  startTime?: number; // Filter entities created after this timestamp (Unix milliseconds)
  endTime?: number; // Filter entities created before this timestamp (Unix milliseconds)
  propertyFilters?: any; // Filter by entity properties: { status: ["completed"], tags: ["urgent"], priority: ["high"], roles: ["task"], contexts: ["work"] }
  limit?: number; // Maximum number of results (default: 50, max: 100)
}
export interface MemoryQueryArgs {
  type?: string; // Semantic type filter (e.g., "task", "note", "idea", "reminder", "contact", "document"). Matches against meta_item_type, subType, or semantic_roles
  filters?: any; // Additional filters (not yet implemented)
  limit?: number; // Maximum results (default: 50, max: 100)
  offset?: number; // Pagination offset for fetching more results (default: 0)
}
export interface MemoryFindOneArgs {
  filters: any; // Filter criteria. Use { id: "entity_id" } to find by ID (recommended), or { name: "entity name" } to find by name.
}
export interface MemoryUpdateArgs {
  id: string; // Entity ID to update
  type?: string; // Entity type
  content?: string; // Updated content
  metadata?: any; // Updated metadata
}
export interface MemoryDeleteArgs {
  id: string; // Entity ID to delete
}
export interface MemoryShareArgs {
  entityId: string; // Entity ID to share
  targetGraphId: string; // Target graph ID to share with (group ID or user contact graph ID)
  shareReason?: string; // Optional reason for sharing
}
export interface MemoryUnshareArgs {
  entityId: string; // Entity ID to unshare
  graphId: string; // Graph ID to remove sharing from
}
export interface MemoryListGraphsArgs {
  entityId: string; // Entity ID to list graphs for
}

// AI Services Adapter Types
export interface AiChatArgs {
  messages: any[]; // Array of message objects with role ("system" | "user" | "assistant") and content (string). System messages set AI behavior, user messages are queries, assistant messages are previous AI responses.
  model?: string; // Specific model to use. Default: "claude-3-haiku-20240307". Use Anthropic Claude model names.
  temperature?: number; // Creativity level 0.0-1.0. Lower=factual/consistent, Higher=creative/varied. Default: 0.7
  maxTokens?: number; // Maximum tokens in response. Default: 1000. Increase for longer responses (costs more tokens).
}
export interface AiDecideArgs {
  prompt: string; // The decision prompt - what needs to be decided and why
  options: any[]; // Array of options to choose from. Each option must have: id (unique identifier), label (descriptive name), and optional metadata (additional data)
  context?: string; // Additional context to help the AI make a better decision
  model?: string; // Specific model to use. Defaults to system default.
}

// Documents Adapter Types
export interface DocumentUploadArgs {
  file: string; // Base64 encoded file content
  filename: string; // Original filename with extension
  mimeType: string; // MIME type (application/pdf, text/plain, etc.)
  graphId?: string; // Target graph ID (defaults to user's personal graph)
  title?: string; // Custom document title
  productTags?: any[]; // Array of product tags for categorization
}
export interface DocumentGetArgs {
  documentId: string; // Document ID to retrieve
}
export interface DocumentGetStatusArgs {
  documentId: string; // Document ID to check
}
export interface DocumentGetChunksArgs {
  documentId: string; // Document ID
}
export interface DocumentDeleteArgs {
  documentId: string; // Document ID to delete
}
export interface DocumentShareArgs {
  documentId: string; // Document ID to share
  targetGraphId: string; // Target graph ID to share to
  shareReason?: string; // Optional reason for sharing
}
export interface DocumentUnshareArgs {
  documentId: string; // Document ID
  graphId: string; // Graph ID to remove access from
}
export interface DocumentListGraphsArgs {
  documentId: string; // Document ID
}
export interface DocumentSearchArgs {
  query: string; // Search query
  graphId?: string; // Graph ID to search in (defaults to user's graph)
  limit?: number; // Maximum results (default: 10)
  threshold?: number; // Similarity threshold 0-1 (default: 0.7)
}
export interface DocumentListArgs {
  graphId?: string; // Graph ID to list documents from (defaults to user's graph)
  limit?: number; // Maximum results (default: 50)
  offset?: number; // Pagination offset (default: 0)
}

// Feed Items Adapter Types
export interface FeedItemsCreateFeedItemArgs {
  title: string; // Main title of the feed item (shown prominently)
  subtitle?: string; // Optional subtitle (shown below title in muted color)
  blocks: any[]; // Array of content blocks to display (text, key_value, list, timestamp, user_mention, divider, image, progress)
  itemType: string; // Type: informative (FYI), actionable (needs response), or error
  actions?: any[]; // Optional action buttons for the feed item
  avatar?: any; // Optional avatar to show (user profile, icon, or custom image)
  metadata?: any; // Additional metadata (searchable, not displayed)
}

// Telegram Adapter Types
export interface TelegramSendMessageArgs {
  chatId: string; // Chat ID (numeric) or username (e.g., @username) to send the message to. Chat IDs can be obtained from searchChats operation.
  text: string; // The text content of the message to send
}
export interface TelegramSearchChatsArgs {
  query?: string; // Text to search in chat names/usernames. Supports fuzzy matching with relevance scoring.
  type?: string; // Filter by chat type: "private", "group", "channel", or "all" (default: "all")
  inactiveSince?: string; // Find chats with no activity since date. Accepts ISO date or relative like "30 days ago", "1 week ago"
  activeSince?: string; // Find chats with activity since date. Accepts ISO date or relative like "7 days ago"
  hasUnread?: boolean; // Filter by unread status: true = only unread, false = only read
  archived?: boolean; // Filter by archived status
  pinned?: boolean; // Filter by pinned status
  sortBy?: string; // Sort results: "relevance" (default with query), "lastActivity" (default without query), "unreadCount", "name"
  limit?: number; // Max results (default: 50, max: 100)
  offset?: number; // Pagination offset (default: 0)
  forceRefresh?: boolean; // Bypass cache and fetch fresh data
}
export interface TelegramSearchMessagesArgs {
  query: string; // Text query to search for in messages
  chatIds?: any[]; // Array of chat IDs to search within. Omit for global search across all chats.
  chatType?: string; // Filter by chat type (for global search): "private", "group", or "channel"
  fromDate?: string; // ISO date string for start of date range
  toDate?: string; // ISO date string for end of date range
  limit?: number; // Maximum number of messages to return (default: 100, max: 100)
  senderId?: string; // Filter messages by sender ID
}
export interface TelegramGetChatMessagesArgs {
  chatId: string; // Chat ID to retrieve messages from
  limit?: number; // Maximum number of messages to return (default: 50, max: 100)
  offsetId?: number; // Message ID to use as pagination offset
  minDate?: string; // ISO date string for minimum message date
  maxDate?: string; // ISO date string for maximum message date
}
export interface TelegramGetUnreadSummaryArgs {
  chatIds?: any[]; // Array of chat IDs to filter by. If not provided, checks all chats.
  priorityOnly?: boolean; // If true, only return chats with unread messages
  groupBy?: string; // Group results by "chat" or "sender"
}
export interface TelegramMarkAsReadArgs {
  chatId: string; // Chat ID to mark messages as read in
  maxMessageId?: number; // Maximum message ID to mark as read. If not provided, marks all messages as read.
}
export interface TelegramGetMentionsArgs {
  chatIds?: any[]; // Array of chat IDs to filter mentions by
  sinceDate?: string; // ISO date string - only return mentions since this date
  onlyUnread?: boolean; // If true, only return unread mentions
}
export interface TelegramLeaveGroupArgs {
  chatId: string; // The ID of the group, supergroup, or channel to leave. Can be obtained from searchChats operation.
}

// Gmail Adapter Types
export interface GoogleGmailSendEmailArgs {
  to: string; // Valid email address
  subject: string; // Email subject line
  body: string; // Email body content
  cc?: string; // CC recipients (comma-separated email addresses)
  bcc?: string; // BCC recipients (comma-separated email addresses)
  isHtml?: boolean; // Whether body is HTML format
}
export interface GoogleGmailSearchEmailsArgs {
  query: string; // Gmail search query (e.g., "from:user@example.com is:unread")
  maxResults?: number; // Maximum number of results to return (default: 50, max: 100)
}
export interface GoogleGmailListEmailsArgs {
  maxResults?: number; // Maximum number of results to return (default: 50, max: 100)
}
export interface GoogleGmailGetEmailArgs {
  messageId: string; // Gmail message ID
  includeHtml?: boolean; // Include HTML body content (default: false)
  includeAttachments?: boolean; // Include attachment metadata (default: false)
}
export interface GoogleGmailCreateDraftArgs {
  to: string; // Valid email address
  subject: string; // Email subject line
  body: string; // Email body content
  cc?: string; // CC recipients (comma-separated email addresses)
  bcc?: string; // BCC recipients (comma-separated email addresses)
  isHtml?: boolean; // Whether body is HTML format
}
export interface GoogleGmailUpdateDraftArgs {
  draftId: string; // Gmail draft ID to update
  to?: string; // Updated recipient email address(es)
  subject?: string; // Updated email subject line
  body?: string; // Updated email body content
  cc?: string; // Updated CC recipients
  bcc?: string; // Updated BCC recipients
  isHtml?: boolean; // Whether body is HTML format
}
export interface GoogleGmailDeleteDraftArgs {
  draftId: string; // Gmail draft ID to delete
}
export interface GoogleGmailListDraftsArgs {
  maxResults?: number; // Maximum number of drafts to return (default: 10)
}
export interface GoogleGmailDeleteEmailArgs {
  messageId: string; // Gmail message ID to delete
}
export interface GoogleGmailBulkDeleteEmailsArgs {
  messageIds: any[]; // Array of Gmail message IDs to delete (max 1000 per request)
  permanently?: boolean; // If true, permanently delete. If false (default), move to trash.
}

// Google Calendar Adapter Types
export interface GoogleCalendarCreateEventArgs {
  summary: string; // Event title/summary
  start: any; // Start time object with dateTime and optional timeZone
  end: any; // End time object with dateTime and optional timeZone
  description?: string; // Event description
  location?: string; // Event location
  attendees?: any[]; // Array of attendee email addresses
}
export interface GoogleCalendarListEventsArgs {
  timeMin?: string; // Start time for events to list (ISO 8601)
  timeMax?: string; // End time for events to list (ISO 8601)
  maxResults?: number; // Maximum number of events to return (default: 50, max: 100)
  query?: string; // Search query to filter events
}
export interface GoogleCalendarGetEventsArgs {
  timeMin?: string; // Start time for events to list (ISO 8601)
  timeMax?: string; // End time for events to list (ISO 8601)
  maxResults?: number; // Maximum number of events to return (default: 50, max: 100)
  query?: string; // Search query to filter events
}
export interface GoogleCalendarGetEventArgs {
  eventId: string; // Calendar event ID
}
export interface GoogleCalendarUpdateEventArgs {
  eventId: string; // Calendar event ID to update
  summary?: string; // Updated event title/summary
  description?: string; // Updated event description
  location?: string; // Updated event location
  start?: any; // Updated start time object with dateTime and optional timeZone
  end?: any; // Updated end time object with dateTime and optional timeZone
}
export interface GoogleCalendarDeleteEventArgs {
  eventId: string; // Calendar event ID to delete
}
export interface GoogleCalendarSearchEventsArgs {
  query: string; // Search query to filter events
  timeMin?: string; // Start time for events to search (ISO 8601)
  timeMax?: string; // End time for events to search (ISO 8601)
  maxResults?: number; // Maximum number of events to return (default: 50, max: 100)
}

// Google Drive Adapter Types
export interface GoogleDriveListFilesArgs {
  query?: string; // Search query (Google Drive query syntax)
  pageSize?: number; // Maximum number of files to return (default: 20)
}
export interface GoogleDriveCreateFileArgs {
  name: string; // Name of the file
  mimeType: string; // MIME type of the file
  folderId?: string; // Parent folder ID (optional)
}
export interface GoogleDriveCreateFolderArgs {
  name: string; // Name of the folder
  parentFolderId?: string; // Parent folder ID (optional)
}
export interface GoogleDriveGetFileInfoArgs {
  fileId: string; // ID of the file
}
export interface GoogleDriveShareFileArgs {
  fileId: string; // ID of the file to share
  email?: string; // Email address to share with (optional)
  role?: string; // Permission role: reader, writer, commenter (default: reader)
}
export interface GoogleDriveDownloadFileArgs {
  fileId: string; // ID of the file to download
}
export interface GoogleDriveMoveFileArgs {
  fileId: string; // ID of the file to move
  folderId: string; // ID of the destination folder
}
export interface GoogleDriveDeleteFileArgs {
  fileId: string; // ID of the file or folder to delete
  permanently?: boolean; // If true, permanently delete instead of moving to trash (default: false)
}
export interface GoogleDriveSearchFilesArgs {
  query: string; // Search query using Drive syntax (e.g., "name contains 'report'", "mimeType='application/pdf'")
  pageSize?: number; // Maximum number of files to return (default: 20)
}
export interface GoogleDriveUpdateFileArgs {
  fileId: string; // ID of the file to update
  name?: string; // New name for the file
  description?: string; // New description for the file
}

// Google Sheets Adapter Types
export interface GoogleSheetsCreateSpreadsheetArgs {
  title: string; // Title of the spreadsheet
}
export interface GoogleSheetsReadRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  range: string; // Cell range (e.g., "Sheet1!A1:B10")
}
export interface GoogleSheetsWriteRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  range: string; // Cell range (e.g., "Sheet1!A1:B10")
  values: any[]; // Data to write (2D array)
}
export interface GoogleSheetsAppendRowArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetName: string; // Name of the sheet
  values: any[]; // Row values to append
}
export interface GoogleSheetsGetSpreadsheetArgs {
  spreadsheetId: string; // ID of the spreadsheet
}
export interface GoogleSheetsInsertAtCellArgs {
  spreadsheetId: string; // ID of the spreadsheet
  cell: string; // Cell reference in format SheetName!A1
  value: string; // Value to insert
  bold?: boolean; // Make text bold
  italic?: boolean; // Make text italic
  foregroundColor?: string; // Text color (hex or named color)
  backgroundColor?: string; // Cell background color (hex or named color)
}
export interface GoogleSheetsInsertFormulaArgs {
  spreadsheetId: string; // ID of the spreadsheet
  cell: string; // Cell reference in format SheetName!A1
  formula: string; // Formula to insert (with or without leading =)
  note?: string; // Optional note to add to the cell
}
export interface GoogleSheetsFormatRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  range: string; // Range in format SheetName!A1:B10
  bold?: boolean; // Make text bold
  italic?: boolean; // Make text italic
  foregroundColor?: string; // Text color (hex or named color)
  backgroundColor?: string; // Cell background color (hex or named color)
  borders?: boolean; // Add borders to cells
}
export interface GoogleSheetsCreateChartArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // ID of the sheet containing data
  dataRange: string; // Data range for the chart (e.g., A1:B10)
  chartType: string; // Chart type: BAR, LINE, AREA, PIE, or SCATTER
  title: string; // Chart title
  position: any; // Chart position with row, column, rowCount, columnCount
}
export interface GoogleSheetsFindAndReplaceArgs {
  spreadsheetId: string; // ID of the spreadsheet
  findText: string; // Text to find
  replaceText: string; // Text to replace with
  sheetName?: string; // Limit search to specific sheet
  matchCase?: boolean; // Case-sensitive search
  matchEntireCell?: boolean; // Match entire cell content only
}
export interface GoogleSheetsInsertMultipleRowsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetName: string; // Name of the sheet
  rowsData: any[]; // 2D array of row data to insert
  startingRow?: number; // Row number to start insertion (1-indexed). If not provided, appends to end
  formattingOptions?: any; // Optional formatting to apply (bold, italic, foregroundColor, backgroundColor, borders)
}
export interface GoogleSheetsClearRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetName: string; // Name of the sheet
  range: string; // Range to clear (e.g., A1:B10)
}
export interface GoogleSheetsInsertRowsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
  startRowIndex: number; // Row index to start inserting at (0-indexed). To insert before row 5 in the UI, use index 4.
  numRows: number; // Number of rows to insert
}
export interface GoogleSheetsDeleteRowsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
  startRowIndex: number; // Row index to start deleting from (0-indexed). To delete row 5 in the UI, use index 4.
  numRows: number; // Number of rows to delete
}
export interface GoogleSheetsInsertColumnsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
  startColumnIndex: number; // Column index to start inserting at (0-indexed: A=0, B=1, C=2, D=3, etc.). To insert before column D, use index 3.
  numColumns: number; // Number of columns to insert
}
export interface GoogleSheetsDeleteColumnsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
  startColumnIndex: number; // Column index to start deleting from (0-indexed: A=0, B=1, C=2, D=3, etc.). To delete column D, use index 3.
  numColumns: number; // Number of columns to delete
}
export interface GoogleSheetsCopyRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sourceSheetId: number; // Numeric sheet ID of the source sheet (get from getSpreadsheet response: sheets[n].properties.sheetId)
  sourceRange: string; // Source range in A1 notation WITHOUT sheet name (e.g., "A1:C5", not "Sheet1!A1:C5")
  targetSheetId: number; // Numeric sheet ID of the target sheet (can be same as sourceSheetId to copy within same sheet)
  targetStartCell: string; // Target start cell in A1 notation (e.g., "E1"). The copied data will fill cells starting from this position.
}

// Google Docs Adapter Types
export interface GoogleDocsCreateDocumentArgs {
  title: string; // Title of the document
}
export interface GoogleDocsGetDocumentArgs {
  documentId: string; // ID of the document
}
export interface GoogleDocsAppendTextArgs {
  documentId: string; // ID of the document
  text: string; // Text to append
}
export interface GoogleDocsReplaceTextArgs {
  documentId: string; // ID of the document
  searchText: string; // Text to search for
  replaceText: string; // Text to replace with
}
export interface GoogleDocsGetDocumentContentArgs {
  documentId: string; // ID of the document
}
export interface GoogleDocsInsertTextAtPositionArgs {
  documentId: string; // ID of the document
  text: string; // Text to insert
  position: number; // Character position to insert at (1-indexed)
}
export interface GoogleDocsInsertTextAfterArgs {
  documentId: string; // ID of the document
  searchText: string; // Text to search for
  textToInsert: string; // Text to insert after the search text
  occurrence?: number; // Which occurrence to insert after (default: 1)
}
export interface GoogleDocsInsertHeadingArgs {
  documentId: string; // ID of the document
  text: string; // Heading text
  level: number; // Heading level (1-6)
  position?: number; // Character position to insert at
  insertAfterText?: string; // Insert after this text instead of at position
}
export interface GoogleDocsInsertListArgs {
  documentId: string; // ID of the document
  items: any[]; // Array of list items
  listType: string; // Type of list: "bulleted" or "numbered"
  position?: number; // Character position to insert at
  insertAfterText?: string; // Insert after this text instead of at position
}
export interface GoogleDocsInsertTableArgs {
  documentId: string; // ID of the document
  data: any[]; // 2D array of table data (rows x columns)
  hasHeader?: boolean; // Whether the first row is a header (default: true)
  position?: number; // Character position to insert at
  insertAfterText?: string; // Insert after this text instead of at position
}
export interface GoogleDocsUpdateDocumentContentArgs {
  documentId: string; // ID of the document
  newContent: string; // New content to replace existing content
}
export interface GoogleDocsCreateSectionArgs {
  documentId: string; // ID of the document
  heading: string; // Section heading text
  content: string; // Section content text
}
export interface GoogleDocsFindInsertionPointArgs {
  documentId: string; // ID of the document
  position: number; // Position to find (1 for start, -1 for end)
  searchText?: string; // Text to search for (returns position after this text)
}

// Jira Adapter Types
export interface JiraCreateIssueArgs {
  projectKey: string; // Jira project key (e.g., "PROJ")
  summary: string; // Issue summary/title
  description?: string; // Issue description
  issueType?: string; // Issue type (Task, Bug, Story, etc.)
}
export interface JiraSearchIssuesArgs {
  jql: string; // JQL query string
  maxResults?: number; // Maximum number of results (default: 50, max: 100)
}
export interface JiraGetIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123") or ID
}
export interface JiraUpdateIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
  summary?: string; // New issue summary/title
  description?: string; // New issue description
}
export interface JiraDeleteIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
}
export interface JiraAddCommentArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
  comment: string; // Comment text
}
export interface JiraTransitionIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
  transitionId: string; // ID of the transition to perform
}
export interface JiraAssignIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
  accountId: string; // Atlassian account ID of the assignee
}
export interface JiraGetProjectMetadataArgs {
  projectKey: string; // Project key (e.g., "PROJ")
}
export interface JiraGetTransitionsArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
}
export interface JiraListAssignableUsersArgs {
  projectKey: string; // Project key (e.g., "PROJ")
}
export interface JiraGetIssueTypesArgs {
  projectKey: string; // Project key (e.g., "PROJ")
}
export interface JiraDiscoverExtendedArgs {
  query: string; // Describe what you want to do (e.g., "add label to card")
  limit?: number; // Max results to return (default 5)
}
export interface JiraExecuteExtendedArgs {
  operationId: string; // The operationId from discoverExtended results
  pathParams?: any; // Path parameters, e.g., { id: "abc123" }
  queryParams?: any; // Query string parameters
  body?: any; // Request body for POST/PUT/PATCH operations
}

// Twitter Adapter Types
export interface TwitterPostTweetArgs {
  text: string; // Tweet text (max 280 characters)
}
export interface TwitterGetUserTweetsArgs {
  userId?: string; // Twitter user ID (recommended for stability and speed). Provide userId OR userName, not both.
  userName?: string; // Twitter username/handle without @ symbol (e.g., "elonmusk"). Provide userName OR userId, not both.
  cursor?: string; // Pagination cursor from previous response's nextCursor field. Do not fabricate cursor values.
  includeReplies?: boolean; // Whether to include replies in results. Defaults to false (only original tweets).
}
export interface TwitterAdvancedSearchArgs {
  query: string; // Search query with advanced syntax. Examples: "from:elonmusk", "bitcoin since:2024-01-01", "AI OR \"machine learning\"". Supported operators: from:user, to:user, since:YYYY-MM-DD, until:YYYY-MM-DD, lang:xx, filter:media, filter:links, -filter:retweets, AND, OR, -keyword, "exact phrase".
  queryType?: string; // Type of search results: "Latest" (most recent) or "Top" (most relevant). Defaults to "Latest". Only these two values are valid.
  cursor?: string; // Pagination cursor from previous response's nextCursor field. Do not fabricate cursor values.
}

// Trello Adapter Types
export interface TrelloGetBoardArgs {
  boardId: string; // The ID of the board to retrieve
}
export interface TrelloCreateCardArgs {
  name: string; // Card name/title
  idList: string; // ID of the list to add the card to
  desc?: string; // Card description (supports markdown)
}
export interface TrelloGetCardArgs {
  cardId: string; // The ID of the card to retrieve
}
export interface TrelloUpdateCardArgs {
  cardId: string; // The ID of the card to update
  name?: string; // New card name
  desc?: string; // New card description
  idList?: string; // Move card to a different list
  closed?: boolean; // Archive the card
}
export interface TrelloDeleteCardArgs {
  cardId: string; // The ID of the card to delete
}
export interface TrelloCreateChecklistArgs {
  cardId: string; // The ID of the card to add the checklist to
  name: string; // Checklist name
}
export interface TrelloGetChecklistArgs {
  checklistId: string; // The ID of the checklist to retrieve
}
export interface TrelloUpdateChecklistArgs {
  checklistId: string; // The ID of the checklist to update
  name: string; // New checklist name
}
export interface TrelloDeleteChecklistArgs {
  checklistId: string; // The ID of the checklist to delete
}
export interface TrelloAddCheckItemArgs {
  checklistId: string; // The ID of the checklist to add the item to
  name: string; // Check item text
}
export interface TrelloUpdateCheckItemArgs {
  cardId: string; // The ID of the card containing the check item
  checkItemId: string; // The ID of the check item to update
  name?: string; // New check item text
  state?: string; // Check state: "complete" or "incomplete"
}
export interface TrelloDeleteCheckItemArgs {
  checklistId: string; // The ID of the checklist containing the item
  checkItemId: string; // The ID of the check item to delete
}
export interface TrelloDiscoverExtendedArgs {
  query: string; // Describe what you want to do (e.g., "add label to card")
  limit?: number; // Max results to return (default 5)
}
export interface TrelloExecuteExtendedArgs {
  operationId: string; // The operationId from discoverExtended results
  pathParams?: any; // Path parameters, e.g., { id: "abc123" }
  queryParams?: any; // Query string parameters
  body?: any; // Request body for POST/PUT/PATCH operations
}

// Jupiter Adapter Types
export interface JupiterSwapArgs {
  inputMint: string; // Input token mint address
  outputMint: string; // Output token mint address
  amount: number; // Amount to swap (in smallest unit)
  inputDecimals: number; // Number of decimals for input token
  slippageBps?: number; // Slippage tolerance in basis points (default: 50)
}
export interface JupiterGetHoldingsArgs {
  walletAddress?: string; // Wallet address to check (uses actor wallet if not provided)
}
export interface JupiterGetTokenSecurityArgs {
  tokenMint: string; // Token mint address to check security for
}
export interface JupiterSearchTokensArgs {
  query: string; // Search query (symbol, name, or mint address)
}
export interface JupiterRefreshSwapArgs {
  feedItemId: string; // Feed item ID containing the swap to refresh
  swapId: string; // Original swap ID
  inputMint: string; // Input token mint address
  outputMint: string; // Output token mint address
  amount: number; // Amount to swap (in UI units)
  inputDecimals: number; // Input token decimals
  slippageBps?: number; // Slippage tolerance in basis points
}

// Crypto Adapter Types
export interface CryptoGetPriceArgs {
  tokenAddress: string; // Token contract address (EVM: 0x..., SVM: base58)
  chainName?: string; // Specific chain name (auto-detected if not provided)
}
export interface CryptoSendTokenArgs {
  recipient: string; // Contact username, user ID, or Solana wallet address
  token: string; // Token symbol (SOL, USDC), name, or mint address
  amount: number; // Amount to send (in UI units)
}
export interface CryptoMonitorPriceArgs {
  tokenAddress: string; // Token contract address to monitor
  direction: string; // Alert direction: "above" or "below"
  targetPrice: number; // Target price in USD to trigger alert
  scriptId: string; // ID of the script to execute when price target is reached
  chainName?: string; // Chain name (auto-detected if not provided)
  percentStep?: number; // Progressive alert step percentage (default: 0.1 = 10%)
}
export interface CryptoUnsubscribeAssetArgs {
  tokenAddress: string; // Token address to stop monitoring
}
export interface CryptoRefreshTransactionArgs {
  feedItemId: string; // Feed item ID containing the transaction to refresh
  transferId: string; // Original transfer ID
  recipient: string; // Recipient address
  token: string; // Token symbol or mint address
  amount: number; // Amount to send
  tokenMint?: string; // Token mint address (optional, will resolve if not provided)
  tokenDecimals?: number; // Token decimals (optional)
}

// Scripts Adapter Types
export interface ScriptsCreateScriptArgs {
  name: string; // Name of the script
  description?: string; // Description of what the script does
  runtime?: string; // Lambda runtime (default: nodejs18)
  config?: any; // Script configuration (timeout, memory, maxCostPerExecution, etc.)
  code: string; // Initial JavaScript/TypeScript code for the script
}
export interface ScriptsDeleteScriptArgs {
  scriptId: string; // ID of the script to delete
}
export interface ScriptsCreateVersionArgs {
  scriptId: string; // ID of the script
  code: string; // Updated code for the new version
  commitMessage?: string; // Description of changes in this version
}
export interface ScriptsListVersionsArgs {
  scriptId: string; // ID of the script
}
export interface ScriptsDeployScriptArgs {
  scriptId: string; // ID of the script to deploy (from createScript response at data._id)
  version?: number; // Version number to deploy (default: latest)
}
export interface ScriptsExecuteScriptArgs {
  scriptId: string; // ID of the script to execute (from createScript response at data._id)
  data?: any; // Input data to pass to the script
  trigger?: any; // Trigger information (type, source, event)
}
export interface ScriptsGetScriptArgs {
  scriptId: string; // ID of the script
}
export interface ScriptsGetExecutionsArgs {
  scriptId: string; // ID of the script
  status?: string; // Filter by status (completed, failed, running)
  limit?: number; // Maximum number of executions to return (default: 100)
}
export interface ScriptsGetExecutionArgs {
  executionId: string; // ID of the execution
}
export interface ScriptsPublishScriptArgs {
  scriptId: string; // ID of the script to publish
  pricing?: any; // Pricing configuration for the marketplace
}
export interface ScriptsUnpublishScriptArgs {
  scriptId: string; // ID of the script to unpublish
}
export interface ScriptsListMarketplaceScriptsArgs {
  name?: string; // Exact match on script name
  system?: boolean; // Filter by system scripts (scope="system") when true, user scripts when false
  search?: string; // Text search on name and description
  tags?: any[]; // Filter by tags (matches scripts with any of the specified tags)
  category?: string; // Filter by UI category (notification, data_sync, automation, utility, reporting)
  pricingModel?: string; // Filter by pricing model (free, pay-per-execution, subscription)
  staffPick?: boolean; // Filter to only staff-picked scripts when true
  minRating?: number; // Minimum rating threshold (0-5)
  requiredIntegrations?: any[]; // Filter by required integrations (e.g., ["telegram", "gmail"])
  sortBy?: string; // Sort field: rating, installCount, trendingScore, publishedAt, name (default: rating)
  sortOrder?: string; // Sort order: asc or desc (default: desc)
  limit?: number; // Maximum number of results to return (default: 50, max: 100)
  offset?: number; // Number of results to skip for pagination (default: 0)
}
export interface ScriptsGetMetricsArgs {
  scriptId: string; // ID of the script
}
export interface ScriptsCreateWebhookArgs {
  scriptId: string; // ID of the script
  name: string; // Name of the webhook
  enabled?: boolean; // Whether webhook is enabled (default: true)
}
export interface ScriptsCreateScheduleArgs {
  scriptId: string; // ID of the script
  name: string; // Name of the schedule
  cronExpression: string; // Cron expression (e.g., "0 9 * * *" for daily at 9am)
  enabled?: boolean; // Whether schedule is enabled (default: true)
  data?: any; // Data to pass to the script on scheduled execution
}
export interface ScriptsGetFlowScriptArgs {
  flowId: string; // ID of the flow to get script code for
}
export interface ScriptsModifyFlowScriptArgs {
  flowId: string; // ID of the flow to modify
  newCode: string; // New code to deploy
  commitMessage?: string; // Description of changes
}
export interface ScriptsLintScriptArgs {
  code: string; // The script code to validate
}

// Feedback Adapter Types
export interface FeedbackReportBugArgs {
  title: string; // Brief bug description
  description: string; // Detailed description of the bug
  severity: string; // Bug severity: critical, high, medium, or low
  stepsToReproduce?: any[]; // Steps to reproduce the bug
  expectedBehavior?: string; // What should happen
  actualBehavior?: string; // What actually happens
  errorDetails?: any; // Error details: { message, stack, code }
  context?: any; // Additional context: { conversationId, recentMessages, platform, appVersion }
  llmAnalysis?: string; // LLM analysis of the issue
}
export interface FeedbackReportToolFailureArgs {
  adapterType: string; // Adapter type (e.g., jupiter, crypto)
  operation: string; // Operation that failed (e.g., swap, sendToken)
  errorMessage: string; // Error message from the failure
  errorCode?: string; // Error code if available
  errorStack?: string; // Error stack trace
  args?: any; // Sanitized arguments that caused the failure
  llmAnalysis?: string; // LLM analysis of why it failed
  suggestedFix?: string; // LLM suggested fix
  context?: any; // Additional context: { conversationId, userId, timestamp }
}
export interface FeedbackReportMissingCapabilityArgs {
  userRequest: string; // What the user asked for
  reason: string; // Why it could not be fulfilled
  suggestedCapability?: string; // What capability would enable this
  relatedAdapters?: any[]; // Adapters that might be relevant
  context?: any; // Additional context: { conversationId }
}
export interface FeedbackSubmitFeedbackArgs {
  sentiment: string; // Sentiment: positive, negative, or neutral
  feedback: string; // Feedback content
  category?: string; // Category: ux, performance, feature, or general
  context?: any; // Additional context: { feature, screen }
}
export interface FeedbackSubmitFeatureRequestArgs {
  title: string; // Feature title
  description: string; // Feature description
  useCase?: string; // Why the user needs this feature
  priority?: string; // Priority: high, medium, or low
}

// Mirra Messaging Adapter Types
export interface MirraMessagingSendMessageArgs {
  groupId: string; // Group ID to send the message to (use getContacts or getGroups to get the groupId)
  content: string; // Message text content
  automation?: any; // Automation metadata: { source: string, flowId?: string, flowTitle?: string, sessionId?: string, isAutomated?: boolean }. Use sessionId to group related messages and enable Flow-based reply routing.
  structuredData?: any[]; // Structured data for rich UI rendering: [{ displayType, templateId, data, metadata?, interactions? }]
}
export interface MirraMessagingUpdateMessageArgs {
  messageId: string; // ID of the message to update
  content: string; // New message text content
  structuredData?: any[]; // Updated structured data for rich UI rendering
}
export interface MirraMessagingGetContactsArgs {
  limit?: number; // Maximum number of contacts to return (default 50)
  offset?: number; // Offset for pagination (default 0)
}
export interface MirraMessagingFindContactArgs {
  query: string; // Username or name to search for
}
export interface MirraMessagingGetChatsArgs {
  scope?: string; // Filter by scope: direct, user, group, or all (default all)
  limit?: number; // Maximum number of chats to return (default 50)
}
export interface MirraMessagingGetGroupsArgs {
  limit?: number; // Maximum number of groups to return (default 50)
}
export interface MirraMessagingCreateGroupArgs {
  name: string; // Group name (max 100 characters)
  description?: string; // Group description (max 500 characters)
  category?: string; // Category for organization: "family", "friends", "work", or "other" (default: "other")
  memberIds?: any[]; // Array of user IDs to add as initial members
}
export interface MirraMessagingSearchMessagesArgs {
  query: string; // Keywords to search for
  contactName?: string; // Contact name to filter by sender (resolved to userId)
  groupName?: string; // Group name to limit search (resolved to groupId)
  groupId?: string; // Group ID to limit search (use groupName for name-based lookup)
  scope?: string; // "direct", "group", or "all" (default)
  startDate?: string; // ISO date for time range start
  endDate?: string; // ISO date for time range end
  includeFullText?: boolean; // Include full message text (default: false, returns snippets)
  snippetLength?: number; // Max chars for snippet (default: 200)
  limit?: number; // Max results (default 20, max 50)
  offset?: number; // Pagination offset
}

// Moltbook Adapter Types
export interface MoltbookRegisterAgentArgs {
  agentName: string; // Unique name for your agent (alphanumeric, underscores allowed)
}
export interface MoltbookCreatePostArgs {
  content: string; // Post content/body text
  title?: string; // Post title (optional)
  type?: string; // Post type: "text" or "link" (default: text)
  url?: string; // URL for link posts
  submolt?: string; // Community name to post in (optional)
}
export interface MoltbookGetPostsArgs {
  sort?: string; // Sort order: "hot", "new", "top", "rising" (default: hot)
  limit?: number; // Max posts to return (default: 25)
  submolt?: string; // Filter by community name
}
export interface MoltbookGetPostArgs {
  postId: string; // Post ID
}
export interface MoltbookDeletePostArgs {
  postId: string; // Post ID to delete
}
export interface MoltbookCreateCommentArgs {
  postId: string; // Post ID to comment on
  content: string; // Comment content
  parentId?: string; // Parent comment ID for replies
}
export interface MoltbookGetCommentsArgs {
  postId: string; // Post ID
  sort?: string; // Sort: "top", "new", "controversial" (default: top)
}
export interface MoltbookUpvotePostArgs {
  postId: string; // Post ID to upvote
}
export interface MoltbookDownvotePostArgs {
  postId: string; // Post ID to downvote
}
export interface MoltbookUpvoteCommentArgs {
  commentId: string; // Comment ID to upvote
}
export interface MoltbookCreateSubmoltArgs {
  name: string; // Community name (alphanumeric, underscores)
  description: string; // Community description
}
export interface MoltbookGetSubmoltArgs {
  name: string; // Community name
}
export interface MoltbookSubscribeArgs {
  name: string; // Community name to subscribe to
}
export interface MoltbookUnsubscribeArgs {
  name: string; // Community name to unsubscribe from
}
export interface MoltbookFollowAgentArgs {
  agentName: string; // Agent name to follow
}
export interface MoltbookUnfollowAgentArgs {
  agentName: string; // Agent name to unfollow
}
export interface MoltbookGetProfileArgs {
  agentName: string; // Agent name
}
export interface MoltbookUpdateProfileArgs {
  description?: string; // New profile description
  metadata?: any; // Additional metadata
}
export interface MoltbookGetFeedArgs {
  limit?: number; // Max posts to return (default: 25)
}
export interface MoltbookSearchArgs {
  query: string; // Search query
}


// ============================================================================
// Response Type Definitions
// ============================================================================

// Telegram Response Types
export interface TelegramSendMessageData {
  messageId: number; // ID of the sent message
  chatId: string; // Chat ID where message was sent
  text: string; // Message text that was sent
  sentAt: string; // ISO 8601 timestamp when sent
}

export type TelegramSendMessageResult = AdapterResultBase<TelegramSendMessageData>;

export interface TelegramChat {
  id: string; // Chat ID
  title: string; // Chat title/name
  type: 'private' | 'group' | 'channel'; // Chat type
  username: string | null; // Chat username (if available)
  lastMessageDate: string | null; // ISO 8601 date of last message
  unreadCount: number; // Number of unread messages
  unreadMentionsCount: number; // Number of unread mentions
  pinned: boolean; // Whether chat is pinned
  archived: boolean; // Whether chat is archived
  memberCount: number; // Number of members (for groups/channels)
  relevanceScore?: number; // Relevance score when query is provided
}

export interface TelegramPaginationInfo {
  totalCount: number; // Total number of matching chats
  limit: number; // Maximum items per page
  offset: number; // Current offset
  hasMore: boolean; // Whether more results are available
}

export interface TelegramSearchChatsData {
  items: TelegramChat[]; // List of matching chats
  pagination: TelegramPaginationInfo; // Pagination metadata
}

export type TelegramSearchChatsResult = AdapterResultBase<TelegramSearchChatsData>;

export interface TelegramMessage {
  id: string; // Message ID
  text: string; // Message text content
  caption: string | null; // Caption for media messages
  date: string; // ISO 8601 timestamp
  chatId: string; // Chat ID where message was sent
  senderId: string; // Sender user ID
  senderName: string; // Sender display name
  hasMedia: boolean; // Whether message has media attachment
  mediaType: string | null; // Media type: photo, video, document, etc.
  isOutgoing: boolean; // Whether message was sent by the user
  replyToMessageId: string | null; // ID of message being replied to
}

export interface TelegramSearchMessagesData {
  messages: TelegramMessage[]; // List of matching messages
  count: number; // Number of messages returned
}

export type TelegramSearchMessagesResult = AdapterResultBase<TelegramSearchMessagesData>;

export interface TelegramGetChatMessagesData {
  messages: TelegramMessage[]; // List of messages from the chat
  count: number; // Number of messages returned
  chatId?: string; // Chat ID the messages are from
}

export type TelegramGetChatMessagesResult = AdapterResultBase<TelegramGetChatMessagesData>;

export interface TelegramUnreadSummaryEntry {
  chatId: string; // Chat ID
  chatName: string; // Chat display name
  chatType: 'private' | 'group' | 'channel'; // Chat type
  unreadCount: number; // Number of unread messages
  hasMention: boolean; // Whether there are unread mentions
  lastMessageText: string | null; // Text of last message
  lastMessageSender: string | null; // Sender of last message
  lastMessageDate: string | null; // ISO 8601 date of last message
}

export interface TelegramUnreadSummaryData {
  chats: TelegramUnreadSummaryEntry[]; // List of chats with unread information
  totalUnread: number; // Total unread messages across all chats
  chatsWithUnread: number; // Number of chats with unread messages
}

export type TelegramGetUnreadSummaryResult = AdapterResultBase<TelegramUnreadSummaryData>;

export interface TelegramMarkAsReadData {
  success: boolean; // Whether the operation succeeded
  chatId: string; // Chat ID that was marked as read
  markedAt: string; // ISO 8601 timestamp when marked
}

export type TelegramMarkAsReadResult = AdapterResultBase<TelegramMarkAsReadData>;

export interface TelegramMentionsData {
  mentions: TelegramMessage[]; // List of messages with mentions
  count: number; // Number of mentions returned
}

export type TelegramGetMentionsResult = AdapterResultBase<TelegramMentionsData>;

export interface TelegramLeaveGroupData {
  success: boolean; // Whether the operation succeeded
  chatId: string; // Chat ID that was left
  leftAt: string; // ISO 8601 timestamp when left
}

export type TelegramLeaveGroupResult = AdapterResultBase<TelegramLeaveGroupData>;

// Gmail Response Types
export interface GoogleGmailSendEmailData {
  messageId: string; // ID of the sent message
  to: string; // Recipient email address
  subject: string; // Email subject
  sentAt: string; // ISO timestamp when sent
}

export type GoogleGmailSendEmailResult = AdapterResultBase<GoogleGmailSendEmailData>;

export interface GoogleGmailAttachment {
  filename: string; // Attachment filename
  mimeType: string; // MIME type
  size: number; // Size in bytes
  attachmentId: string; // Attachment ID
}

export interface GoogleGmailGetEmailData {
  id: string; // Unique email ID
  threadId: string; // Thread ID
  subject: string; // Email subject
  from: string; // Sender email address
  to: string; // Recipient email address
  cc?: string; // CC recipients
  bcc?: string; // BCC recipients
  date: string; // ISO timestamp of email
  body: string; // Plain text body content
  bodyHtml?: string; // HTML body content
  snippet: string; // Email preview snippet
  labelIds: string[]; // Gmail label IDs
  isUnread: boolean; // Whether email is unread
  hasAttachments: boolean; // Whether email has attachments
  attachments?: GoogleGmailAttachment[]; // Attachment metadata
}

export type GoogleGmailGetEmailResult = AdapterResultBase<GoogleGmailGetEmailData>;

export interface GoogleGmailEmailSummary {
  id: string; // Unique email ID
  threadId: string; // Thread ID
  subject: string; // Email subject
  from: string; // Sender email address
  to: string; // Recipient email address
  date: string; // ISO timestamp
  snippet: string; // Preview snippet
  labelIds: string[]; // Gmail label IDs
  isUnread: boolean; // Whether email is unread
  hasAttachments: boolean; // Whether email has attachments
}

export interface GoogleGmailSearchEmailsData {
  query: string; // Search query used
  count: number; // Number of results
  emails: GoogleGmailEmailSummary[]; // List of matching emails
}

export type GoogleGmailSearchEmailsResult = AdapterResultBase<GoogleGmailSearchEmailsData>;

export interface GoogleGmailListEmailsData {
  query: string; // Search query used
  count: number; // Number of results
  emails: GoogleGmailEmailSummary[]; // List of emails
}

export type GoogleGmailListEmailsResult = AdapterResultBase<GoogleGmailListEmailsData>;

export interface GoogleGmailCreateDraftData {
  draftId: string; // ID of created draft
  subject: string; // Draft subject
  to: string; // Recipient email address
}

export type GoogleGmailCreateDraftResult = AdapterResultBase<GoogleGmailCreateDraftData>;

export interface GoogleGmailUpdateDraftData {
  draftId: string; // ID of updated draft
  updated: boolean; // Whether update succeeded
}

export type GoogleGmailUpdateDraftResult = AdapterResultBase<GoogleGmailUpdateDraftData>;

export interface GoogleGmailDeleteDraftData {
  draftId: string; // ID of deleted draft
  deleted: boolean; // Whether deletion succeeded
}

export type GoogleGmailDeleteDraftResult = AdapterResultBase<GoogleGmailDeleteDraftData>;

export interface GoogleGmailDraftSummary {
  id: string; // Draft ID
  messageId: string; // Associated message ID
  subject: string; // Draft subject
  to: string; // Recipient email
  snippet: string; // Preview snippet
}

export interface GoogleGmailListDraftsData {
  count: number; // Number of drafts
  drafts: GoogleGmailDraftSummary[]; // List of drafts
}

export type GoogleGmailListDraftsResult = AdapterResultBase<GoogleGmailListDraftsData>;

export interface GoogleGmailDeleteEmailData {
  messageId: string; // ID of deleted email
  deleted: 'permanent' | 'trash'; // Type of deletion
}

export type GoogleGmailDeleteEmailResult = AdapterResultBase<GoogleGmailDeleteEmailData>;

export interface GoogleGmailBulkDeleteEmailsData {
  deletedCount: number; // Number of emails deleted
  messageIds: string[]; // IDs of deleted emails
  deleted: 'permanent' | 'trash'; // Type of deletion
}

export type GoogleGmailBulkDeleteEmailsResult = AdapterResultBase<GoogleGmailBulkDeleteEmailsData>;

// Google Calendar Response Types
export interface GoogleCalendarAttendee {
  email: string; // Attendee email address
  name?: string; // Attendee display name
  responseStatus?: string; // Response status: needsAction, declined, tentative, accepted
  isOrganizer?: boolean; // Whether this attendee is the organizer
  isSelf?: boolean; // Whether this is the authenticated user
}

export interface GoogleCalendarGetEventData {
  id: string; // Calendar event ID
  summary: string; // Event title
  description: string; // Event description
  location: string; // Event location
  startTime: string; // Start time (ISO 8601)
  endTime: string; // End time (ISO 8601)
  isAllDay: boolean; // Whether this is an all-day event
  timeZone: string; // Event timezone
  creator: GoogleCalendarAttendee; // Event creator
  organizer: GoogleCalendarAttendee; // Event organizer
  attendees: GoogleCalendarAttendee[]; // List of attendees
  attendeeCount: number; // Number of attendees
  status: string; // Event status: confirmed, tentative, cancelled
  htmlLink: string; // Link to view event in Google Calendar
  isRecurring: boolean; // Whether this is a recurring event
  recurringEventId?: string; // ID of the recurring event series
  created: string; // When the event was created (ISO 8601)
  updated: string; // When the event was last updated (ISO 8601)
}

export type GoogleCalendarGetEventResult = AdapterResultBase<GoogleCalendarGetEventData>;

export interface GoogleCalendarEventSummary {
  id: string; // Calendar event ID
  summary: string; // Event title
  location: string; // Event location
  startTime: string; // Start time (ISO 8601)
  endTime: string; // End time (ISO 8601)
  isAllDay: boolean; // Whether this is an all-day event
  status: string; // Event status: confirmed, tentative, cancelled
  htmlLink: string; // Link to view event in Google Calendar
  isRecurring: boolean; // Whether this is a recurring event
  attendeeCount: number; // Number of attendees
}

export interface GoogleCalendarListEventsData {
  count: number; // Number of events returned
  query?: string; // Search query used
  timeMin?: string; // Start of time range
  timeMax?: string; // End of time range
  events: GoogleCalendarEventSummary[]; // List of calendar events
}

export type GoogleCalendarListEventsResult = AdapterResultBase<GoogleCalendarListEventsData>;

export interface GoogleCalendarListEventsData {
  count: number; // Number of events returned
  query?: string; // Search query used
  timeMin?: string; // Start of time range
  timeMax?: string; // End of time range
  events: GoogleCalendarEventSummary[]; // List of calendar events
}

export type GoogleCalendarGetEventsResult = AdapterResultBase<GoogleCalendarListEventsData>;

export interface GoogleCalendarSearchEventsData {
  count: number; // Number of events returned
  query: string; // Search query used
  timeMin?: string; // Start of time range
  timeMax?: string; // End of time range
  events: GoogleCalendarEventSummary[]; // List of matching calendar events
}

export type GoogleCalendarSearchEventsResult = AdapterResultBase<GoogleCalendarSearchEventsData>;

export interface GoogleCalendarCreateEventData {
  eventId: string; // Created event ID
  summary: string; // Event title
  start: object; // Event start time
  end: object; // Event end time
  htmlLink: string; // Link to view event in Google Calendar
}

export type GoogleCalendarCreateEventResult = AdapterResultBase<GoogleCalendarCreateEventData>;

export interface GoogleCalendarUpdateEventData {
  eventId: string; // Updated event ID
  summary: string; // Event title
  updated: boolean; // Whether the update succeeded
}

export type GoogleCalendarUpdateEventResult = AdapterResultBase<GoogleCalendarUpdateEventData>;

export interface GoogleCalendarDeleteEventData {
  eventId: string; // Deleted event ID
  deleted: boolean; // Whether the deletion succeeded
}

export type GoogleCalendarDeleteEventResult = AdapterResultBase<GoogleCalendarDeleteEventData>;

// Google Drive Response Types
export interface GoogleDriveFileSummary {
  id: string; // File ID
  name: string; // File name
  mimeType: string; // MIME type
  mimeTypeReadable: string; // Human-readable file type
  createdAt: string; // ISO 8601 creation date
  modifiedAt: string; // ISO 8601 modification date
  isFolder: boolean; // Whether this is a folder
}

export interface GoogleDriveListFilesData {
  count: number; // Number of files returned
  query?: string; // Search query used
  files: GoogleDriveFileSummary[]; // Array of file summaries
}

export type GoogleDriveListFilesResult = AdapterResultBase<GoogleDriveListFilesData>;

export interface GoogleDriveSearchFilesData {
  count: number; // Number of files returned
  query: string; // Search query used
  files: GoogleDriveFileSummary[]; // Array of matching file summaries
}

export type GoogleDriveSearchFilesResult = AdapterResultBase<GoogleDriveSearchFilesData>;

export interface GoogleDriveOwner {
  name: string; // Owner name
  email: string; // Owner email
}

export interface GoogleDriveGetFileInfoData {
  id: string; // File ID
  name: string; // File name
  mimeType: string; // MIME type
  mimeTypeReadable: string; // Human-readable file type
  size: number; // File size in bytes
  createdAt: string; // ISO 8601 creation date
  modifiedAt: string; // ISO 8601 modification date
  webViewLink: string | null; // Web view URL
  parents: string[]; // Parent folder IDs
  owner: GoogleDriveOwner | null; // File owner
  isFolder: boolean; // Whether this is a folder
  isTrashed: boolean; // Whether file is in trash
}

export type GoogleDriveGetFileInfoResult = AdapterResultBase<GoogleDriveGetFileInfoData>;

export interface GoogleDriveCreateFileData {
  fileId: string; // Created file ID
  name: string; // File name
  mimeType: string; // MIME type
  webViewLink?: string; // Web view URL
}

export type GoogleDriveCreateFileResult = AdapterResultBase<GoogleDriveCreateFileData>;

export interface GoogleDriveCreateFolderData {
  folderId: string; // Created folder ID
  name: string; // Folder name
  webViewLink?: string; // Web view URL
}

export type GoogleDriveCreateFolderResult = AdapterResultBase<GoogleDriveCreateFolderData>;

export interface GoogleDriveDownloadFileData {
  data: string; // Base64-encoded file content
  mimeType: string; // MIME type of downloaded file
}

export type GoogleDriveDownloadFileResult = AdapterResultBase<GoogleDriveDownloadFileData>;

export interface GoogleDriveMoveFileData {
  fileId: string; // Moved file ID
  name: string; // File name
  moved: boolean; // Whether move succeeded
}

export type GoogleDriveMoveFileResult = AdapterResultBase<GoogleDriveMoveFileData>;

export interface GoogleDriveShareFileData {
  fileId: string; // Shared file ID
  permissionId: string; // Created permission ID
  role: string; // Permission role granted
  shared: boolean; // Whether share succeeded
}

export type GoogleDriveShareFileResult = AdapterResultBase<GoogleDriveShareFileData>;

export interface GoogleDriveDeleteFileData {
  fileId: string; // Deleted file ID
  deleted: string; // Deletion type: permanent or trash
}

export type GoogleDriveDeleteFileResult = AdapterResultBase<GoogleDriveDeleteFileData>;

export interface GoogleDriveUpdateFileData {
  fileId: string; // Updated file ID
  name: string; // File name
  updated: boolean; // Whether update succeeded
}

export type GoogleDriveUpdateFileResult = AdapterResultBase<GoogleDriveUpdateFileData>;

// Google Docs Response Types
/**
 * Normalized document structure with all fields extracted
 */
export interface GoogleDocsGetDocumentData {
  documentId: string; // Unique document ID
  title: string; // Document title
  revisionId: string; // Current revision ID
  body: string; // Plain text content extracted from document
  bodyLength: number; // Character count of body
  lastEditedTime?: string; // ISO 8601 timestamp if available
  url: string; // Link to document
  hasContent: boolean; // Whether document has any text content
}

export type GoogleDocsGetDocumentResult = AdapterResultBase<GoogleDocsGetDocumentData>;

/**
 * Result of document creation
 */
export interface GoogleDocsCreateDocumentData {
  documentId: string; // Created document ID
  title: string; // Document title
}

export type GoogleDocsCreateDocumentResult = AdapterResultBase<GoogleDocsCreateDocumentData>;

/**
 * Result of getDocumentContent operation
 */
export interface GoogleDocsGetDocumentContentData {
  documentId: string; // Document ID
  content: string; // Plain text content
}

export type GoogleDocsGetDocumentContentResult = AdapterResultBase<GoogleDocsGetDocumentContentData>;

/**
 * Result for write operations (append, insert, replace, update)
 */
export interface GoogleDocsWriteOperationData {
  documentId: string; // Document ID
  success: boolean; // Whether operation succeeded
  feedback: string; // Human-readable feedback message
}

export type GoogleDocsAppendTextResult = AdapterResultBase<GoogleDocsWriteOperationData>;
export type GoogleDocsInsertTextAtPositionResult = AdapterResultBase<GoogleDocsWriteOperationData>;
export type GoogleDocsInsertTextAfterResult = AdapterResultBase<GoogleDocsWriteOperationData>;
export type GoogleDocsInsertHeadingResult = AdapterResultBase<GoogleDocsWriteOperationData>;
export type GoogleDocsInsertListResult = AdapterResultBase<GoogleDocsWriteOperationData>;
export type GoogleDocsInsertTableResult = AdapterResultBase<GoogleDocsWriteOperationData>;
export type GoogleDocsReplaceTextResult = AdapterResultBase<GoogleDocsWriteOperationData>;
export type GoogleDocsUpdateDocumentContentResult = AdapterResultBase<GoogleDocsWriteOperationData>;

/**
 * Result of section creation with insertion details
 */
export interface GoogleDocsCreateSectionData {
  documentId: string; // Document ID
  title: string; // Document title
  url: string; // Link to document
  heading: string; // Section heading text
  insertionIndex: number; // Character position where section was inserted
  success: boolean; // Whether operation succeeded
}

export type GoogleDocsCreateSectionResult = AdapterResultBase<GoogleDocsCreateSectionData>;

/**
 * Result of finding insertion point with position and context
 */
export interface GoogleDocsFindInsertionPointData {
  documentId: string; // Document ID
  title: string; // Document title
  url: string; // Link to document
  position: number; // Character position for insertion
  context: string; // Text context around the position
  documentLength: number; // Total document length in characters
}

export type GoogleDocsFindInsertionPointResult = AdapterResultBase<GoogleDocsFindInsertionPointData>;

// Jira Response Types
export interface JiraGetIssueData {
  id: string; // Unique issue ID
  key: string; // Issue key (e.g., PROJ-123)
  summary: string; // Issue summary/title
  description: string; // Issue description (extracted from ADF)
  status: string; // Status name
  statusId: string; // Status ID
  issueType: string; // Issue type name
  issueTypeId: string; // Issue type ID
  priority: string; // Priority name
  priorityId: string; // Priority ID
  assignee: string; // Assignee display name
  assigneeAccountId: string; // Assignee account ID
  reporter: string; // Reporter display name
  reporterAccountId: string; // Reporter account ID
  projectKey: string; // Project key
  projectName: string; // Project name
  projectId: string; // Project ID
  labels: string[]; // Issue labels
  created: string; // Created timestamp (ISO 8601)
  updated: string; // Updated timestamp (ISO 8601)
  isAssigned: boolean; // Whether issue has an assignee
  hasLabels: boolean; // Whether issue has labels
}

export type JiraGetIssueResult = AdapterResultBase<JiraGetIssueData>;

export interface JiraIssueSummary {
  id: string; // Unique issue ID
  key: string; // Issue key (e.g., PROJ-123)
  summary: string; // Issue summary/title
  status: string; // Status name
  statusId: string; // Status ID
  issueType: string; // Issue type name
  issueTypeId: string; // Issue type ID
  priority: string; // Priority name
  priorityId: string; // Priority ID
  assignee: string; // Assignee display name
  assigneeAccountId: string; // Assignee account ID
  projectKey: string; // Project key
  projectName: string; // Project name
  labels: string[]; // Issue labels
  created: string; // Created timestamp (ISO 8601)
  updated: string; // Updated timestamp (ISO 8601)
  isAssigned: boolean; // Whether issue has an assignee
}

export interface JiraSearchIssuesData {
  jql: string; // JQL query used
  count: number; // Number of results
  issues: JiraIssueSummary[]; // List of matching issues
}

export type JiraSearchIssuesResult = AdapterResultBase<JiraSearchIssuesData>;

export interface JiraCreateIssueData {
  issueKey: string; // Created issue key
  issueId: string; // Created issue ID
  summary: string; // Issue summary
}

export type JiraCreateIssueResult = AdapterResultBase<JiraCreateIssueData>;

export interface JiraUpdateIssueData {
  issueKey: string; // Updated issue key
  updated: boolean; // Whether update succeeded
}

export type JiraUpdateIssueResult = AdapterResultBase<JiraUpdateIssueData>;

export interface JiraDeleteIssueData {
  issueKey: string; // Deleted issue key
  deleted: boolean; // Whether deletion succeeded
}

export type JiraDeleteIssueResult = AdapterResultBase<JiraDeleteIssueData>;

export interface JiraAddCommentData {
  issueKey: string; // Issue key
  commentId: string; // Created comment ID
  added: boolean; // Whether comment was added
}

export type JiraAddCommentResult = AdapterResultBase<JiraAddCommentData>;

export interface JiraTransitionIssueData {
  issueKey: string; // Issue key
  transitioned: boolean; // Whether transition succeeded
  transitionId: string; // Transition ID used
}

export type JiraTransitionIssueResult = AdapterResultBase<JiraTransitionIssueData>;

export interface JiraAssignIssueData {
  issueKey: string; // Issue key
  accountId: string; // Assigned user account ID
  assigned: boolean; // Whether assignment succeeded
}

export type JiraAssignIssueResult = AdapterResultBase<JiraAssignIssueData>;

export interface JiraProject {
  id: string; // Project ID
  key: string; // Project key
  name: string; // Project name
  projectTypeKey: string; // Project type key
  leadName: string; // Project lead name
  leadAccountId: string; // Project lead account ID
}

export interface JiraGetProjectsData {
  count: number; // Number of projects
  projects: JiraProject[]; // List of projects
}

export type JiraGetProjectsResult = AdapterResultBase<JiraGetProjectsData>;

export interface JiraListProjectsData {
  count: number; // Number of projects
  projects: JiraProject[]; // List of projects
}

export type JiraListProjectsResult = AdapterResultBase<JiraListProjectsData>;

export interface JiraIssueType {
  id: string; // Issue type ID
  name: string; // Issue type name
  description: string; // Issue type description
  isSubtask: boolean; // Whether this is a subtask type
}

export interface JiraPriority {
  id: string; // Priority ID
  name: string; // Priority name
  description: string; // Priority description
}

export interface JiraGetProjectMetadataData {
  projectKey: string; // Project key
  projectName: string; // Project name
  issueTypeCount: number; // Number of issue types
  issueTypes: JiraIssueType[]; // Available issue types
  priorityCount: number; // Number of priorities
  priorities: JiraPriority[]; // Available priorities
}

export type JiraGetProjectMetadataResult = AdapterResultBase<JiraGetProjectMetadataData>;

export interface JiraTransition {
  id: string; // Transition ID
  name: string; // Transition name
  toStatus: string; // Target status name
  toStatusId: string; // Target status ID
}

export interface JiraGetTransitionsData {
  issueKey: string; // Issue key
  count: number; // Number of transitions
  transitions: JiraTransition[]; // Available transitions
}

export type JiraGetTransitionsResult = AdapterResultBase<JiraGetTransitionsData>;

export interface JiraUser {
  accountId: string; // User account ID
  displayName: string; // User display name
  emailAddress?: string; // User email address
  active: boolean; // Whether user is active
}

export interface JiraListAssignableUsersData {
  projectKey: string; // Project key
  count: number; // Number of users
  users: JiraUser[]; // Assignable users
}

export type JiraListAssignableUsersResult = AdapterResultBase<JiraListAssignableUsersData>;

export interface JiraGetIssueTypesData {
  projectKey: string; // Project key
  count: number; // Number of issue types
  issueTypes: JiraIssueType[]; // Available issue types
}

export type JiraGetIssueTypesResult = AdapterResultBase<JiraGetIssueTypesData>;


// ============================================================================
// Adapter Factory Functions
// ============================================================================

/**
 * Flows Adapter
 * Category: internal
 */
function createFlowsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a flow (event-triggered or time-scheduled). This is the unified, simplified interface for flow creation.

TRIGGER TYPE (provide exactly one):
- schedule: Cron expression for time-based flows (e.g., "0 9 * * *")
- eventType: Event type shorthand for event flows (e.g., "telegram.message")
- eventFilter: Full filter object for complex event conditions
- trigger: Legacy nested structure (still supported)

SCRIPT (provide exactly one):
- code: Inline script code - will auto-create, deploy, and link the script
- scriptId: ID of an existing deployed script

EXAMPLES:

Time flow with inline code:
{
  title: "Daily Report",
  schedule: "0 9 * * *",
  code: "async (ctx) => { await ctx.mirra.telegram.sendMessage({...}); return { done: true }; }"
}

Event flow with eventType shorthand:
{
  title: "Handle Messages",
  eventType: "telegram.message",
  code: "async (event, ctx) => { return { handled: true }; }"
}

Event flow with existing script:
{
  eventType: "gmail.email_received",
  scriptId: "existing-script-id"
}
     * @param args.title - Flow title. Required if providing inline code. (optional)
     * @param args.description - Detailed description of what the flow does (optional)
     * @param args.code - Inline script code. If provided, auto-creates, deploys, and links the script. Cannot use with scriptId. (optional)
     * @param args.scriptId - ID of existing deployed script. Cannot use with code. (optional)
     * @param args.schedule - Cron expression for time-based flows (e.g., "0 9 * * *"). Cannot use with eventType/eventFilter/trigger. (optional)
     * @param args.eventType - Event type shorthand (e.g., "telegram.message", "gmail.email_received"). Creates an eventFilter matching this type. (optional)
     * @param args.eventFilter - Full event filter with operator and conditions array for complex filtering. (optional)
     * @param args.trigger - Legacy nested trigger structure. Prefer eventType or eventFilter instead. (optional)
     * @param args.scriptInput - Optional static input data for the script (optional)
     * @param args.enabled - Whether the flow is enabled (default: true) (optional)
     */
    createFlow: async (args: FlowsCreateFlowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'createFlow',
        params: args || {}
      });
    },

    /**
     * Create a new time-based flow with cron schedule. NOTE: Consider using createFlow instead for a simpler interface with inline code support.
     * @param args.title - Flow title
     * @param args.description - Detailed description of what the flow does
     * @param args.schedule - Cron expression for scheduling (e.g., "0 9 * * *" for daily at 9am)
     * @param args.scriptId - ID of the script to execute when triggered
     * @param args.scriptInput - Optional static input data for the script (optional)
     */
    createTimeFlow: async (args: FlowsCreateTimeFlowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'createTimeFlow',
        params: args || {}
      });
    },

    /**
     * Create an event-based flow with pre-filtering conditions. NOTE: Consider using createFlow instead for a simpler interface with inline code support.

EFFICIENCY RULE: Always filter in eventFilter, not the script.
- eventFilter conditions: FREE (evaluated in-memory before script runs)
- Script filtering: EXPENSIVE (invokes Lambda for every event)

BAD: Trigger on "telegram.message" with no filter  script checks sender
GOOD: Trigger on "telegram.message" with eventFilter for sender

TRIGGER STRUCTURE:
{
  type: "event",
  config: {
    eventFilter: {
      operator: "and" | "or",
      conditions: [
        { operator: "equals", field: "type", value: "call.ended" },
        { operator: "contains", field: "content.text", value: "urgent" }
      ]
    }
  }
}

IMPORTANT: Use field: "type" (not "eventType") to filter by event type. This is required for testFlow to auto-generate test events.

VALID OPERATORS: equals, notEquals, contains, startsWith, endsWith, greaterThan, lessThan, exists, notExists, matchesRegex, and, or, not

COMMON EVENT TYPES (use with field: "type"): call.started, call.ended, call.action, telegram.message, gmail.email_received
     * @param args.title - Flow title
     * @param args.description - Detailed description of what the flow does
     * @param args.trigger - Event filter conditions that determine WHEN the script runs. Add ALL filtering logic here to minimize Lambda invocations. Must have type:"event" and config.eventFilter with operator and conditions array.
     * @param args.scriptId - ID of the script to execute when triggered
     * @param args.scriptInput - Optional static input data for the script (optional)
     */
    createEventFlow: async (args: FlowsCreateEventFlowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'createEventFlow',
        params: args || {}
      });
    },

    /**
     * List all flows for the user
     * @param args.status - Filter by status: active, paused, completed, failed (optional)
     */
    listFlows: async (args: FlowsListFlowsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'listFlows',
        params: args || {}
      });
    },

    /**
     * Get a specific flow by ID
     * @param args.id - Flow ID
     */
    getFlow: async (args: FlowsGetFlowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'getFlow',
        params: args || {}
      });
    },

    /**
     * Update an existing flow
     * @param args.id - Flow ID to update
     * @param args.title - New title (optional)
     * @param args.description - New description (optional)
     * @param args.trigger - New trigger configuration (optional)
     * @param args.scriptId - New script ID (optional)
     * @param args.scriptInput - New script input data (optional)
     * @param args.status - New status: active, paused, completed, failed (optional)
     */
    updateFlow: async (args: FlowsUpdateFlowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'updateFlow',
        params: args || {}
      });
    },

    /**
     * Delete a flow
     * @param args.id - Flow ID to delete
     */
    deleteFlow: async (args: FlowsDeleteFlowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'deleteFlow',
        params: args || {}
      });
    },

    /**
     * Pause an active flow
     * @param args.id - Flow ID to pause
     */
    pauseFlow: async (args: FlowsPauseFlowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'pauseFlow',
        params: args || {}
      });
    },

    /**
     * Resume a paused flow
     * @param args.id - Flow ID to resume
     */
    resumeFlow: async (args: FlowsResumeFlowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'resumeFlow',
        params: args || {}
      });
    },

    /**
     * Search flows with filters
     * @param args.status - Filter by status (or array of statuses) (optional)
     * @param args.triggerType - Filter by trigger type: time or event (optional)
     * @param args.limit - Maximum number of results (default: 100) (optional)
     * @param args.offset - Pagination offset (default: 0) (optional)
     */
    searchFlows: async (args: FlowsSearchFlowsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'searchFlows',
        params: args || {}
      });
    },

    /**
     * Record execution result for a flow
     * @param args.id - Flow ID
     * @param args.success - Whether execution succeeded
     * @param args.result - Execution result data (optional)
     * @param args.error - Error message if execution failed (optional)
     */
    recordExecution: async (args: FlowsRecordExecutionArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'recordExecution',
        params: args || {}
      });
    },

    /**
     * List all available event types that can trigger automations
     * @param args.includeTemplates - Include condition templates for each event type (optional)
     */
    listEventTypes: async (args: FlowsListEventTypesArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'listEventTypes',
        params: args || {}
      });
    },

    /**
     * Test a flow by generating an event that matches the trigger conditions.

REQUIREMENT: The flow's trigger conditions MUST include a condition with field: "type" or field: "source" so the system knows what kind of test event to generate.

CORRECT condition: { operator: "equals", field: "type", value: "telegram.message" }
WRONG condition: { operator: "equals", field: "eventType", value: "telegram.message" }

If your flow lacks a "type" or "source" condition, use validateTrigger instead with a manually constructed event.

MODES:
- dryRun=true (DEFAULT): Validates trigger matching only. Safe, no side effects, no token consumption.
- dryRun=false: Executes the real script. WARNING: This causes real side effects (sends messages, makes API calls, consumes tokens).

Use dryRun=true first to verify trigger conditions work, then dryRun=false only when ready to test full execution.

WORKFLOW:
1. Generates a test event from the flow's trigger conditions (requires "type" or "source" field)
2. Validates the event matches the trigger (always)
3. If dryRun=false, executes the script with the test event

RESULT:
Returns detailed information about trigger matching, including which conditions passed/failed, and optionally full execution results.
     * @param args.flowId - ID of the flow to test
     * @param args.dryRun - If true (default), only validate trigger matching without executing script. If false, execute the script (causes side effects). (optional)
     * @param args.eventOverrides - Custom field values to merge into the generated test event (e.g., {"content.text": "custom message"}) (optional)
     */
    testFlow: async (args: FlowsTestFlowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'testFlow',
        params: args || {}
      });
    },

    /**
     * Check if a custom event would match a flow trigger without any execution. Useful for debugging trigger conditions or testing with real event data.
     * @param args.flowId - ID of the flow
     * @param args.event - Event object to test against the trigger (must match IntegrationEvent structure)
     */
    validateTrigger: async (args: FlowsValidateTriggerArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'validateTrigger',
        params: args || {}
      });
    },

    /**
     * Get all active flows that are triggered by a specific event type. Used by frontend to show flow selection for targeted execution (e.g., call.action flows).
     * @param args.eventType - Event type to filter by (e.g., "call.action", "call.ended", "telegram.message")
     */
    getFlowsByEventType: async (args: FlowsGetFlowsByEventTypeArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'getFlowsByEventType',
        params: args || {}
      });
    },

    /**
     * Create a self-managing flow that processes multiple adapter operations over time, respecting rate limits. The flow automatically cleans up when complete and notifies the user via feed item.
     * @param args.title - Human-readable title for this batch operation (e.g., "Leave 100 Telegram groups")
     * @param args.operations - Array of operations to execute. Each item must have adapter, operation, and args properties.
     * @param args.batchSize - Number of operations to process per execution (default: 5) (optional)
     * @param args.intervalSeconds - Seconds between batch executions (default: 60, minimum: 60) (optional)
     */
    createBatchOperation: async (args: FlowsCreateBatchOperationArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'createBatchOperation',
        params: args || {}
      });
    }
  };
}

/**
 * User Adapter
 * Category: internal
 */
function createUserAdapter(sdk: MirraSDK) {
  return {
    /**
     * Get user profile information including username, email, timezone, phone, and usage stats
     */
    getProfile: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'getProfile',
        params: args || {}
      });
    },

    /**
     * Update user profile fields (username, email, timezone, phone)
     * @param args.username - New username (3-30 characters, alphanumeric with underscores/hyphens) (optional)
     * @param args.email - New email address (optional)
     * @param args.timezone - IANA timezone identifier (e.g., America/Los_Angeles) (optional)
     * @param args.phoneNumber - Phone number (7-15 digits with optional formatting) (optional)
     */
    updateProfile: async (args: UserUpdateProfileArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'updateProfile',
        params: args || {}
      });
    },

    /**
     * Update user preferences (notification settings, etc)
     * @param args.timezone - Preferred timezone for scheduling (optional)
     * @param args.socials - Social media links (twitter, discord) (optional)
     */
    updatePreferences: async (args: UserUpdatePreferencesArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'updatePreferences',
        params: args || {}
      });
    },

    /**
     * Get token usage statistics, quota, and billing information
     */
    getUsageStats: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'getUsageStats',
        params: args || {}
      });
    },

    /**
     * Get active sessions/devices (based on push token registrations)
     */
    getSessions: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'getSessions',
        params: args || {}
      });
    },

    /**
     * Soft delete user account (set inactive flag) - CAUTION: This marks the account for deletion
     * @param args.confirm - Must be true to confirm account deactivation
     */
    deactivateAccount: async (args: UserDeactivateAccountArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'deactivateAccount',
        params: args || {}
      });
    }
  };
}

/**
 * Contacts Adapter
 * Category: internal
 */
function createContactsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Get a list of all accepted contacts for the user with their profile information
     * @param args.limit - Maximum number of contacts to return (default: 100) (optional)
     * @param args.offset - Number of contacts to skip for pagination (default: 0) (optional)
     */
    listContacts: async (args: ContactsListContactsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'listContacts',
        params: args || {}
      });
    },

    /**
     * Get detailed information about a specific contact by their ID or username
     * @param args.contactId - The contact user ID (MongoDB ObjectId) (optional)
     * @param args.username - The contact username (optional)
     */
    getContact: async (args: ContactsGetContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'getContact',
        params: args || {}
      });
    },

    /**
     * Send a contact request to another user by their username
     * @param args.username - Username of the user to add as a contact
     */
    addContact: async (args: ContactsAddContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'addContact',
        params: args || {}
      });
    },

    /**
     * Remove a user from your contacts list (unfriend)
     * @param args.contactId - The contact user ID to remove (optional)
     * @param args.username - The contact username to remove (optional)
     */
    removeContact: async (args: ContactsRemoveContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'removeContact',
        params: args || {}
      });
    },

    /**
     * Search your contacts by username, email, phone, or wallet address
     * @param args.query - Search query - can be username, email, phone, or wallet address
     * @param args.searchType - Type of search to perform: all, username, email, phone, or wallet (default: all) (optional)
     * @param args.limit - Maximum number of results (default: 20) (optional)
     */
    searchContacts: async (args: ContactsSearchContactsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'searchContacts',
        params: args || {}
      });
    },

    /**
     * Block a user (prevents them from contacting you)
     * @param args.contactId - The user ID to block (optional)
     * @param args.username - The username to block (optional)
     */
    blockContact: async (args: ContactsBlockContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'blockContact',
        params: args || {}
      });
    },

    /**
     * Unblock a previously blocked user
     * @param args.contactId - The user ID to unblock (optional)
     * @param args.username - The username to unblock (optional)
     */
    unblockContact: async (args: ContactsUnblockContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'unblockContact',
        params: args || {}
      });
    },

    /**
     * Get a list of all users you have blocked
     * @param args.limit - Maximum number of results (default: 100) (optional)
     * @param args.offset - Number of items to skip for pagination (default: 0) (optional)
     */
    getBlockedContacts: async (args: ContactsGetBlockedContactsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'getBlockedContacts',
        params: args || {}
      });
    },

    /**
     * Get pending contact requests (sent by you or received from others)
     * @param args.type - Type of requests to retrieve: all, sent, or received (default: all) (optional)
     * @param args.status - Filter by request status: pending, accepted, or rejected (default: pending) (optional)
     */
    getContactRequests: async (args: ContactsGetContactRequestsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'getContactRequests',
        params: args || {}
      });
    }
  };
}

/**
 * Memory Adapter
 * Category: internal
 */
function createMemoryAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new memory entity in the knowledge graph. Use the type field to specify what kind of memory (note, idea, shopping_item, etc.). For tasks with assignment or timing features, use `createTask` instead. All memory types can be queried, updated, and deleted using the standard operations.
     * @param args.type - Memory subtype: "note" (general notes), "idea" (concepts/ideas), "shopping_item" (shopping list), "topic" (general knowledge), "document" (documents), "contact" (people), "event" (calendar items). For tasks with assignment, use createTask instead.
     * @param args.content - Main content/description of the memory
     * @param args.metadata - Additional metadata (e.g., priority, deadline, tags, etc.) (optional)
     */
    create: async (args: MemoryCreateArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'create',
        params: args || {}
      });
    },

    /**
     * Create a task in the knowledge graph. Tasks are a specialized memory type with assignment, timing, priority, and status lifecycle. Use this instead of `create` when you need task-specific features like assigning to users. Tasks can be queried, updated, and deleted using the standard memory operations (`query`, `update`, `delete`) with type="task". For group contexts, the task is stored in the group's shared graph.
     * @param args.content - Task description/title - what needs to be done. IMPORTANT: Write task content from a neutral perspective without possessive pronouns (his/her/their). The assignee will see this exact text, so "fold dresses" is correct, NOT "fold her dresses". Avoid phrases like "remind him to", "help her with", etc.
     * @param args.assignedTo - Username of the person to assign this task to (group contexts only). System resolves username to user ID. (optional)
     * @param args.dueAt - Due date/time in ISO 8601 format (e.g., "2024-01-15T10:00:00Z") or natural language that will be parsed (optional)
     * @param args.priority - Task priority: "high", "medium", or "low" (optional)
     * @param args.tags - Tags/labels for categorization (e.g., ["work", "urgent"]) (optional)
     */
    createTask: async (args: MemoryCreateTaskArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'createTask',
        params: args || {}
      });
    },

    /**
     * Semantic search across memory entities with advanced filtering. IMPORTANT: Search results return TRUNCATED content (max 300 chars) to prevent huge payloads. To get the full untruncated text of a specific entity, use `findOne` with the entity ID after searching. Recommended workflow: (1) Use `search` to find matching entities, (2) Use `findOne` with { filters: { id: "entity_id" } } to retrieve full content for entities you need.
     * @param args.query - Search query text for semantic matching
     * @param args.types - Filter by entity types (e.g., ["TASK", "NOTE", "IDEA"]) (optional)
     * @param args.startTime - Filter entities created after this timestamp (Unix milliseconds) (optional)
     * @param args.endTime - Filter entities created before this timestamp (Unix milliseconds) (optional)
     * @param args.propertyFilters - Filter by entity properties: { status: ["completed"], tags: ["urgent"], priority: ["high"], roles: ["task"], contexts: ["work"] } (optional)
     * @param args.limit - Maximum number of results (default: 50, max: 100) (optional)
     */
    search: async (args: MemorySearchArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'search',
        params: args || {}
      });
    },

    /**
     * Query memory entities with filters. Returns lightweight summaries with TRUNCATED content (max 200 chars) to prevent large payloads. Use type="task" to list all tasks (including those created via createTask). To get full untruncated content for a specific entity, use `findOne` with the entity ID.
     * @param args.type - Semantic type filter (e.g., "task", "note", "idea", "reminder", "contact", "document"). Matches against meta_item_type, subType, or semantic_roles (optional)
     * @param args.filters - Additional filters (not yet implemented) (optional)
     * @param args.limit - Maximum results (default: 50, max: 100) (optional)
     * @param args.offset - Pagination offset for fetching more results (default: 0) (optional)
     */
    query: async (args: MemoryQueryArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'query',
        params: args || {}
      });
    },

    /**
     * Find a single entity by ID or name. Returns the FULL untruncated entity content. Use this after `search` or `query` to retrieve complete content for a specific entity (since those operations return truncated results to prevent large payloads).
     * @param args.filters - Filter criteria. Use { id: "entity_id" } to find by ID (recommended), or { name: "entity name" } to find by name.
     */
    findOne: async (args: MemoryFindOneArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'findOne',
        params: args || {}
      });
    },

    /**
     * Update an existing memory entity. Works with all memory types including tasks created via createTask. Use this to mark tasks complete, update content, or modify metadata.
     * @param args.id - Entity ID to update
     * @param args.type - Entity type (optional)
     * @param args.content - Updated content (optional)
     * @param args.metadata - Updated metadata (optional)
     */
    update: async (args: MemoryUpdateArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'update',
        params: args || {}
      });
    },

    /**
     * Delete a memory entity. Works with all memory types including tasks, notes, ideas, etc.
     * @param args.id - Entity ID to delete
     */
    delete: async (args: MemoryDeleteArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'delete',
        params: args || {}
      });
    },

    /**
     * Share a memory entity with another graph (group or contact). Only the creator can share memories. Recipients can view and complete tasks but cannot edit or delete.
     * @param args.entityId - Entity ID to share
     * @param args.targetGraphId - Target graph ID to share with (group ID or user contact graph ID)
     * @param args.shareReason - Optional reason for sharing (optional)
     */
    share: async (args: MemoryShareArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'share',
        params: args || {}
      });
    },

    /**
     * Remove sharing of a memory entity from a graph. Only the creator can unshare. Cannot unshare from the primary graph (where it was created).
     * @param args.entityId - Entity ID to unshare
     * @param args.graphId - Graph ID to remove sharing from
     */
    unshare: async (args: MemoryUnshareArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'unshare',
        params: args || {}
      });
    },

    /**
     * List all graphs a memory entity is shared with, including share history and metadata.
     * @param args.entityId - Entity ID to list graphs for
     */
    listGraphs: async (args: MemoryListGraphsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'listGraphs',
        params: args || {}
      });
    }
  };
}

/**
 * AI Services Adapter
 * Category: internal
 */
function createAiAdapter(sdk: MirraSDK) {
  return {
    /**
     * Have a conversation with an AI assistant. Supports multi-turn conversations with system prompts, user messages, and assistant responses.

PROVIDER: Uses Anthropic (Claude) as the AI provider.

BEST PRACTICES:
- Use system messages to set AI behavior and constraints
- Keep conversations focused - avoid unnecessary context

MESSAGE STRUCTURE:
Each message has:
- role: "system" | "user" | "assistant"
- content: string (the message text)

TYPICAL PATTERNS:
1. Simple query: [{ role: "user", content: "question" }]
2. With system prompt: [{ role: "system", content: "instructions" }, { role: "user", content: "question" }]
3. Multi-turn: [system, user, assistant, user, assistant, ...]
     * @param args.messages - Array of message objects with role ("system" | "user" | "assistant") and content (string). System messages set AI behavior, user messages are queries, assistant messages are previous AI responses.
     * @param args.model - Specific model to use. Default: "claude-3-haiku-20240307". Use Anthropic Claude model names. (optional)
     * @param args.temperature - Creativity level 0.0-1.0. Lower=factual/consistent, Higher=creative/varied. Default: 0.7 (optional)
     * @param args.maxTokens - Maximum tokens in response. Default: 1000. Increase for longer responses (costs more tokens). (optional)
     */
    chat: async (args: AiChatArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'ai',
        method: 'chat',
        params: args || {}
      });
    },

    /**
     * Use AI to make a decision from a list of options. The AI analyzes your prompt, considers the context, and selects the most appropriate option with reasoning.

USE CASES:
- Route messages to correct handlers
- Classify user intents
- Select appropriate tools or actions
- Prioritize tasks
- Choose templates or responses
- Determine sentiment or category

HOW IT WORKS:
1. Provide a prompt (the decision context)
2. List available options (each with id and label)
3. Optionally add extra context
4. AI returns selected option ID and reasoning

BEST PRACTICES:
- Make option labels clear and descriptive
- Use unique IDs for options
- Add context when decision needs background info
- Keep prompt focused on the decision criteria
- Use metadata field for additional option data
     * @param args.prompt - The decision prompt - what needs to be decided and why
     * @param args.options - Array of options to choose from. Each option must have: id (unique identifier), label (descriptive name), and optional metadata (additional data)
     * @param args.context - Additional context to help the AI make a better decision (optional)
     * @param args.model - Specific model to use. Defaults to system default. (optional)
     */
    decide: async (args: AiDecideArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'ai',
        method: 'decide',
        params: args || {}
      });
    }
  };
}

/**
 * Documents Adapter
 * Category: storage
 */
function createDocumentAdapter(sdk: MirraSDK) {
  return {
    /**
     * Upload and process a document (PDF, DOCX, TXT, MD)
     * @param args.file - Base64 encoded file content
     * @param args.filename - Original filename with extension
     * @param args.mimeType - MIME type (application/pdf, text/plain, etc.)
     * @param args.graphId - Target graph ID (defaults to user's personal graph) (optional)
     * @param args.title - Custom document title (optional)
     * @param args.productTags - Array of product tags for categorization (optional)
     */
    upload: async (args: DocumentUploadArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'upload',
        params: args || {}
      });
    },

    /**
     * Get document metadata and content
     * @param args.documentId - Document ID to retrieve
     */
    get: async (args: DocumentGetArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'get',
        params: args || {}
      });
    },

    /**
     * Get document processing status
     * @param args.documentId - Document ID to check
     */
    getStatus: async (args: DocumentGetStatusArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'getStatus',
        params: args || {}
      });
    },

    /**
     * Get all chunks for a document
     * @param args.documentId - Document ID
     */
    getChunks: async (args: DocumentGetChunksArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'getChunks',
        params: args || {}
      });
    },

    /**
     * Delete a document and all its chunks
     * @param args.documentId - Document ID to delete
     */
    delete: async (args: DocumentDeleteArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'delete',
        params: args || {}
      });
    },

    /**
     * Share a document to another graph (group or user-contact)
     * @param args.documentId - Document ID to share
     * @param args.targetGraphId - Target graph ID to share to
     * @param args.shareReason - Optional reason for sharing (optional)
     */
    share: async (args: DocumentShareArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'share',
        params: args || {}
      });
    },

    /**
     * Remove document access from a graph
     * @param args.documentId - Document ID
     * @param args.graphId - Graph ID to remove access from
     */
    unshare: async (args: DocumentUnshareArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'unshare',
        params: args || {}
      });
    },

    /**
     * List all graphs a document is shared in
     * @param args.documentId - Document ID
     */
    listGraphs: async (args: DocumentListGraphsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'listGraphs',
        params: args || {}
      });
    },

    /**
     * Semantic search across document chunks
     * @param args.query - Search query
     * @param args.graphId - Graph ID to search in (defaults to user's graph) (optional)
     * @param args.limit - Maximum results (default: 10) (optional)
     * @param args.threshold - Similarity threshold 0-1 (default: 0.7) (optional)
     */
    search: async (args: DocumentSearchArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'search',
        params: args || {}
      });
    },

    /**
     * List documents in a graph
     * @param args.graphId - Graph ID to list documents from (defaults to user's graph) (optional)
     * @param args.limit - Maximum results (default: 50) (optional)
     * @param args.offset - Pagination offset (default: 0) (optional)
     */
    list: async (args: DocumentListArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'list',
        params: args || {}
      });
    }
  };
}

/**
 * Feed Items Adapter
 * Category: internal
 */
function createFeedItemsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a feed item with flexible content blocks. Use this to show action results, notifications, or updates to users.
     * @param args.title - Main title of the feed item (shown prominently)
     * @param args.subtitle - Optional subtitle (shown below title in muted color) (optional)
     * @param args.blocks - Array of content blocks to display (text, key_value, list, timestamp, user_mention, divider, image, progress)
     * @param args.itemType - Type: informative (FYI), actionable (needs response), or error
     * @param args.actions - Optional action buttons for the feed item (optional)
     * @param args.avatar - Optional avatar to show (user profile, icon, or custom image) (optional)
     * @param args.metadata - Additional metadata (searchable, not displayed) (optional)
     */
    createFeedItem: async (args: FeedItemsCreateFeedItemArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'feed-items',
        method: 'create_feed_item',
        params: args || {}
      });
    }
  };
}

/**
 * Telegram Adapter
 * Category: social
 */
function createTelegramAdapter(sdk: MirraSDK) {
  return {
    /**
     * Send a text message to a Telegram chat or user. Supports both chat IDs and usernames.
     * @param args.chatId - Chat ID (numeric) or username (e.g., @username) to send the message to. Chat IDs can be obtained from searchChats operation.
     * @param args.text - The text content of the message to send
     * @returns Promise<TelegramSendMessageResult> Typed response with IDE autocomplete
     */
    sendMessage: async (args: TelegramSendMessageArgs): Promise<TelegramSendMessageResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'sendMessage',
        params: args || {}
      });
    },

    /**
     * Powerful unified chat search with filtering, sorting, and activity tracking. Replaces getChats, findChatByName, and getRecentContacts. Use with no filters to list all chats.
     * @param args.query - Text to search in chat names/usernames. Supports fuzzy matching with relevance scoring. (optional)
     * @param args.type - Filter by chat type: "private", "group", "channel", or "all" (default: "all") (optional)
     * @param args.inactiveSince - Find chats with no activity since date. Accepts ISO date or relative like "30 days ago", "1 week ago" (optional)
     * @param args.activeSince - Find chats with activity since date. Accepts ISO date or relative like "7 days ago" (optional)
     * @param args.hasUnread - Filter by unread status: true = only unread, false = only read (optional)
     * @param args.archived - Filter by archived status (optional)
     * @param args.pinned - Filter by pinned status (optional)
     * @param args.sortBy - Sort results: "relevance" (default with query), "lastActivity" (default without query), "unreadCount", "name" (optional)
     * @param args.limit - Max results (default: 50, max: 100) (optional)
     * @param args.offset - Pagination offset (default: 0) (optional)
     * @param args.forceRefresh - Bypass cache and fetch fresh data (optional)
     * @returns Promise<TelegramSearchChatsResult> Typed response with IDE autocomplete
     */
    searchChats: async (args: TelegramSearchChatsArgs): Promise<TelegramSearchChatsResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'searchChats',
        params: args || {}
      });
    },

    /**
     * Search for messages across Telegram chats. When chatIds is omitted, performs global search across all chats (replaces globalSearch operation).
     * @param args.query - Text query to search for in messages
     * @param args.chatIds - Array of chat IDs to search within. Omit for global search across all chats. (optional)
     * @param args.chatType - Filter by chat type (for global search): "private", "group", or "channel" (optional)
     * @param args.fromDate - ISO date string for start of date range (optional)
     * @param args.toDate - ISO date string for end of date range (optional)
     * @param args.limit - Maximum number of messages to return (default: 100, max: 100) (optional)
     * @param args.senderId - Filter messages by sender ID (optional)
     * @returns Promise<TelegramSearchMessagesResult> Typed response with IDE autocomplete
     */
    searchMessages: async (args: TelegramSearchMessagesArgs): Promise<TelegramSearchMessagesResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'searchMessages',
        params: args || {}
      });
    },

    /**
     * Get message history from a specific Telegram chat with pagination and date filtering.
     * @param args.chatId - Chat ID to retrieve messages from
     * @param args.limit - Maximum number of messages to return (default: 50, max: 100) (optional)
     * @param args.offsetId - Message ID to use as pagination offset (optional)
     * @param args.minDate - ISO date string for minimum message date (optional)
     * @param args.maxDate - ISO date string for maximum message date (optional)
     * @returns Promise<TelegramGetChatMessagesResult> Typed response with IDE autocomplete
     */
    getChatMessages: async (args: TelegramGetChatMessagesArgs): Promise<TelegramGetChatMessagesResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'getChatMessages',
        params: args || {}
      });
    },

    /**
     * Get summary of unread messages across Telegram chats, including mentions and flattened last message info.
     * @param args.chatIds - Array of chat IDs to filter by. If not provided, checks all chats. (optional)
     * @param args.priorityOnly - If true, only return chats with unread messages (optional)
     * @param args.groupBy - Group results by "chat" or "sender" (optional)
     * @returns Promise<TelegramGetUnreadSummaryResult> Typed response with IDE autocomplete
     */
    getUnreadSummary: async (args: TelegramGetUnreadSummaryArgs): Promise<TelegramGetUnreadSummaryResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'getUnreadSummary',
        params: args || {}
      });
    },

    /**
     * Mark messages as read in a Telegram chat up to a specific message ID.
     * @param args.chatId - Chat ID to mark messages as read in
     * @param args.maxMessageId - Maximum message ID to mark as read. If not provided, marks all messages as read. (optional)
     * @returns Promise<TelegramMarkAsReadResult> Typed response with IDE autocomplete
     */
    markAsRead: async (args: TelegramMarkAsReadArgs): Promise<TelegramMarkAsReadResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'markAsRead',
        params: args || {}
      });
    },

    /**
     * Get messages where the user is mentioned in Telegram chats.
     * @param args.chatIds - Array of chat IDs to filter mentions by (optional)
     * @param args.sinceDate - ISO date string - only return mentions since this date (optional)
     * @param args.onlyUnread - If true, only return unread mentions (optional)
     * @returns Promise<TelegramGetMentionsResult> Typed response with IDE autocomplete
     */
    getMentions: async (args: TelegramGetMentionsArgs): Promise<TelegramGetMentionsResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'getMentions',
        params: args || {}
      });
    },

    /**
     * Leave a Telegram group, supergroup, or channel. Removes the user from the group and clears it from the local cache.
     * @param args.chatId - The ID of the group, supergroup, or channel to leave. Can be obtained from searchChats operation.
     * @returns Promise<TelegramLeaveGroupResult> Typed response with IDE autocomplete
     */
    leaveGroup: async (args: TelegramLeaveGroupArgs): Promise<TelegramLeaveGroupResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'leaveGroup',
        params: args || {}
      });
    }
  };
}

/**
 * Gmail Adapter
 * Category: communication
 */
function createGoogleGmailAdapter(sdk: MirraSDK) {
  return {
    /**
     * Send an email via Gmail
     * @param args.to - Valid email address
     * @param args.subject - Email subject line
     * @param args.body - Email body content
     * @param args.cc - CC recipients (comma-separated email addresses) (optional)
     * @param args.bcc - BCC recipients (comma-separated email addresses) (optional)
     * @param args.isHtml - Whether body is HTML format (optional)
     * @returns Promise<GoogleGmailSendEmailResult> Typed response with IDE autocomplete
     */
    sendEmail: async (args: GoogleGmailSendEmailArgs): Promise<GoogleGmailSendEmailResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'sendEmail',
        params: args || {}
      });
    },

    /**
     * Search emails with Gmail query syntax. Returns normalized email summaries.
     * @param args.query - Gmail search query (e.g., "from:user@example.com is:unread")
     * @param args.maxResults - Maximum number of results to return (default: 50, max: 100) (optional)
     * @returns Promise<GoogleGmailSearchEmailsResult> Typed response with IDE autocomplete
     */
    searchEmails: async (args: GoogleGmailSearchEmailsArgs): Promise<GoogleGmailSearchEmailsResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'searchEmails',
        params: args || {}
      });
    },

    /**
     * List recent emails from inbox. Returns normalized email summaries.
     * @param args.maxResults - Maximum number of results to return (default: 50, max: 100) (optional)
     * @returns Promise<GoogleGmailListEmailsResult> Typed response with IDE autocomplete
     */
    listEmails: async (args: GoogleGmailListEmailsArgs): Promise<GoogleGmailListEmailsResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'listEmails',
        params: args || {}
      });
    },

    /**
     * Get full details of a specific email by ID. Returns normalized flat structure.
     * @param args.messageId - Gmail message ID
     * @param args.includeHtml - Include HTML body content (default: false) (optional)
     * @param args.includeAttachments - Include attachment metadata (default: false) (optional)
     * @returns Promise<GoogleGmailGetEmailResult> Typed response with IDE autocomplete
     */
    getEmail: async (args: GoogleGmailGetEmailArgs): Promise<GoogleGmailGetEmailResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'getEmail',
        params: args || {}
      });
    },

    /**
     * Create a draft email in Gmail
     * @param args.to - Valid email address
     * @param args.subject - Email subject line
     * @param args.body - Email body content
     * @param args.cc - CC recipients (comma-separated email addresses) (optional)
     * @param args.bcc - BCC recipients (comma-separated email addresses) (optional)
     * @param args.isHtml - Whether body is HTML format (optional)
     * @returns Promise<GoogleGmailCreateDraftResult> Typed response with IDE autocomplete
     */
    createDraft: async (args: GoogleGmailCreateDraftArgs): Promise<GoogleGmailCreateDraftResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'createDraft',
        params: args || {}
      });
    },

    /**
     * Update an existing draft email
     * @param args.draftId - Gmail draft ID to update
     * @param args.to - Updated recipient email address(es) (optional)
     * @param args.subject - Updated email subject line (optional)
     * @param args.body - Updated email body content (optional)
     * @param args.cc - Updated CC recipients (optional)
     * @param args.bcc - Updated BCC recipients (optional)
     * @param args.isHtml - Whether body is HTML format (optional)
     * @returns Promise<GoogleGmailUpdateDraftResult> Typed response with IDE autocomplete
     */
    updateDraft: async (args: GoogleGmailUpdateDraftArgs): Promise<GoogleGmailUpdateDraftResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'updateDraft',
        params: args || {}
      });
    },

    /**
     * Delete a draft email
     * @param args.draftId - Gmail draft ID to delete
     * @returns Promise<GoogleGmailDeleteDraftResult> Typed response with IDE autocomplete
     */
    deleteDraft: async (args: GoogleGmailDeleteDraftArgs): Promise<GoogleGmailDeleteDraftResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'deleteDraft',
        params: args || {}
      });
    },

    /**
     * List all draft emails. Returns normalized draft summaries.
     * @param args.maxResults - Maximum number of drafts to return (default: 10) (optional)
     * @returns Promise<GoogleGmailListDraftsResult> Typed response with IDE autocomplete
     */
    listDrafts: async (args: GoogleGmailListDraftsArgs): Promise<GoogleGmailListDraftsResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'listDrafts',
        params: args || {}
      });
    },

    /**
     * Delete an email
     * @param args.messageId - Gmail message ID to delete
     * @returns Promise<GoogleGmailDeleteEmailResult> Typed response with IDE autocomplete
     */
    deleteEmail: async (args: GoogleGmailDeleteEmailArgs): Promise<GoogleGmailDeleteEmailResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'deleteEmail',
        params: args || {}
      });
    },

    /**
     * Delete multiple emails at once. Uses Gmail batchDelete API for efficiency.
     * @param args.messageIds - Array of Gmail message IDs to delete (max 1000 per request)
     * @param args.permanently - If true, permanently delete. If false (default), move to trash. (optional)
     * @returns Promise<GoogleGmailBulkDeleteEmailsResult> Typed response with IDE autocomplete
     */
    bulkDeleteEmails: async (args: GoogleGmailBulkDeleteEmailsArgs): Promise<GoogleGmailBulkDeleteEmailsResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'bulkDeleteEmails',
        params: args || {}
      });
    }
  };
}

/**
 * Google Calendar Adapter
 * Category: productivity
 */
function createGoogleCalendarAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new calendar event
     * @param args.summary - Event title/summary
     * @param args.start - Start time object with dateTime and optional timeZone
     * @param args.end - End time object with dateTime and optional timeZone
     * @param args.description - Event description (optional)
     * @param args.location - Event location (optional)
     * @param args.attendees - Array of attendee email addresses (optional)
     * @returns Promise<GoogleCalendarCreateEventResult> Typed response with IDE autocomplete
     */
    createEvent: async (args: GoogleCalendarCreateEventArgs): Promise<GoogleCalendarCreateEventResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'createEvent',
        params: args || {}
      });
    },

    /**
     * List calendar events
     * @param args.timeMin - Start time for events to list (ISO 8601) (optional)
     * @param args.timeMax - End time for events to list (ISO 8601) (optional)
     * @param args.maxResults - Maximum number of events to return (default: 50, max: 100) (optional)
     * @param args.query - Search query to filter events (optional)
     * @returns Promise<GoogleCalendarListEventsResult> Typed response with IDE autocomplete
     */
    listEvents: async (args: GoogleCalendarListEventsArgs): Promise<GoogleCalendarListEventsResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'listEvents',
        params: args || {}
      });
    },

    /**
     * Get calendar events (alias for listEvents)
     * @param args.timeMin - Start time for events to list (ISO 8601) (optional)
     * @param args.timeMax - End time for events to list (ISO 8601) (optional)
     * @param args.maxResults - Maximum number of events to return (default: 50, max: 100) (optional)
     * @param args.query - Search query to filter events (optional)
     * @returns Promise<GoogleCalendarGetEventsResult> Typed response with IDE autocomplete
     */
    getEvents: async (args: GoogleCalendarGetEventsArgs): Promise<GoogleCalendarGetEventsResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'getEvents',
        params: args || {}
      });
    },

    /**
     * Get a specific calendar event by ID
     * @param args.eventId - Calendar event ID
     * @returns Promise<GoogleCalendarGetEventResult> Typed response with IDE autocomplete
     */
    getEvent: async (args: GoogleCalendarGetEventArgs): Promise<GoogleCalendarGetEventResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'getEvent',
        params: args || {}
      });
    },

    /**
     * Update an existing calendar event
     * @param args.eventId - Calendar event ID to update
     * @param args.summary - Updated event title/summary (optional)
     * @param args.description - Updated event description (optional)
     * @param args.location - Updated event location (optional)
     * @param args.start - Updated start time object with dateTime and optional timeZone (optional)
     * @param args.end - Updated end time object with dateTime and optional timeZone (optional)
     * @returns Promise<GoogleCalendarUpdateEventResult> Typed response with IDE autocomplete
     */
    updateEvent: async (args: GoogleCalendarUpdateEventArgs): Promise<GoogleCalendarUpdateEventResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'updateEvent',
        params: args || {}
      });
    },

    /**
     * Delete a calendar event
     * @param args.eventId - Calendar event ID to delete
     * @returns Promise<GoogleCalendarDeleteEventResult> Typed response with IDE autocomplete
     */
    deleteEvent: async (args: GoogleCalendarDeleteEventArgs): Promise<GoogleCalendarDeleteEventResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'deleteEvent',
        params: args || {}
      });
    },

    /**
     * Search calendar events by text query
     * @param args.query - Search query to filter events
     * @param args.timeMin - Start time for events to search (ISO 8601) (optional)
     * @param args.timeMax - End time for events to search (ISO 8601) (optional)
     * @param args.maxResults - Maximum number of events to return (default: 50, max: 100) (optional)
     * @returns Promise<GoogleCalendarSearchEventsResult> Typed response with IDE autocomplete
     */
    searchEvents: async (args: GoogleCalendarSearchEventsArgs): Promise<GoogleCalendarSearchEventsResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'searchEvents',
        params: args || {}
      });
    }
  };
}

/**
 * Google Drive Adapter
 * Category: storage
 */
function createGoogleDriveAdapter(sdk: MirraSDK) {
  return {
    /**
     * List files in Google Drive
     * @param args.query - Search query (Google Drive query syntax) (optional)
     * @param args.pageSize - Maximum number of files to return (default: 20) (optional)
     * @returns Promise<GoogleDriveListFilesResult> Typed response with IDE autocomplete
     */
    listFiles: async (args: GoogleDriveListFilesArgs): Promise<GoogleDriveListFilesResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'listFiles',
        params: args || {}
      });
    },

    /**
     * Create a new file in Google Drive
     * @param args.name - Name of the file
     * @param args.mimeType - MIME type of the file
     * @param args.folderId - Parent folder ID (optional) (optional)
     * @returns Promise<GoogleDriveCreateFileResult> Typed response with IDE autocomplete
     */
    createFile: async (args: GoogleDriveCreateFileArgs): Promise<GoogleDriveCreateFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'createFile',
        params: args || {}
      });
    },

    /**
     * Create a new folder in Google Drive
     * @param args.name - Name of the folder
     * @param args.parentFolderId - Parent folder ID (optional) (optional)
     * @returns Promise<GoogleDriveCreateFolderResult> Typed response with IDE autocomplete
     */
    createFolder: async (args: GoogleDriveCreateFolderArgs): Promise<GoogleDriveCreateFolderResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'createFolder',
        params: args || {}
      });
    },

    /**
     * Get information about a file
     * @param args.fileId - ID of the file
     * @returns Promise<GoogleDriveGetFileInfoResult> Typed response with IDE autocomplete
     */
    getFileInfo: async (args: GoogleDriveGetFileInfoArgs): Promise<GoogleDriveGetFileInfoResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'getFileInfo',
        params: args || {}
      });
    },

    /**
     * Share a file with others
     * @param args.fileId - ID of the file to share
     * @param args.email - Email address to share with (optional) (optional)
     * @param args.role - Permission role: reader, writer, commenter (default: reader) (optional)
     * @returns Promise<GoogleDriveShareFileResult> Typed response with IDE autocomplete
     */
    shareFile: async (args: GoogleDriveShareFileArgs): Promise<GoogleDriveShareFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'shareFile',
        params: args || {}
      });
    },

    /**
     * Download a file from Google Drive. For Google Docs/Sheets, exports as PDF/XLSX. Returns base64-encoded data.
     * @param args.fileId - ID of the file to download
     * @returns Promise<GoogleDriveDownloadFileResult> Typed response with IDE autocomplete
     */
    downloadFile: async (args: GoogleDriveDownloadFileArgs): Promise<GoogleDriveDownloadFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'downloadFile',
        params: args || {}
      });
    },

    /**
     * Move a file to a different folder
     * @param args.fileId - ID of the file to move
     * @param args.folderId - ID of the destination folder
     * @returns Promise<GoogleDriveMoveFileResult> Typed response with IDE autocomplete
     */
    moveFile: async (args: GoogleDriveMoveFileArgs): Promise<GoogleDriveMoveFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'moveFile',
        params: args || {}
      });
    },

    /**
     * Delete a file or folder. By default moves to trash; set permanently=true to delete forever.
     * @param args.fileId - ID of the file or folder to delete
     * @param args.permanently - If true, permanently delete instead of moving to trash (default: false) (optional)
     * @returns Promise<GoogleDriveDeleteFileResult> Typed response with IDE autocomplete
     */
    deleteFile: async (args: GoogleDriveDeleteFileArgs): Promise<GoogleDriveDeleteFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'deleteFile',
        params: args || {}
      });
    },

    /**
     * Search for files using Google Drive query syntax
     * @param args.query - Search query using Drive syntax (e.g., "name contains 'report'", "mimeType='application/pdf'")
     * @param args.pageSize - Maximum number of files to return (default: 20) (optional)
     * @returns Promise<GoogleDriveSearchFilesResult> Typed response with IDE autocomplete
     */
    searchFiles: async (args: GoogleDriveSearchFilesArgs): Promise<GoogleDriveSearchFilesResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'searchFiles',
        params: args || {}
      });
    },

    /**
     * Update file metadata (name, description)
     * @param args.fileId - ID of the file to update
     * @param args.name - New name for the file (optional)
     * @param args.description - New description for the file (optional)
     * @returns Promise<GoogleDriveUpdateFileResult> Typed response with IDE autocomplete
     */
    updateFile: async (args: GoogleDriveUpdateFileArgs): Promise<GoogleDriveUpdateFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'updateFile',
        params: args || {}
      });
    }
  };
}

/**
 * Google Sheets Adapter
 * Category: productivity
 */
function createGoogleSheetsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new Google Sheets spreadsheet
     * @param args.title - Title of the spreadsheet
     */
    createSpreadsheet: async (args: GoogleSheetsCreateSpreadsheetArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'createSpreadsheet',
        params: args || {}
      });
    },

    /**
     * Read data from a range in a spreadsheet
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.range - Cell range (e.g., "Sheet1!A1:B10")
     */
    readRange: async (args: GoogleSheetsReadRangeArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'readRange',
        params: args || {}
      });
    },

    /**
     * Write data to a range in a spreadsheet
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.range - Cell range (e.g., "Sheet1!A1:B10")
     * @param args.values - Data to write (2D array)
     */
    writeRange: async (args: GoogleSheetsWriteRangeArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'writeRange',
        params: args || {}
      });
    },

    /**
     * Append a row to a spreadsheet
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetName - Name of the sheet
     * @param args.values - Row values to append
     */
    appendRow: async (args: GoogleSheetsAppendRowArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'appendRow',
        params: args || {}
      });
    },

    /**
     * Get spreadsheet metadata and properties
     * @param args.spreadsheetId - ID of the spreadsheet
     */
    getSpreadsheet: async (args: GoogleSheetsGetSpreadsheetArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'getSpreadsheet',
        params: args || {}
      });
    },

    /**
     * Insert a value at a specific cell with optional formatting
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.cell - Cell reference in format SheetName!A1
     * @param args.value - Value to insert
     * @param args.bold - Make text bold (optional)
     * @param args.italic - Make text italic (optional)
     * @param args.foregroundColor - Text color (hex or named color) (optional)
     * @param args.backgroundColor - Cell background color (hex or named color) (optional)
     */
    insertAtCell: async (args: GoogleSheetsInsertAtCellArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertAtCell',
        params: args || {}
      });
    },

    /**
     * Insert a formula at a specific cell
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.cell - Cell reference in format SheetName!A1
     * @param args.formula - Formula to insert (with or without leading =)
     * @param args.note - Optional note to add to the cell (optional)
     */
    insertFormula: async (args: GoogleSheetsInsertFormulaArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertFormula',
        params: args || {}
      });
    },

    /**
     * Apply formatting to a range of cells
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.range - Range in format SheetName!A1:B10
     * @param args.bold - Make text bold (optional)
     * @param args.italic - Make text italic (optional)
     * @param args.foregroundColor - Text color (hex or named color) (optional)
     * @param args.backgroundColor - Cell background color (hex or named color) (optional)
     * @param args.borders - Add borders to cells (optional)
     */
    formatRange: async (args: GoogleSheetsFormatRangeArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'formatRange',
        params: args || {}
      });
    },

    /**
     * Create a chart from spreadsheet data
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - ID of the sheet containing data
     * @param args.dataRange - Data range for the chart (e.g., A1:B10)
     * @param args.chartType - Chart type: BAR, LINE, AREA, PIE, or SCATTER
     * @param args.title - Chart title
     * @param args.position - Chart position with row, column, rowCount, columnCount
     */
    createChart: async (args: GoogleSheetsCreateChartArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'createChart',
        params: args || {}
      });
    },

    /**
     * Find and replace text in a spreadsheet
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.findText - Text to find
     * @param args.replaceText - Text to replace with
     * @param args.sheetName - Limit search to specific sheet (optional)
     * @param args.matchCase - Case-sensitive search (optional)
     * @param args.matchEntireCell - Match entire cell content only (optional)
     */
    findAndReplace: async (args: GoogleSheetsFindAndReplaceArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'findAndReplace',
        params: args || {}
      });
    },

    /**
     * Insert multiple rows of data at once
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetName - Name of the sheet
     * @param args.rowsData - 2D array of row data to insert
     * @param args.startingRow - Row number to start insertion (1-indexed). If not provided, appends to end (optional)
     * @param args.formattingOptions - Optional formatting to apply (bold, italic, foregroundColor, backgroundColor, borders) (optional)
     */
    insertMultipleRows: async (args: GoogleSheetsInsertMultipleRowsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertMultipleRows',
        params: args || {}
      });
    },

    /**
     * Clear content from a range of cells
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetName - Name of the sheet
     * @param args.range - Range to clear (e.g., A1:B10)
     */
    clearRange: async (args: GoogleSheetsClearRangeArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'clearRange',
        params: args || {}
      });
    },

    /**
     * Insert empty rows at a specific position in a sheet. IMPORTANT: Requires numeric sheetId (get from getSpreadsheet), not sheet name. Row indices are 0-indexed (row 1 in UI = index 0).
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
     * @param args.startRowIndex - Row index to start inserting at (0-indexed). To insert before row 5 in the UI, use index 4.
     * @param args.numRows - Number of rows to insert
     */
    insertRows: async (args: GoogleSheetsInsertRowsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertRows',
        params: args || {}
      });
    },

    /**
     * Delete rows from a sheet. IMPORTANT: Requires numeric sheetId (get from getSpreadsheet), not sheet name. Row indices are 0-indexed (row 1 in UI = index 0).
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
     * @param args.startRowIndex - Row index to start deleting from (0-indexed). To delete row 5 in the UI, use index 4.
     * @param args.numRows - Number of rows to delete
     */
    deleteRows: async (args: GoogleSheetsDeleteRowsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'deleteRows',
        params: args || {}
      });
    },

    /**
     * Insert empty columns at a specific position in a sheet. IMPORTANT: Requires numeric sheetId (get from getSpreadsheet), not sheet name. Column indices are 0-indexed (A=0, B=1, C=2, etc.).
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
     * @param args.startColumnIndex - Column index to start inserting at (0-indexed: A=0, B=1, C=2, D=3, etc.). To insert before column D, use index 3.
     * @param args.numColumns - Number of columns to insert
     */
    insertColumns: async (args: GoogleSheetsInsertColumnsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertColumns',
        params: args || {}
      });
    },

    /**
     * Delete columns from a sheet. IMPORTANT: Requires numeric sheetId (get from getSpreadsheet), not sheet name. Column indices are 0-indexed (A=0, B=1, C=2, etc.).
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
     * @param args.startColumnIndex - Column index to start deleting from (0-indexed: A=0, B=1, C=2, D=3, etc.). To delete column D, use index 3.
     * @param args.numColumns - Number of columns to delete
     */
    deleteColumns: async (args: GoogleSheetsDeleteColumnsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'deleteColumns',
        params: args || {}
      });
    },

    /**
     * Copy data from one range to another location within the same spreadsheet. IMPORTANT: Requires numeric sheetIds (get from getSpreadsheet), not sheet names. Can copy within same sheet or across sheets.
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sourceSheetId - Numeric sheet ID of the source sheet (get from getSpreadsheet response: sheets[n].properties.sheetId)
     * @param args.sourceRange - Source range in A1 notation WITHOUT sheet name (e.g., "A1:C5", not "Sheet1!A1:C5")
     * @param args.targetSheetId - Numeric sheet ID of the target sheet (can be same as sourceSheetId to copy within same sheet)
     * @param args.targetStartCell - Target start cell in A1 notation (e.g., "E1"). The copied data will fill cells starting from this position.
     */
    copyRange: async (args: GoogleSheetsCopyRangeArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'copyRange',
        params: args || {}
      });
    }
  };
}

/**
 * Google Docs Adapter
 * Category: productivity
 */
function createGoogleDocsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new Google Doc
     * @param args.title - Title of the document
     * @returns Promise<GoogleDocsCreateDocumentResult> Typed response with IDE autocomplete
     */
    createDocument: async (args: GoogleDocsCreateDocumentArgs): Promise<GoogleDocsCreateDocumentResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'createDocument',
        params: args || {}
      });
    },

    /**
     * Get a Google Doc by ID. Returns normalized flat structure with extracted fields.
     * @param args.documentId - ID of the document
     * @returns Promise<GoogleDocsGetDocumentResult> Typed response with IDE autocomplete
     */
    getDocument: async (args: GoogleDocsGetDocumentArgs): Promise<GoogleDocsGetDocumentResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'getDocument',
        params: args || {}
      });
    },

    /**
     * Append text to the end of a document
     * @param args.documentId - ID of the document
     * @param args.text - Text to append
     * @returns Promise<GoogleDocsAppendTextResult> Typed response with IDE autocomplete
     */
    appendText: async (args: GoogleDocsAppendTextArgs): Promise<GoogleDocsAppendTextResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'appendText',
        params: args || {}
      });
    },

    /**
     * Replace text in a document
     * @param args.documentId - ID of the document
     * @param args.searchText - Text to search for
     * @param args.replaceText - Text to replace with
     * @returns Promise<GoogleDocsReplaceTextResult> Typed response with IDE autocomplete
     */
    replaceText: async (args: GoogleDocsReplaceTextArgs): Promise<GoogleDocsReplaceTextResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'replaceText',
        params: args || {}
      });
    },

    /**
     * Get the text content of a Google Doc
     * @param args.documentId - ID of the document
     * @returns Promise<GoogleDocsGetDocumentContentResult> Typed response with IDE autocomplete
     */
    getDocumentContent: async (args: GoogleDocsGetDocumentContentArgs): Promise<GoogleDocsGetDocumentContentResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'getDocumentContent',
        params: args || {}
      });
    },

    /**
     * Insert text at a specific position in the document
     * @param args.documentId - ID of the document
     * @param args.text - Text to insert
     * @param args.position - Character position to insert at (1-indexed)
     * @returns Promise<GoogleDocsInsertTextAtPositionResult> Typed response with IDE autocomplete
     */
    insertTextAtPosition: async (args: GoogleDocsInsertTextAtPositionArgs): Promise<GoogleDocsInsertTextAtPositionResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertTextAtPosition',
        params: args || {}
      });
    },

    /**
     * Insert text after a search string in the document
     * @param args.documentId - ID of the document
     * @param args.searchText - Text to search for
     * @param args.textToInsert - Text to insert after the search text
     * @param args.occurrence - Which occurrence to insert after (default: 1) (optional)
     * @returns Promise<GoogleDocsInsertTextAfterResult> Typed response with IDE autocomplete
     */
    insertTextAfter: async (args: GoogleDocsInsertTextAfterArgs): Promise<GoogleDocsInsertTextAfterResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertTextAfter',
        params: args || {}
      });
    },

    /**
     * Insert a heading into the document
     * @param args.documentId - ID of the document
     * @param args.text - Heading text
     * @param args.level - Heading level (1-6)
     * @param args.position - Character position to insert at (optional)
     * @param args.insertAfterText - Insert after this text instead of at position (optional)
     * @returns Promise<GoogleDocsInsertHeadingResult> Typed response with IDE autocomplete
     */
    insertHeading: async (args: GoogleDocsInsertHeadingArgs): Promise<GoogleDocsInsertHeadingResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertHeading',
        params: args || {}
      });
    },

    /**
     * Insert a bulleted or numbered list into the document
     * @param args.documentId - ID of the document
     * @param args.items - Array of list items
     * @param args.listType - Type of list: "bulleted" or "numbered"
     * @param args.position - Character position to insert at (optional)
     * @param args.insertAfterText - Insert after this text instead of at position (optional)
     * @returns Promise<GoogleDocsInsertListResult> Typed response with IDE autocomplete
     */
    insertList: async (args: GoogleDocsInsertListArgs): Promise<GoogleDocsInsertListResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertList',
        params: args || {}
      });
    },

    /**
     * Insert a table into the document
     * @param args.documentId - ID of the document
     * @param args.data - 2D array of table data (rows x columns)
     * @param args.hasHeader - Whether the first row is a header (default: true) (optional)
     * @param args.position - Character position to insert at (optional)
     * @param args.insertAfterText - Insert after this text instead of at position (optional)
     * @returns Promise<GoogleDocsInsertTableResult> Typed response with IDE autocomplete
     */
    insertTable: async (args: GoogleDocsInsertTableArgs): Promise<GoogleDocsInsertTableResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertTable',
        params: args || {}
      });
    },

    /**
     * Replace the entire content of a document
     * @param args.documentId - ID of the document
     * @param args.newContent - New content to replace existing content
     * @returns Promise<GoogleDocsUpdateDocumentContentResult> Typed response with IDE autocomplete
     */
    updateDocumentContent: async (args: GoogleDocsUpdateDocumentContentArgs): Promise<GoogleDocsUpdateDocumentContentResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'updateDocumentContent',
        params: args || {}
      });
    },

    /**
     * Create a new section with a heading and content. Returns normalized result with insertion details.
     * @param args.documentId - ID of the document
     * @param args.heading - Section heading text
     * @param args.content - Section content text
     * @returns Promise<GoogleDocsCreateSectionResult> Typed response with IDE autocomplete
     */
    createSection: async (args: GoogleDocsCreateSectionArgs): Promise<GoogleDocsCreateSectionResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'createSection',
        params: args || {}
      });
    },

    /**
     * Find the character position for insertion based on position or search text. Returns normalized result with position and context.
     * @param args.documentId - ID of the document
     * @param args.position - Position to find (1 for start, -1 for end)
     * @param args.searchText - Text to search for (returns position after this text) (optional)
     * @returns Promise<GoogleDocsFindInsertionPointResult> Typed response with IDE autocomplete
     */
    findInsertionPoint: async (args: GoogleDocsFindInsertionPointArgs): Promise<GoogleDocsFindInsertionPointResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'findInsertionPoint',
        params: args || {}
      });
    }
  };
}

/**
 * Jira Adapter
 * Category: project
 */
function createJiraAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new Jira issue
     * @param args.projectKey - Jira project key (e.g., "PROJ")
     * @param args.summary - Issue summary/title
     * @param args.description - Issue description (optional)
     * @param args.issueType - Issue type (Task, Bug, Story, etc.) (optional)
     * @returns Promise<JiraCreateIssueResult> Typed response with IDE autocomplete
     */
    createIssue: async (args: JiraCreateIssueArgs): Promise<JiraCreateIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'createIssue',
        params: args || {}
      });
    },

    /**
     * Search Jira issues using JQL. Returns normalized flat issue summaries.
     * @param args.jql - JQL query string
     * @param args.maxResults - Maximum number of results (default: 50, max: 100) (optional)
     * @returns Promise<JiraSearchIssuesResult> Typed response with IDE autocomplete
     */
    searchIssues: async (args: JiraSearchIssuesArgs): Promise<JiraSearchIssuesResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'searchIssues',
        params: args || {}
      });
    },

    /**
     * Get a specific Jira issue by key or ID. Returns normalized flat structure.
     * @param args.issueKey - Issue key (e.g., "PROJ-123") or ID
     * @returns Promise<JiraGetIssueResult> Typed response with IDE autocomplete
     */
    getIssue: async (args: JiraGetIssueArgs): Promise<JiraGetIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getIssue',
        params: args || {}
      });
    },

    /**
     * Update an existing Jira issue
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @param args.summary - New issue summary/title (optional)
     * @param args.description - New issue description (optional)
     * @returns Promise<JiraUpdateIssueResult> Typed response with IDE autocomplete
     */
    updateIssue: async (args: JiraUpdateIssueArgs): Promise<JiraUpdateIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'updateIssue',
        params: args || {}
      });
    },

    /**
     * Delete a Jira issue
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @returns Promise<JiraDeleteIssueResult> Typed response with IDE autocomplete
     */
    deleteIssue: async (args: JiraDeleteIssueArgs): Promise<JiraDeleteIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'deleteIssue',
        params: args || {}
      });
    },

    /**
     * Add a comment to a Jira issue
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @param args.comment - Comment text
     * @returns Promise<JiraAddCommentResult> Typed response with IDE autocomplete
     */
    addComment: async (args: JiraAddCommentArgs): Promise<JiraAddCommentResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'addComment',
        params: args || {}
      });
    },

    /**
     * Transition a Jira issue to a different status
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @param args.transitionId - ID of the transition to perform
     * @returns Promise<JiraTransitionIssueResult> Typed response with IDE autocomplete
     */
    transitionIssue: async (args: JiraTransitionIssueArgs): Promise<JiraTransitionIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'transitionIssue',
        params: args || {}
      });
    },

    /**
     * Assign a Jira issue to a user
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @param args.accountId - Atlassian account ID of the assignee
     * @returns Promise<JiraAssignIssueResult> Typed response with IDE autocomplete
     */
    assignIssue: async (args: JiraAssignIssueArgs): Promise<JiraAssignIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'assignIssue',
        params: args || {}
      });
    },

    /**
     * Get all accessible Jira projects. Returns normalized flat project structures.
     * @returns Promise<JiraGetProjectsResult> Typed response with IDE autocomplete
     */
    getProjects: async (args?: {}): Promise<JiraGetProjectsResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getProjects',
        params: args || {}
      });
    },

    /**
     * List all accessible Jira projects (alias for getProjects). Returns normalized flat structures.
     * @returns Promise<JiraListProjectsResult> Typed response with IDE autocomplete
     */
    listProjects: async (args?: {}): Promise<JiraListProjectsResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'listProjects',
        params: args || {}
      });
    },

    /**
     * Get metadata for a specific Jira project. Returns normalized flat structures.
     * @param args.projectKey - Project key (e.g., "PROJ")
     * @returns Promise<JiraGetProjectMetadataResult> Typed response with IDE autocomplete
     */
    getProjectMetadata: async (args: JiraGetProjectMetadataArgs): Promise<JiraGetProjectMetadataResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getProjectMetadata',
        params: args || {}
      });
    },

    /**
     * Get available transitions for a Jira issue. Returns normalized flat structures.
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @returns Promise<JiraGetTransitionsResult> Typed response with IDE autocomplete
     */
    getTransitions: async (args: JiraGetTransitionsArgs): Promise<JiraGetTransitionsResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getTransitions',
        params: args || {}
      });
    },

    /**
     * List users that can be assigned to issues in a project
     * @param args.projectKey - Project key (e.g., "PROJ")
     * @returns Promise<JiraListAssignableUsersResult> Typed response with IDE autocomplete
     */
    listAssignableUsers: async (args: JiraListAssignableUsersArgs): Promise<JiraListAssignableUsersResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'listAssignableUsers',
        params: args || {}
      });
    },

    /**
     * Get available issue types for a project. Returns normalized flat structures.
     * @param args.projectKey - Project key (e.g., "PROJ")
     * @returns Promise<JiraGetIssueTypesResult> Typed response with IDE autocomplete
     */
    getIssueTypes: async (args: JiraGetIssueTypesArgs): Promise<JiraGetIssueTypesResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getIssueTypes',
        params: args || {}
      });
    },

    /**
     * Search Jira API for available operations beyond core tools
     * @param args.query - Describe what you want to do (e.g., "add label to card")
     * @param args.limit - Max results to return (default 5) (optional)
     */
    discoverExtended: async (args: JiraDiscoverExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'discoverExtended',
        params: args || {}
      });
    },

    /**
     * Execute a Jira API operation by operationId
     * @param args.operationId - The operationId from discoverExtended results
     * @param args.pathParams - Path parameters, e.g., { id: "abc123" } (optional)
     * @param args.queryParams - Query string parameters (optional)
     * @param args.body - Request body for POST/PUT/PATCH operations (optional)
     */
    executeExtended: async (args: JiraExecuteExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'executeExtended',
        params: args || {}
      });
    }
  };
}

/**
 * Twitter Adapter
 * Category: social
 */
function createTwitterAdapter(sdk: MirraSDK) {
  return {
    /**
     * Post a tweet
     * @param args.text - Tweet text (max 280 characters)
     */
    postTweet: async (args: TwitterPostTweetArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'twitter',
        method: 'postTweet',
        params: args || {}
      });
    },

    /**
     * Retrieve tweets from a Twitter user. Must provide either userId OR userName (not both). NOTE: This operation ONLY accepts the 4 parameters listed below. There is NO maxResults, limit, count, or similar parameters - the API returns ~20 tweets per page, use cursor for pagination.
     * @param args.userId - Twitter user ID (recommended for stability and speed). Provide userId OR userName, not both. (optional)
     * @param args.userName - Twitter username/handle without @ symbol (e.g., "elonmusk"). Provide userName OR userId, not both. (optional)
     * @param args.cursor - Pagination cursor from previous response's nextCursor field. Do not fabricate cursor values. (optional)
     * @param args.includeReplies - Whether to include replies in results. Defaults to false (only original tweets). (optional)
     */
    getUserTweets: async (args: TwitterGetUserTweetsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'twitter',
        method: 'getUserTweets',
        params: args || {}
      });
    },

    /**
     * Search tweets using advanced Twitter search syntax. Supports operators like from:username, since:date, until:date, lang:en, and boolean operators (AND, OR). NOTE: This operation ONLY accepts the 3 parameters listed below (query, queryType, cursor). There is NO minFollowers, maxResults, limit, or other filtering parameters - filter results client-side after fetching.
     * @param args.query - Search query with advanced syntax. Examples: "from:elonmusk", "bitcoin since:2024-01-01", "AI OR \"machine learning\"". Supported operators: from:user, to:user, since:YYYY-MM-DD, until:YYYY-MM-DD, lang:xx, filter:media, filter:links, -filter:retweets, AND, OR, -keyword, "exact phrase".
     * @param args.queryType - Type of search results: "Latest" (most recent) or "Top" (most relevant). Defaults to "Latest". Only these two values are valid. (optional)
     * @param args.cursor - Pagination cursor from previous response's nextCursor field. Do not fabricate cursor values. (optional)
     */
    advancedSearch: async (args: TwitterAdvancedSearchArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'twitter',
        method: 'advancedSearch',
        params: args || {}
      });
    }
  };
}

/**
 * Trello Adapter
 * Category: productivity
 */
function createTrelloAdapter(sdk: MirraSDK) {
  return {
    /**
     * Get all boards for the authenticated user
     */
    getBoards: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'getBoards',
        params: args || {}
      });
    },

    /**
     * Get a specific board by ID including its lists
     * @param args.boardId - The ID of the board to retrieve
     */
    getBoard: async (args: TrelloGetBoardArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'getBoard',
        params: args || {}
      });
    },

    /**
     * Create a new card in a Trello list
     * @param args.name - Card name/title
     * @param args.idList - ID of the list to add the card to
     * @param args.desc - Card description (supports markdown) (optional)
     */
    createCard: async (args: TrelloCreateCardArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'createCard',
        params: args || {}
      });
    },

    /**
     * Get a specific card by ID
     * @param args.cardId - The ID of the card to retrieve
     */
    getCard: async (args: TrelloGetCardArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'getCard',
        params: args || {}
      });
    },

    /**
     * Update an existing card
     * @param args.cardId - The ID of the card to update
     * @param args.name - New card name (optional)
     * @param args.desc - New card description (optional)
     * @param args.idList - Move card to a different list (optional)
     * @param args.closed - Archive the card (optional)
     */
    updateCard: async (args: TrelloUpdateCardArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'updateCard',
        params: args || {}
      });
    },

    /**
     * Delete a card permanently
     * @param args.cardId - The ID of the card to delete
     */
    deleteCard: async (args: TrelloDeleteCardArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'deleteCard',
        params: args || {}
      });
    },

    /**
     * Create a new checklist on a card
     * @param args.cardId - The ID of the card to add the checklist to
     * @param args.name - Checklist name
     */
    createChecklist: async (args: TrelloCreateChecklistArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'createChecklist',
        params: args || {}
      });
    },

    /**
     * Get a specific checklist by ID
     * @param args.checklistId - The ID of the checklist to retrieve
     */
    getChecklist: async (args: TrelloGetChecklistArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'getChecklist',
        params: args || {}
      });
    },

    /**
     * Update a checklist name
     * @param args.checklistId - The ID of the checklist to update
     * @param args.name - New checklist name
     */
    updateChecklist: async (args: TrelloUpdateChecklistArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'updateChecklist',
        params: args || {}
      });
    },

    /**
     * Delete a checklist from a card
     * @param args.checklistId - The ID of the checklist to delete
     */
    deleteChecklist: async (args: TrelloDeleteChecklistArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'deleteChecklist',
        params: args || {}
      });
    },

    /**
     * Add a check item to a checklist
     * @param args.checklistId - The ID of the checklist to add the item to
     * @param args.name - Check item text
     */
    addCheckItem: async (args: TrelloAddCheckItemArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'addCheckItem',
        params: args || {}
      });
    },

    /**
     * Update a check item (name or completion state)
     * @param args.cardId - The ID of the card containing the check item
     * @param args.checkItemId - The ID of the check item to update
     * @param args.name - New check item text (optional)
     * @param args.state - Check state: "complete" or "incomplete" (optional)
     */
    updateCheckItem: async (args: TrelloUpdateCheckItemArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'updateCheckItem',
        params: args || {}
      });
    },

    /**
     * Delete a check item from a checklist
     * @param args.checklistId - The ID of the checklist containing the item
     * @param args.checkItemId - The ID of the check item to delete
     */
    deleteCheckItem: async (args: TrelloDeleteCheckItemArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'deleteCheckItem',
        params: args || {}
      });
    },

    /**
     * Search Trello API for available operations beyond core tools
     * @param args.query - Describe what you want to do (e.g., "add label to card")
     * @param args.limit - Max results to return (default 5) (optional)
     */
    discoverExtended: async (args: TrelloDiscoverExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'discoverExtended',
        params: args || {}
      });
    },

    /**
     * Execute a Trello API operation by operationId
     * @param args.operationId - The operationId from discoverExtended results
     * @param args.pathParams - Path parameters, e.g., { id: "abc123" } (optional)
     * @param args.queryParams - Query string parameters (optional)
     * @param args.body - Request body for POST/PUT/PATCH operations (optional)
     */
    executeExtended: async (args: TrelloExecuteExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'executeExtended',
        params: args || {}
      });
    }
  };
}

/**
 * Jupiter Adapter
 * Category: crypto
 */
function createJupiterAdapter(sdk: MirraSDK) {
  return {
    /**
     * Execute a token swap on Jupiter DEX
     * @param args.inputMint - Input token mint address
     * @param args.outputMint - Output token mint address
     * @param args.amount - Amount to swap (in smallest unit)
     * @param args.inputDecimals - Number of decimals for input token
     * @param args.slippageBps - Slippage tolerance in basis points (default: 50) (optional)
     */
    swap: async (args: JupiterSwapArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'swap',
        params: args || {}
      });
    },

    /**
     * Get token holdings for a wallet
     * @param args.walletAddress - Wallet address to check (uses actor wallet if not provided) (optional)
     */
    getHoldings: async (args: JupiterGetHoldingsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'getHoldings',
        params: args || {}
      });
    },

    /**
     * Get token security information using Jupiter Shield
     * @param args.tokenMint - Token mint address to check security for
     */
    getTokenSecurity: async (args: JupiterGetTokenSecurityArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'getTokenSecurity',
        params: args || {}
      });
    },

    /**
     * Search for tokens by symbol, name, or mint address
     * @param args.query - Search query (symbol, name, or mint address)
     */
    searchTokens: async (args: JupiterSearchTokensArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'searchTokens',
        params: args || {}
      });
    },

    /**
     * Refresh an expired swap with new quote and transaction
     * @param args.feedItemId - Feed item ID containing the swap to refresh
     * @param args.swapId - Original swap ID
     * @param args.inputMint - Input token mint address
     * @param args.outputMint - Output token mint address
     * @param args.amount - Amount to swap (in UI units)
     * @param args.inputDecimals - Input token decimals
     * @param args.slippageBps - Slippage tolerance in basis points (optional)
     */
    refreshSwap: async (args: JupiterRefreshSwapArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'refreshSwap',
        params: args || {}
      });
    }
  };
}

/**
 * Crypto Adapter
 * Category: crypto
 */
function createCryptoAdapter(sdk: MirraSDK) {
  return {
    /**
     * Get the current price of a crypto asset
     * @param args.tokenAddress - Token contract address (EVM: 0x..., SVM: base58)
     * @param args.chainName - Specific chain name (auto-detected if not provided) (optional)
     */
    getPrice: async (args: CryptoGetPriceArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'getPrice',
        params: args || {}
      });
    },

    /**
     * Send cryptocurrency or tokens (creates pending transaction for signing)
     * @param args.recipient - Contact username, user ID, or Solana wallet address
     * @param args.token - Token symbol (SOL, USDC), name, or mint address
     * @param args.amount - Amount to send (in UI units)
     */
    sendToken: async (args: CryptoSendTokenArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'sendToken',
        params: args || {}
      });
    },

    /**
     * Set up automated price monitoring with progressive alerts
     * @param args.tokenAddress - Token contract address to monitor
     * @param args.direction - Alert direction: "above" or "below"
     * @param args.targetPrice - Target price in USD to trigger alert
     * @param args.scriptId - ID of the script to execute when price target is reached
     * @param args.chainName - Chain name (auto-detected if not provided) (optional)
     * @param args.percentStep - Progressive alert step percentage (default: 0.1 = 10%) (optional)
     */
    monitorPrice: async (args: CryptoMonitorPriceArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'monitorPrice',
        params: args || {}
      });
    },

    /**
     * List all active crypto price monitoring assignments
     */
    listSubscriptions: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'listSubscriptions',
        params: args || {}
      });
    },

    /**
     * Stop monitoring a crypto asset
     * @param args.tokenAddress - Token address to stop monitoring
     */
    unsubscribeAsset: async (args: CryptoUnsubscribeAssetArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'unsubscribeAsset',
        params: args || {}
      });
    },

    /**
     * Refresh an expired transaction with new blockhash and updated details
     * @param args.feedItemId - Feed item ID containing the transaction to refresh
     * @param args.transferId - Original transfer ID
     * @param args.recipient - Recipient address
     * @param args.token - Token symbol or mint address
     * @param args.amount - Amount to send
     * @param args.tokenMint - Token mint address (optional, will resolve if not provided) (optional)
     * @param args.tokenDecimals - Token decimals (optional) (optional)
     */
    refreshTransaction: async (args: CryptoRefreshTransactionArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'refreshTransaction',
        params: args || {}
      });
    }
  };
}

/**
 * Scripts Adapter
 * Category: productivity
 */
function createScriptsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new script with initial version and API key. IMPORTANT: The script ID for subsequent operations (deployScript, executeScript, etc.) is returned at data._id in the response.
     * @param args.name - Name of the script
     * @param args.description - Description of what the script does (optional)
     * @param args.runtime - Lambda runtime (default: nodejs18) (optional)
     * @param args.config - Script configuration (timeout, memory, maxCostPerExecution, etc.) (optional)
     * @param args.code - Initial JavaScript/TypeScript code for the script
     */
    createScript: async (args: ScriptsCreateScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'createScript',
        params: args || {}
      });
    },

    /**
     * Delete a script and all its versions
     * @param args.scriptId - ID of the script to delete
     */
    deleteScript: async (args: ScriptsDeleteScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'deleteScript',
        params: args || {}
      });
    },

    /**
     * Create a new version of an existing script.
     * @param args.scriptId - ID of the script
     * @param args.code - Updated code for the new version
     * @param args.commitMessage - Description of changes in this version (optional)
     */
    createVersion: async (args: ScriptsCreateVersionArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'createVersion',
        params: args || {}
      });
    },

    /**
     * List all versions of a script
     * @param args.scriptId - ID of the script
     */
    listVersions: async (args: ScriptsListVersionsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'listVersions',
        params: args || {}
      });
    },

    /**
     * Deploy a script version to AWS Lambda. Must be called after createScript to make the script executable.
     * @param args.scriptId - ID of the script to deploy (from createScript response at data._id)
     * @param args.version - Version number to deploy (default: latest) (optional)
     */
    deployScript: async (args: ScriptsDeployScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'deployScript',
        params: args || {}
      });
    },

    /**
     * Execute a deployed script with custom data. Script must be deployed first via deployScript.
     * @param args.scriptId - ID of the script to execute (from createScript response at data._id)
     * @param args.data - Input data to pass to the script (optional)
     * @param args.trigger - Trigger information (type, source, event) (optional)
     */
    executeScript: async (args: ScriptsExecuteScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'executeScript',
        params: args || {}
      });
    },

    /**
     * Get details of a specific script
     * @param args.scriptId - ID of the script
     */
    getScript: async (args: ScriptsGetScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getScript',
        params: args || {}
      });
    },

    /**
     * List all scripts owned by the user
     */
    listScripts: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'listScripts',
        params: args || {}
      });
    },

    /**
     * Get execution history for a script
     * @param args.scriptId - ID of the script
     * @param args.status - Filter by status (completed, failed, running) (optional)
     * @param args.limit - Maximum number of executions to return (default: 100) (optional)
     */
    getExecutions: async (args: ScriptsGetExecutionsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getExecutions',
        params: args || {}
      });
    },

    /**
     * Get details of a specific execution
     * @param args.executionId - ID of the execution
     */
    getExecution: async (args: ScriptsGetExecutionArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getExecution',
        params: args || {}
      });
    },

    /**
     * Publish a script to the marketplace
     * @param args.scriptId - ID of the script to publish
     * @param args.pricing - Pricing configuration for the marketplace (optional)
     */
    publishScript: async (args: ScriptsPublishScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'publishScript',
        params: args || {}
      });
    },

    /**
     * Remove a script from the marketplace
     * @param args.scriptId - ID of the script to unpublish
     */
    unpublishScript: async (args: ScriptsUnpublishScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'unpublishScript',
        params: args || {}
      });
    },

    /**
     * Search and list published scripts in the marketplace with filtering and sorting options
     * @param args.name - Exact match on script name (optional)
     * @param args.system - Filter by system scripts (scope="system") when true, user scripts when false (optional)
     * @param args.search - Text search on name and description (optional)
     * @param args.tags - Filter by tags (matches scripts with any of the specified tags) (optional)
     * @param args.category - Filter by UI category (notification, data_sync, automation, utility, reporting) (optional)
     * @param args.pricingModel - Filter by pricing model (free, pay-per-execution, subscription) (optional)
     * @param args.staffPick - Filter to only staff-picked scripts when true (optional)
     * @param args.minRating - Minimum rating threshold (0-5) (optional)
     * @param args.requiredIntegrations - Filter by required integrations (e.g., ["telegram", "gmail"]) (optional)
     * @param args.sortBy - Sort field: rating, installCount, trendingScore, publishedAt, name (default: rating) (optional)
     * @param args.sortOrder - Sort order: asc or desc (default: desc) (optional)
     * @param args.limit - Maximum number of results to return (default: 50, max: 100) (optional)
     * @param args.offset - Number of results to skip for pagination (default: 0) (optional)
     */
    listMarketplaceScripts: async (args: ScriptsListMarketplaceScriptsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'listMarketplaceScripts',
        params: args || {}
      });
    },

    /**
     * Get execution metrics for a script
     * @param args.scriptId - ID of the script
     */
    getMetrics: async (args: ScriptsGetMetricsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getMetrics',
        params: args || {}
      });
    },

    /**
     * Create a webhook endpoint for the script
     * @param args.scriptId - ID of the script
     * @param args.name - Name of the webhook
     * @param args.enabled - Whether webhook is enabled (default: true) (optional)
     */
    createWebhook: async (args: ScriptsCreateWebhookArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'createWebhook',
        params: args || {}
      });
    },

    /**
     * Create a cron schedule for the script
     * @param args.scriptId - ID of the script
     * @param args.name - Name of the schedule
     * @param args.cronExpression - Cron expression (e.g., "0 9 * * *" for daily at 9am)
     * @param args.enabled - Whether schedule is enabled (default: true) (optional)
     * @param args.data - Data to pass to the script on scheduled execution (optional)
     */
    createSchedule: async (args: ScriptsCreateScheduleArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'createSchedule',
        params: args || {}
      });
    },

    /**
     * Get the script code for a specific flow
     * @param args.flowId - ID of the flow to get script code for
     */
    getFlowScript: async (args: ScriptsGetFlowScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getFlowScript',
        params: args || {}
      });
    },

    /**
     * Modify the script code for a flow. Automatically creates a copy if user doesn't own the original, deploys to Lambda, and updates the flow.
     * @param args.flowId - ID of the flow to modify
     * @param args.newCode - New code to deploy
     * @param args.commitMessage - Description of changes (optional)
     */
    modifyFlowScript: async (args: ScriptsModifyFlowScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'modifyFlowScript',
        params: args || {}
      });
    },

    /**
     * Validate script code BEFORE creating or deploying. Checks for: 1) Missing async handler wrapper (top-level await errors), 2) Invalid adapter operations. Returns validation errors with suggestions for fixes. ALWAYS use this before createScript/modifyFlowScript.
     * @param args.code - The script code to validate
     */
    lintScript: async (args: ScriptsLintScriptArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'lintScript',
        params: args || {}
      });
    }
  };
}

/**
 * Feedback Adapter
 * Category: internal
 */
function createFeedbackAdapter(sdk: MirraSDK) {
  return {
    /**
     * Report a bug with detailed context and reproduction steps
     * @param args.title - Brief bug description
     * @param args.description - Detailed description of the bug
     * @param args.severity - Bug severity: critical, high, medium, or low
     * @param args.stepsToReproduce - Steps to reproduce the bug (optional)
     * @param args.expectedBehavior - What should happen (optional)
     * @param args.actualBehavior - What actually happens (optional)
     * @param args.errorDetails - Error details: { message, stack, code } (optional)
     * @param args.context - Additional context: { conversationId, recentMessages, platform, appVersion } (optional)
     * @param args.llmAnalysis - LLM analysis of the issue (optional)
     */
    reportBug: async (args: FeedbackReportBugArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'reportBug',
        params: args || {}
      });
    },

    /**
     * Auto-report tool or adapter failures for debugging
     * @param args.adapterType - Adapter type (e.g., jupiter, crypto)
     * @param args.operation - Operation that failed (e.g., swap, sendToken)
     * @param args.errorMessage - Error message from the failure
     * @param args.errorCode - Error code if available (optional)
     * @param args.errorStack - Error stack trace (optional)
     * @param args.args - Sanitized arguments that caused the failure (optional)
     * @param args.llmAnalysis - LLM analysis of why it failed (optional)
     * @param args.suggestedFix - LLM suggested fix (optional)
     * @param args.context - Additional context: { conversationId, userId, timestamp } (optional)
     */
    reportToolFailure: async (args: FeedbackReportToolFailureArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'reportToolFailure',
        params: args || {}
      });
    },

    /**
     * Report when LLM cannot fulfill a user request
     * @param args.userRequest - What the user asked for
     * @param args.reason - Why it could not be fulfilled
     * @param args.suggestedCapability - What capability would enable this (optional)
     * @param args.relatedAdapters - Adapters that might be relevant (optional)
     * @param args.context - Additional context: { conversationId } (optional)
     */
    reportMissingCapability: async (args: FeedbackReportMissingCapabilityArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'reportMissingCapability',
        params: args || {}
      });
    },

    /**
     * Submit general user feedback
     * @param args.sentiment - Sentiment: positive, negative, or neutral
     * @param args.feedback - Feedback content
     * @param args.category - Category: ux, performance, feature, or general (optional)
     * @param args.context - Additional context: { feature, screen } (optional)
     */
    submitFeedback: async (args: FeedbackSubmitFeedbackArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'submitFeedback',
        params: args || {}
      });
    },

    /**
     * Submit a feature request
     * @param args.title - Feature title
     * @param args.description - Feature description
     * @param args.useCase - Why the user needs this feature (optional)
     * @param args.priority - Priority: high, medium, or low (optional)
     */
    submitFeatureRequest: async (args: FeedbackSubmitFeatureRequestArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'submitFeatureRequest',
        params: args || {}
      });
    }
  };
}

/**
 * Mirra Messaging Adapter
 * Category: communication
 */
function createMirraMessagingAdapter(sdk: MirraSDK) {
  return {
    /**
     * Send a message to a group (including direct chats). The message is sent as the authenticated user with optional automation metadata.
     * @param args.groupId - Group ID to send the message to (use getContacts or getGroups to get the groupId)
     * @param args.content - Message text content
     * @param args.automation - Automation metadata: { source: string, flowId?: string, flowTitle?: string, sessionId?: string, isAutomated?: boolean }. Use sessionId to group related messages and enable Flow-based reply routing. (optional)
     * @param args.structuredData - Structured data for rich UI rendering: [{ displayType, templateId, data, metadata?, interactions? }] (optional)
     */
    sendMessage: async (args: MirraMessagingSendMessageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'sendMessage',
        params: args || {}
      });
    },

    /**
     * Update an existing message sent by the authenticated user
     * @param args.messageId - ID of the message to update
     * @param args.content - New message text content
     * @param args.structuredData - Updated structured data for rich UI rendering (optional)
     */
    updateMessage: async (args: MirraMessagingUpdateMessageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'updateMessage',
        params: args || {}
      });
    },

    /**
     * Get list of accepted contacts for the user
     * @param args.limit - Maximum number of contacts to return (default 50) (optional)
     * @param args.offset - Offset for pagination (default 0) (optional)
     */
    getContacts: async (args: MirraMessagingGetContactsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'getContacts',
        params: args || {}
      });
    },

    /**
     * Find a contact by username or partial name match
     * @param args.query - Username or name to search for
     */
    findContact: async (args: MirraMessagingFindContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'findContact',
        params: args || {}
      });
    },

    /**
     * Get list of chat instances for the user
     * @param args.scope - Filter by scope: direct, user, group, or all (default all) (optional)
     * @param args.limit - Maximum number of chats to return (default 50) (optional)
     */
    getChats: async (args: MirraMessagingGetChatsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'getChats',
        params: args || {}
      });
    },

    /**
     * Get list of groups the user is a member of
     * @param args.limit - Maximum number of groups to return (default 50) (optional)
     */
    getGroups: async (args: MirraMessagingGetGroupsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'getGroups',
        params: args || {}
      });
    },

    /**
     * Create a new group. The authenticated user becomes the group owner.
     * @param args.name - Group name (max 100 characters)
     * @param args.description - Group description (max 500 characters) (optional)
     * @param args.category - Category for organization: "family", "friends", "work", or "other" (default: "other") (optional)
     * @param args.memberIds - Array of user IDs to add as initial members (optional)
     */
    createGroup: async (args: MirraMessagingCreateGroupArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'createGroup',
        params: args || {}
      });
    },

    /**
     * Search chat messages by keywords. Returns summaries by default to avoid overwhelming context. Use includeFullText for complete messages.
     * @param args.query - Keywords to search for
     * @param args.contactName - Contact name to filter by sender (resolved to userId) (optional)
     * @param args.groupName - Group name to limit search (resolved to groupId) (optional)
     * @param args.groupId - Group ID to limit search (use groupName for name-based lookup) (optional)
     * @param args.scope - "direct", "group", or "all" (default) (optional)
     * @param args.startDate - ISO date for time range start (optional)
     * @param args.endDate - ISO date for time range end (optional)
     * @param args.includeFullText - Include full message text (default: false, returns snippets) (optional)
     * @param args.snippetLength - Max chars for snippet (default: 200) (optional)
     * @param args.limit - Max results (default 20, max 50) (optional)
     * @param args.offset - Pagination offset (optional)
     */
    searchMessages: async (args: MirraMessagingSearchMessagesArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'searchMessages',
        params: args || {}
      });
    }
  };
}

/**
 * Moltbook Adapter
 * Category: social
 */
function createMoltbookAdapter(sdk: MirraSDK) {
  return {
    /**
     * Register a new agent on Moltbook. Returns API key and claim URL for verification.
     * @param args.agentName - Unique name for your agent (alphanumeric, underscores allowed)
     */
    registerAgent: async (args: MoltbookRegisterAgentArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'registerAgent',
        params: args || {}
      });
    },

    /**
     * Create a new post on Moltbook (rate limited: 1 post per 30 minutes)
     * @param args.content - Post content/body text
     * @param args.title - Post title (optional) (optional)
     * @param args.type - Post type: "text" or "link" (default: text) (optional)
     * @param args.url - URL for link posts (optional)
     * @param args.submolt - Community name to post in (optional) (optional)
     */
    createPost: async (args: MoltbookCreatePostArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'createPost',
        params: args || {}
      });
    },

    /**
     * Get posts from Moltbook feed
     * @param args.sort - Sort order: "hot", "new", "top", "rising" (default: hot) (optional)
     * @param args.limit - Max posts to return (default: 25) (optional)
     * @param args.submolt - Filter by community name (optional)
     */
    getPosts: async (args: MoltbookGetPostsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getPosts',
        params: args || {}
      });
    },

    /**
     * Get a single post by ID
     * @param args.postId - Post ID
     */
    getPost: async (args: MoltbookGetPostArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getPost',
        params: args || {}
      });
    },

    /**
     * Delete your own post
     * @param args.postId - Post ID to delete
     */
    deletePost: async (args: MoltbookDeletePostArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'deletePost',
        params: args || {}
      });
    },

    /**
     * Add a comment to a post (rate limited: 50 comments per hour)
     * @param args.postId - Post ID to comment on
     * @param args.content - Comment content
     * @param args.parentId - Parent comment ID for replies (optional)
     */
    createComment: async (args: MoltbookCreateCommentArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'createComment',
        params: args || {}
      });
    },

    /**
     * Get comments on a post
     * @param args.postId - Post ID
     * @param args.sort - Sort: "top", "new", "controversial" (default: top) (optional)
     */
    getComments: async (args: MoltbookGetCommentsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getComments',
        params: args || {}
      });
    },

    /**
     * Upvote a post
     * @param args.postId - Post ID to upvote
     */
    upvotePost: async (args: MoltbookUpvotePostArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'upvotePost',
        params: args || {}
      });
    },

    /**
     * Downvote a post
     * @param args.postId - Post ID to downvote
     */
    downvotePost: async (args: MoltbookDownvotePostArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'downvotePost',
        params: args || {}
      });
    },

    /**
     * Upvote a comment
     * @param args.commentId - Comment ID to upvote
     */
    upvoteComment: async (args: MoltbookUpvoteCommentArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'upvoteComment',
        params: args || {}
      });
    },

    /**
     * Create a new community (submolt)
     * @param args.name - Community name (alphanumeric, underscores)
     * @param args.description - Community description
     */
    createSubmolt: async (args: MoltbookCreateSubmoltArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'createSubmolt',
        params: args || {}
      });
    },

    /**
     * List all communities
     */
    getSubmolts: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getSubmolts',
        params: args || {}
      });
    },

    /**
     * Get community details
     * @param args.name - Community name
     */
    getSubmolt: async (args: MoltbookGetSubmoltArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getSubmolt',
        params: args || {}
      });
    },

    /**
     * Subscribe to a community
     * @param args.name - Community name to subscribe to
     */
    subscribe: async (args: MoltbookSubscribeArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'subscribe',
        params: args || {}
      });
    },

    /**
     * Unsubscribe from a community
     * @param args.name - Community name to unsubscribe from
     */
    unsubscribe: async (args: MoltbookUnsubscribeArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'unsubscribe',
        params: args || {}
      });
    },

    /**
     * Follow another agent
     * @param args.agentName - Agent name to follow
     */
    followAgent: async (args: MoltbookFollowAgentArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'followAgent',
        params: args || {}
      });
    },

    /**
     * Unfollow an agent
     * @param args.agentName - Agent name to unfollow
     */
    unfollowAgent: async (args: MoltbookUnfollowAgentArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'unfollowAgent',
        params: args || {}
      });
    },

    /**
     * Get an agent's profile
     * @param args.agentName - Agent name
     */
    getProfile: async (args: MoltbookGetProfileArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getProfile',
        params: args || {}
      });
    },

    /**
     * Get your own agent profile
     */
    getMyProfile: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getMyProfile',
        params: args || {}
      });
    },

    /**
     * Update your agent profile
     * @param args.description - New profile description (optional)
     * @param args.metadata - Additional metadata (optional)
     */
    updateProfile: async (args: MoltbookUpdateProfileArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'updateProfile',
        params: args || {}
      });
    },

    /**
     * Get personalized feed (subscriptions + follows)
     * @param args.limit - Max posts to return (default: 25) (optional)
     */
    getFeed: async (args: MoltbookGetFeedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getFeed',
        params: args || {}
      });
    },

    /**
     * Search posts, agents, and communities
     * @param args.query - Search query
     */
    search: async (args: MoltbookSearchArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'search',
        params: args || {}
      });
    },

    /**
     * Check agent claim/verification status
     */
    getStatus: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getStatus',
        params: args || {}
      });
    }
  };
}


// ============================================================================
// Exports
// ============================================================================

export const generatedAdapters = {
  flows: createFlowsAdapter,
  user: createUserAdapter,
  contacts: createContactsAdapter,
  memory: createMemoryAdapter,
  ai: createAiAdapter,
  document: createDocumentAdapter,
  feedItems: createFeedItemsAdapter,
  telegram: createTelegramAdapter,
  googleGmail: createGoogleGmailAdapter,
  googleCalendar: createGoogleCalendarAdapter,
  googleDrive: createGoogleDriveAdapter,
  googleSheets: createGoogleSheetsAdapter,
  googleDocs: createGoogleDocsAdapter,
  jira: createJiraAdapter,
  twitter: createTwitterAdapter,
  trello: createTrelloAdapter,
  jupiter: createJupiterAdapter,
  crypto: createCryptoAdapter,
  scripts: createScriptsAdapter,
  feedback: createFeedbackAdapter,
  mirraMessaging: createMirraMessagingAdapter,
  moltbook: createMoltbookAdapter
};