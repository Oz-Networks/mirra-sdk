/**
 * Auto-Generated SDK Adapter Methods
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * Generated from adapter operation schemas
 * Run: npm run generate:llm-api
 */

import { MirraSDK } from '../client';

// ============================================================================
// Base Result Type
// ============================================================================

/**
 * Structured data for rich UI rendering in chat messages
 */
export interface ToolResultStructuredData {
  displayType: 'list' | 'card' | 'table' | 'chart' | 'code' | 'markdown';
  templateId?: string;
  data: any;
  metadata?: Record<string, any>;
}

/**
 * Base result type for all adapter operations
 */
export interface AdapterResultBase<T = any> {
  id: string;
  status: 'success' | 'pending' | 'failed';
  timestamp: string;
  data: T;
  structuredData?: ToolResultStructuredData[];
  metadata?: {
    executionMode: 'standard' | 'delegated' | 'service';
    actorId?: string;
    adapter?: string;
    [key: string]: any;
  };
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

// ============================================================================
// Type Definitions
// ============================================================================

// Flows Adapter Types
export interface FlowsCreateFlowArgs {
  title?: string; // Flow title. Required if providing inline code.
  description?: string; // Detailed description of what the flow does
  code?: string; // Inline script code. If provided, auto-creates, deploys, and links the script. Cannot use with scriptId.
  scriptId?: string; // ID of existing deployed script. Cannot use with code.
  schedule?: string; // Cron expression for time-based flows. Times are automatically evaluated in the user's local timezone. Example: "0 9 * * *" runs at 9am in the user's timezone.
  eventType?: string; // Event type shorthand (e.g., "telegram.message", "gmail.email_received"). Creates an eventFilter matching this type.
  eventFilter?: any; // Full event filter with operator and conditions array for complex filtering.
  trigger?: any; // Legacy nested trigger structure. Prefer eventType or eventFilter instead.
  scriptInput?: any; // Static input data passed to the script. Fields are spread into event.data, so scriptInput: { apiKey: "sk-123" } is accessed as event.data.apiKey in handler code. The linter validates code against these fields.
  scriptInputSchema?: any; // Schema describing scriptInput fields (auto-inferred from scriptInput values if not provided). Keys are field names, values are { type: "string"|"number"|"boolean"|"object"|"array", required?: boolean, description?: string }. When provided, the linter can catch typos in event.data.fieldName access as errors instead of warnings.
  enabled?: boolean; // Whether the flow is enabled (default: true)
}
export interface FlowsCreateTimeFlowArgs {
  title: string; // Flow title
  description: string; // Detailed description of what the flow does
  schedule: string; // Cron expression for scheduling (e.g., "0 9 * * *" for daily at 9am)
  scriptId: string; // ID of the script to execute when triggered
  scriptInput?: any; // Static input data passed to the script. Fields are spread into event.data (e.g., scriptInput: { apiKey: "sk-123" } → event.data.apiKey in handler).
  scriptInputSchema?: any; // Schema describing scriptInput fields (auto-inferred from scriptInput values if not provided). Keys are field names, values are { type, required?, description? }.
}
export interface FlowsCreateEventFlowArgs {
  title: string; // Flow title
  description: string; // Detailed description of what the flow does
  trigger: any; // Event filter conditions that determine WHEN the script runs. Add ALL filtering logic here to minimize Lambda invocations. Must have type:"event" and config.eventFilter with operator and conditions array.
  scriptId: string; // ID of the script to execute when triggered
  scriptInput?: any; // Static input data passed to the script. Fields are spread into event.data (e.g., scriptInput: { apiKey: "sk-123" } → event.data.apiKey in handler).
  scriptInputSchema?: any; // Schema describing scriptInput fields (auto-inferred from scriptInput values if not provided). Keys are field names, values are { type, required?, description? }.
}
export interface FlowsListFlowsArgs {
  status?: string; // Filter by status: active, paused, completed, failed
}
export interface FlowsGetFlowArgs {
  id: string; // Flow ID
}
export interface FlowsUpdateFlowArgs {
  id: string; // Flow ID to update
  title?: string; // New title
  description?: string; // New description
  trigger?: any; // New trigger configuration
  scriptId?: string; // New script ID
  scriptInput?: any; // New static input data for the script. Fields are spread into event.data in handler code.
  scriptInputSchema?: any; // Schema describing scriptInput fields. Keys are field names, values are { type, required?, description? }.
  status?: string; // New status: active, paused, completed, failed
}
export interface FlowsDeleteFlowArgs {
  id: string; // Flow ID to delete
}
export interface FlowsPauseFlowArgs {
  id: string; // Flow ID to pause
}
export interface FlowsResumeFlowArgs {
  id: string; // Flow ID to resume
}
export interface FlowsSearchFlowsArgs {
  status?: string; // Filter by status (or array of statuses)
  triggerType?: string; // Filter by trigger type: time or event
  limit?: number; // Maximum number of results (default: 100)
  offset?: number; // Pagination offset (default: 0)
}
export interface FlowsRecordExecutionArgs {
  id: string; // Flow ID
  success: boolean; // Whether execution succeeded
  result?: any; // Execution result data
  error?: string; // Error message if execution failed
}
export interface FlowsListEventTypesArgs {
  includeTemplates?: boolean; // Include condition templates for each event type
  includeSchema?: boolean; // Include field schema showing available paths for script access. RECOMMENDED when writing scripts to see correct field access patterns.
}
export interface FlowsTestFlowArgs {
  flowId: string; // ID of the flow to test
  dryRun?: boolean; // If true (default), only validate trigger matching without executing script. If false, execute the script (causes side effects).
  eventOverrides?: any; // Custom field values to merge into the generated test event (e.g., {"content.text": "custom message"})
}
export interface FlowsValidateTriggerArgs {
  flowId: string; // ID of the flow
  event: any; // Event object to test against the trigger (must match IntegrationEvent structure)
}
export interface FlowsGetFlowsByEventTypeArgs {
  eventType: string; // Event type to filter by (e.g., "call.action", "call.ended", "telegram.message")
}
export interface FlowsCreateBatchOperationArgs {
  title: string; // Human-readable title for this batch operation (e.g., "Leave 100 Telegram groups")
  operations: any[]; // Array of operations to execute. Each item must have adapter, operation, and args properties.
  batchSize?: number; // Number of operations to process per execution (default: 5)
  intervalSeconds?: number; // Seconds between batch executions (default: 60, minimum: 60)
}
export interface FlowsPublishFlowArgs {
  flowId: string; // ID of the flow to publish
  pricing?: any; // Pricing configuration. Defaults to { model: "free" }. Supported models: "free", "pay-per-execution". For paid models, include basePrice.
  tags?: any[]; // Tags for marketplace discovery (e.g., ["telegram", "automation"])
  category?: string; // Marketplace category (e.g., "messaging", "productivity"). Defaults to "uncategorized".
}
export interface FlowsUnpublishFlowArgs {
  flowId: string; // ID of the flow to unpublish
}

// User Adapter Types
export interface UserUpdateProfileArgs {
  username?: string; // New username (3-30 characters, alphanumeric with underscores/hyphens)
  email?: string; // New email address
  timezone?: string; // IANA timezone identifier (e.g., America/Los_Angeles)
  phoneNumber?: string; // Phone number (7-15 digits with optional formatting)
}
export interface UserUpdatePreferencesArgs {
  timezone?: string; // Preferred timezone for scheduling
  socials?: any; // Social media links (twitter, discord)
}
export interface UserDeactivateAccountArgs {
  confirm: boolean; // Must be true to confirm account deactivation
}

// Contacts Adapter Types
export interface ContactsListContactsArgs {
  limit?: number; // Maximum number of contacts to return (default: 100)
  offset?: number; // Number of contacts to skip for pagination (default: 0)
}
export interface ContactsGetContactArgs {
  contactId?: string; // The contact user ID (MongoDB ObjectId)
  username?: string; // The contact username
}
export interface ContactsAddContactArgs {
  username: string; // Username of the user to add as a contact
}
export interface ContactsRemoveContactArgs {
  contactId?: string; // The contact user ID to remove
  username?: string; // The contact username to remove
}
export interface ContactsSearchContactsArgs {
  query: string; // Search query - can be username, email, phone, or wallet address
  searchType?: string; // Type of search to perform: all, username, email, phone, or wallet (default: all)
  limit?: number; // Maximum number of results (default: 20)
}
export interface ContactsBlockContactArgs {
  contactId?: string; // The user ID to block
  username?: string; // The username to block
}
export interface ContactsUnblockContactArgs {
  contactId?: string; // The user ID to unblock
  username?: string; // The username to unblock
}
export interface ContactsGetBlockedContactsArgs {
  limit?: number; // Maximum number of results (default: 100)
  offset?: number; // Number of items to skip for pagination (default: 0)
}
export interface ContactsGetContactRequestsArgs {
  type?: string; // Type of requests to retrieve: all, sent, or received (default: all)
  status?: string; // Filter by request status: pending, accepted, or rejected (default: pending)
}

// Memory Adapter Types
export interface MemoryCreateArgs {
  type: string; // Memory subtype: "note" (general notes), "idea" (concepts/ideas), "shopping_item" (shopping list), "topic" (general knowledge), "document" (documents), "contact" (people), "event" (calendar items). For tasks with assignment, use createTask instead.
  content: string; // Main content/description of the memory
  metadata?: any; // Additional metadata (e.g., priority, deadline, tags, etc.)
  tags?: any[]; // Tags for organizing the memory. Shorthand for metadata.tags.
  groupId?: string; // Group ID to scope the memory to a specific group. If omitted, memory is created in the user's personal graph.
}
export interface MemoryCreateTaskArgs {
  content: string; // Task description/title - what needs to be done. IMPORTANT: Write task content from a neutral perspective without possessive pronouns (his/her/their). The assignee will see this exact text, so "fold dresses" is correct, NOT "fold her dresses". Avoid phrases like "remind him to", "help her with", etc.
  assignedTo?: string; // Username of the person to assign this task to (group contexts only). System resolves username to user ID.
  dueAt?: string; // Due date/time in ISO 8601 format (e.g., "2024-01-15T10:00:00Z") or natural language that will be parsed
  priority?: string; // Task priority: "high", "medium", or "low"
  tags?: any[]; // Tags/labels for categorization (e.g., ["work", "urgent"])
}
export interface MemorySearchArgs {
  query: string; // Search query text for semantic matching
  types?: any[]; // Filter by entity types (e.g., ["TASK", "NOTE", "IDEA"])
  startTime?: number; // Filter entities created after this timestamp (Unix milliseconds)
  endTime?: number; // Filter entities created before this timestamp (Unix milliseconds)
  propertyFilters?: any; // Filter by entity properties: { status: ["completed"], tags: ["urgent"], priority: ["high"], roles: ["task"], contexts: ["work"] }
  limit?: number; // Maximum number of results (default: 50, max: 100)
}
export interface MemoryQueryArgs {
  type?: string; // Semantic type filter (e.g., "task", "note", "idea", "reminder", "contact", "document"). Matches against meta_item_type, subType, or semantic_roles
  filters?: any; // Additional filters (not yet implemented)
  limit?: number; // Maximum results (default: 50, max: 100)
  offset?: number; // Pagination offset for fetching more results (default: 0)
}
export interface MemoryFindOneArgs {
  filters: any; // Filter criteria. Use { id: "entity_id" } to find by ID (recommended), or { name: "entity name" } to find by name.
}
export interface MemoryUpdateArgs {
  id: string; // Entity ID to update
  type?: string; // Entity type
  content?: string; // Updated content
  metadata?: any; // Updated metadata
}
export interface MemoryDeleteArgs {
  id: string; // Entity ID to delete
}
export interface MemoryShareArgs {
  entityId: string; // Entity ID to share
  targetGraphId: string; // Target graph ID to share with (group ID or user contact graph ID)
  shareReason?: string; // Optional reason for sharing
}
export interface MemoryUnshareArgs {
  entityId: string; // Entity ID to unshare
  graphId: string; // Graph ID to remove sharing from
}
export interface MemoryListGraphsArgs {
  entityId: string; // Entity ID to list graphs for
}

// AI Services Adapter Types
export interface AiChatArgs {
  message?: string; // Simple string shorthand for single-turn queries. Auto-wrapped into messages array. Use "messages" for multi-turn conversations.
  messages?: any[]; // Array of message objects with role ("system" | "user" | "assistant") and content (string). System messages set AI behavior, user messages are queries, assistant messages are previous AI responses.
  model?: string; // Specific model to use. Default: "claude-3-haiku-20240307". Use Anthropic Claude model names.
  temperature?: number; // Creativity level 0.0-1.0. Lower=factual/consistent, Higher=creative/varied. Default: 0.7
  maxTokens?: number; // Maximum tokens in response. Default: 1000. Increase for longer responses (costs more tokens).
}
export interface AiDecideArgs {
  prompt: string; // The decision prompt - what needs to be decided and why
  options: any[]; // Array of options to choose from. Each option must have: id (unique identifier), label (descriptive name), and optional metadata (additional data)
  context?: string; // Additional context to help the AI make a better decision
  model?: string; // Specific model to use. Defaults to system default.
}

// Documents Adapter Types
export interface DocumentUploadArgs {
  file: string; // Base64 encoded file content
  filename: string; // Original filename with extension
  mimeType: string; // MIME type (application/pdf, text/plain, etc.)
  graphId?: string; // Target graph ID (defaults to user's personal graph)
  title?: string; // Custom document title
  productTags?: any[]; // Array of product tags for categorization
}
export interface DocumentGetArgs {
  documentId: string; // Document ID to retrieve
}
export interface DocumentGetStatusArgs {
  documentId: string; // Document ID to check
}
export interface DocumentGetChunksArgs {
  documentId: string; // Document ID
}
export interface DocumentDeleteArgs {
  documentId: string; // Document ID to delete
}
export interface DocumentShareArgs {
  documentId: string; // Document ID to share
  targetGraphId: string; // Target graph ID to share to
  shareReason?: string; // Optional reason for sharing
}
export interface DocumentUnshareArgs {
  documentId: string; // Document ID
  graphId: string; // Graph ID to remove access from
}
export interface DocumentListGraphsArgs {
  documentId: string; // Document ID
}
export interface DocumentSearchArgs {
  query: string; // Search query
  graphId?: string; // Graph ID to search in (defaults to user's graph)
  limit?: number; // Maximum results (default: 10)
  threshold?: number; // Similarity threshold 0-1 (default: 0.7)
}
export interface DocumentListArgs {
  graphId?: string; // Graph ID to list documents from (defaults to user's graph)
  limit?: number; // Maximum results (default: 50)
  offset?: number; // Pagination offset (default: 0)
}

// Feed Items Adapter Types
export interface FeedItemsCreateFeedItemArgs {
  title: string; // Main title of the feed item (shown prominently)
  subtitle?: string; // Optional subtitle (shown below title in muted color)
  blocks: any[]; // Array of content blocks to display (text, key_value, list, timestamp, user_mention, divider, image, progress)
  itemType: string; // Type: informative (FYI), actionable (needs response), or error
  actions?: any[]; // Optional action buttons for the feed item
  avatar?: any; // Optional avatar to show (user profile, icon, or custom image)
  metadata?: any; // Additional metadata (searchable, not displayed)
}

// Telegram Adapter Types
export interface TelegramSendMessageArgs {
  chatId: string; // Chat ID (numeric) or username (e.g., @username) to send the message to. Chat IDs can be obtained from searchChats operation.
  text: string; // The text content of the message to send
}
export interface TelegramSearchChatsArgs {
  query?: string; // Text to search in chat names/usernames. Supports fuzzy matching with relevance scoring.
  type?: string; // Filter by chat type: "private", "group", "channel", or "all" (default: "all")
  inactiveSince?: string; // Find chats with no activity since date. Accepts ISO date or relative like "30 days ago", "1 week ago"
  activeSince?: string; // Find chats with activity since date. Accepts ISO date or relative like "7 days ago"
  hasUnread?: boolean; // Filter by unread status: true = only unread, false = only read
  archived?: boolean; // Filter by archived status
  pinned?: boolean; // Filter by pinned status
  sortBy?: string; // Sort results: "relevance" (default with query), "lastActivity" (default without query), "unreadCount", "name"
  limit?: number; // Max results (default: 50, max: 100)
  offset?: number; // Pagination offset (default: 0)
  forceRefresh?: boolean; // Bypass cache and fetch fresh data
}
export interface TelegramSearchMessagesArgs {
  query: string; // Text query to search for in messages
  chatIds?: any[]; // Array of chat IDs to search within. Omit for global search across all chats.
  chatType?: string; // Filter by chat type (for global search): "private", "group", or "channel"
  fromDate?: string; // ISO date string for start of date range
  toDate?: string; // ISO date string for end of date range
  limit?: number; // Maximum number of messages to return (default: 100, max: 100)
  senderId?: string; // Filter messages by sender ID
}
export interface TelegramGetChatMessagesArgs {
  chatId: string; // Chat ID to retrieve messages from
  limit?: number; // Maximum number of messages to return (default: 50, max: 100)
  offsetId?: number; // Message ID to use as pagination offset
  minDate?: string; // ISO date string for minimum message date
  maxDate?: string; // ISO date string for maximum message date
}
export interface TelegramGetUnreadSummaryArgs {
  chatIds?: any[]; // Array of chat IDs to filter by. If not provided, checks all chats.
  priorityOnly?: boolean; // If true, only return chats with unread messages
  groupBy?: string; // Group results by "chat" or "sender"
}
export interface TelegramMarkAsReadArgs {
  chatId: string; // Chat ID to mark messages as read in
  maxMessageId?: number; // Maximum message ID to mark as read. If not provided, marks all messages as read.
}
export interface TelegramGetMentionsArgs {
  chatIds?: any[]; // Array of chat IDs to filter mentions by
  sinceDate?: string; // ISO date string - only return mentions since this date
  onlyUnread?: boolean; // If true, only return unread mentions
}
export interface TelegramLeaveGroupArgs {
  chatId: string; // The ID of the group, supergroup, or channel to leave. Can be obtained from searchChats operation.
}

// Gmail Adapter Types
export interface GoogleGmailSendEmailArgs {
  to: string; // Valid email address
  subject: string; // Email subject line
  body: string; // Email body content
  cc?: string; // CC recipients (comma-separated email addresses)
  bcc?: string; // BCC recipients (comma-separated email addresses)
  isHtml?: boolean; // Whether body is HTML format
}
export interface GoogleGmailSearchEmailsArgs {
  query: string; // Gmail search query (e.g., "from:user@example.com is:unread")
  maxResults?: number; // Maximum number of results to return (default: 50, max: 100)
}
export interface GoogleGmailListEmailsArgs {
  maxResults?: number; // Maximum number of results to return (default: 50, max: 100)
}
export interface GoogleGmailGetEmailArgs {
  messageId: string; // Gmail message ID
  includeHtml?: boolean; // Include HTML body content (default: false)
  includeAttachments?: boolean; // Include attachment metadata (default: false)
}
export interface GoogleGmailCreateDraftArgs {
  to: string; // Valid email address
  subject: string; // Email subject line
  body: string; // Email body content
  cc?: string; // CC recipients (comma-separated email addresses)
  bcc?: string; // BCC recipients (comma-separated email addresses)
  isHtml?: boolean; // Whether body is HTML format
}
export interface GoogleGmailUpdateDraftArgs {
  draftId: string; // Gmail draft ID to update
  to?: string; // Updated recipient email address(es)
  subject?: string; // Updated email subject line
  body?: string; // Updated email body content
  cc?: string; // Updated CC recipients
  bcc?: string; // Updated BCC recipients
  isHtml?: boolean; // Whether body is HTML format
}
export interface GoogleGmailDeleteDraftArgs {
  draftId: string; // Gmail draft ID to delete
}
export interface GoogleGmailListDraftsArgs {
  maxResults?: number; // Maximum number of drafts to return (default: 10)
}
export interface GoogleGmailDeleteEmailArgs {
  messageId: string; // Gmail message ID to delete
}
export interface GoogleGmailBulkDeleteEmailsArgs {
  messageIds: any[]; // Array of Gmail message IDs to delete (max 1000 per request)
  permanently?: boolean; // If true, permanently delete. If false (default), move to trash.
}

// Google Calendar Adapter Types
export interface GoogleCalendarCreateEventArgs {
  summary: string; // Event title/summary
  start: any; // Start time object with dateTime and optional timeZone
  end: any; // End time object with dateTime and optional timeZone
  description?: string; // Event description
  location?: string; // Event location
  attendees?: any[]; // Array of attendee email addresses
}
export interface GoogleCalendarListEventsArgs {
  timeMin?: string; // Start time for events to list (ISO 8601)
  timeMax?: string; // End time for events to list (ISO 8601)
  maxResults?: number; // Maximum number of events to return (default: 50, max: 100)
  query?: string; // Search query to filter events
}
export interface GoogleCalendarGetEventsArgs {
  timeMin?: string; // Start time for events to list (ISO 8601)
  timeMax?: string; // End time for events to list (ISO 8601)
  maxResults?: number; // Maximum number of events to return (default: 50, max: 100)
  query?: string; // Search query to filter events
}
export interface GoogleCalendarGetEventArgs {
  eventId: string; // Calendar event ID
}
export interface GoogleCalendarUpdateEventArgs {
  eventId: string; // Calendar event ID to update
  summary?: string; // Updated event title/summary
  description?: string; // Updated event description
  location?: string; // Updated event location
  start?: any; // Updated start time object with dateTime and optional timeZone
  end?: any; // Updated end time object with dateTime and optional timeZone
}
export interface GoogleCalendarDeleteEventArgs {
  eventId: string; // Calendar event ID to delete
}
export interface GoogleCalendarSearchEventsArgs {
  query: string; // Search query to filter events
  timeMin?: string; // Start time for events to search (ISO 8601)
  timeMax?: string; // End time for events to search (ISO 8601)
  maxResults?: number; // Maximum number of events to return (default: 50, max: 100)
}

// Google Drive Adapter Types
export interface GoogleDriveListFilesArgs {
  query?: string; // Search query (Google Drive query syntax)
  pageSize?: number; // Maximum number of files to return (default: 20)
}
export interface GoogleDriveCreateFileArgs {
  name: string; // Name of the file
  mimeType: string; // MIME type of the file
  folderId?: string; // Parent folder ID (optional)
}
export interface GoogleDriveCreateFolderArgs {
  name: string; // Name of the folder
  parentFolderId?: string; // Parent folder ID (optional)
}
export interface GoogleDriveGetFileInfoArgs {
  fileId: string; // ID of the file
}
export interface GoogleDriveShareFileArgs {
  fileId: string; // ID of the file to share
  email?: string; // Email address to share with (optional)
  role?: string; // Permission role: reader, writer, commenter (default: reader)
}
export interface GoogleDriveDownloadFileArgs {
  fileId: string; // ID of the file to download
}
export interface GoogleDriveMoveFileArgs {
  fileId: string; // ID of the file to move
  folderId: string; // ID of the destination folder
}
export interface GoogleDriveDeleteFileArgs {
  fileId: string; // ID of the file or folder to delete
  permanently?: boolean; // If true, permanently delete instead of moving to trash (default: false)
}
export interface GoogleDriveSearchFilesArgs {
  query: string; // Search query using Drive syntax (e.g., "name contains 'report'", "mimeType='application/pdf'")
  pageSize?: number; // Maximum number of files to return (default: 20)
}
export interface GoogleDriveUpdateFileArgs {
  fileId: string; // ID of the file to update
  name?: string; // New name for the file
  description?: string; // New description for the file
}

// Google Sheets Adapter Types
export interface GoogleSheetsCreateSpreadsheetArgs {
  title: string; // Title of the spreadsheet
}
export interface GoogleSheetsReadRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  range: string; // Cell range (e.g., "Sheet1!A1:B10")
}
export interface GoogleSheetsWriteRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  range: string; // Cell range (e.g., "Sheet1!A1:B10")
  values: any[]; // Data to write (2D array)
}
export interface GoogleSheetsAppendRowArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetName: string; // Name of the sheet
  values: any[]; // Row values to append
}
export interface GoogleSheetsGetSpreadsheetArgs {
  spreadsheetId: string; // ID of the spreadsheet
}
export interface GoogleSheetsInsertAtCellArgs {
  spreadsheetId: string; // ID of the spreadsheet
  cell: string; // Cell reference in format SheetName!A1
  value: string; // Value to insert
  bold?: boolean; // Make text bold
  italic?: boolean; // Make text italic
  foregroundColor?: string; // Text color (hex or named color)
  backgroundColor?: string; // Cell background color (hex or named color)
}
export interface GoogleSheetsInsertFormulaArgs {
  spreadsheetId: string; // ID of the spreadsheet
  cell: string; // Cell reference in format SheetName!A1
  formula: string; // Formula to insert (with or without leading =)
  note?: string; // Optional note to add to the cell
}
export interface GoogleSheetsFormatRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  range: string; // Range in format SheetName!A1:B10
  bold?: boolean; // Make text bold
  italic?: boolean; // Make text italic
  foregroundColor?: string; // Text color (hex or named color)
  backgroundColor?: string; // Cell background color (hex or named color)
  borders?: boolean; // Add borders to cells
}
export interface GoogleSheetsCreateChartArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // ID of the sheet containing data
  dataRange: string; // Data range for the chart (e.g., A1:B10)
  chartType: string; // Chart type: BAR, LINE, AREA, PIE, or SCATTER
  title: string; // Chart title
  position: any; // Chart position with row, column, rowCount, columnCount
}
export interface GoogleSheetsFindAndReplaceArgs {
  spreadsheetId: string; // ID of the spreadsheet
  findText: string; // Text to find
  replaceText: string; // Text to replace with
  sheetName?: string; // Limit search to specific sheet
  matchCase?: boolean; // Case-sensitive search
  matchEntireCell?: boolean; // Match entire cell content only
}
export interface GoogleSheetsInsertMultipleRowsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetName: string; // Name of the sheet
  rowsData: any[]; // 2D array of row data to insert
  startingRow?: number; // Row number to start insertion (1-indexed). If not provided, appends to end
  formattingOptions?: any; // Optional formatting to apply (bold, italic, foregroundColor, backgroundColor, borders)
}
export interface GoogleSheetsClearRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetName: string; // Name of the sheet
  range: string; // Range to clear (e.g., A1:B10)
}
export interface GoogleSheetsInsertRowsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
  startRowIndex: number; // Row index to start inserting at (0-indexed). To insert before row 5 in the UI, use index 4.
  numRows: number; // Number of rows to insert
}
export interface GoogleSheetsDeleteRowsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
  startRowIndex: number; // Row index to start deleting from (0-indexed). To delete row 5 in the UI, use index 4.
  numRows: number; // Number of rows to delete
}
export interface GoogleSheetsInsertColumnsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
  startColumnIndex: number; // Column index to start inserting at (0-indexed: A=0, B=1, C=2, D=3, etc.). To insert before column D, use index 3.
  numColumns: number; // Number of columns to insert
}
export interface GoogleSheetsDeleteColumnsArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sheetId: number; // Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
  startColumnIndex: number; // Column index to start deleting from (0-indexed: A=0, B=1, C=2, D=3, etc.). To delete column D, use index 3.
  numColumns: number; // Number of columns to delete
}
export interface GoogleSheetsCopyRangeArgs {
  spreadsheetId: string; // ID of the spreadsheet
  sourceSheetId: number; // Numeric sheet ID of the source sheet (get from getSpreadsheet response: sheets[n].properties.sheetId)
  sourceRange: string; // Source range in A1 notation WITHOUT sheet name (e.g., "A1:C5", not "Sheet1!A1:C5")
  targetSheetId: number; // Numeric sheet ID of the target sheet (can be same as sourceSheetId to copy within same sheet)
  targetStartCell: string; // Target start cell in A1 notation (e.g., "E1"). The copied data will fill cells starting from this position.
}

// Google Docs Adapter Types
export interface GoogleDocsCreateDocumentArgs {
  title: string; // Title of the document
}
export interface GoogleDocsGetDocumentArgs {
  documentId: string; // ID of the document
}
export interface GoogleDocsAppendTextArgs {
  documentId: string; // ID of the document
  text: string; // Text to append
}
export interface GoogleDocsReplaceTextArgs {
  documentId: string; // ID of the document
  searchText: string; // Text to search for
  replaceText: string; // Text to replace with
}
export interface GoogleDocsGetDocumentContentArgs {
  documentId: string; // ID of the document
}
export interface GoogleDocsInsertTextAtPositionArgs {
  documentId: string; // ID of the document
  text: string; // Text to insert
  position: number; // Character position to insert at (1-indexed)
}
export interface GoogleDocsInsertTextAfterArgs {
  documentId: string; // ID of the document
  searchText: string; // Text to search for
  textToInsert: string; // Text to insert after the search text
  occurrence?: number; // Which occurrence to insert after (default: 1)
}
export interface GoogleDocsInsertHeadingArgs {
  documentId: string; // ID of the document
  text: string; // Heading text
  level: number; // Heading level (1-6)
  position?: number; // Character position to insert at
  insertAfterText?: string; // Insert after this text instead of at position
}
export interface GoogleDocsInsertListArgs {
  documentId: string; // ID of the document
  items: any[]; // Array of list items
  listType: string; // Type of list: "bulleted" or "numbered"
  position?: number; // Character position to insert at
  insertAfterText?: string; // Insert after this text instead of at position
}
export interface GoogleDocsInsertTableArgs {
  documentId: string; // ID of the document
  data: any[]; // 2D array of table data (rows x columns)
  hasHeader?: boolean; // Whether the first row is a header (default: true)
  position?: number; // Character position to insert at
  insertAfterText?: string; // Insert after this text instead of at position
}
export interface GoogleDocsUpdateDocumentContentArgs {
  documentId: string; // ID of the document
  newContent: string; // New content to replace existing content
}
export interface GoogleDocsCreateSectionArgs {
  documentId: string; // ID of the document
  heading: string; // Section heading text
  content: string; // Section content text
}
export interface GoogleDocsFindInsertionPointArgs {
  documentId: string; // ID of the document
  position: number; // Position to find (1 for start, -1 for end)
  searchText?: string; // Text to search for (returns position after this text)
}

// Jira Adapter Types
export interface JiraCreateIssueArgs {
  projectKey: string; // Jira project key (e.g., "PROJ")
  summary: string; // Issue summary/title
  description?: string; // Issue description
  issueType?: string; // Issue type (Task, Bug, Story, etc.)
}
export interface JiraSearchIssuesArgs {
  jql: string; // JQL query string
  maxResults?: number; // Maximum number of results (default: 50, max: 100)
}
export interface JiraGetIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123") or ID
}
export interface JiraUpdateIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
  summary?: string; // New issue summary/title
  description?: string; // New issue description
}
export interface JiraDeleteIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
}
export interface JiraAddCommentArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
  comment: string; // Comment text
}
export interface JiraTransitionIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
  transitionId: string; // ID of the transition to perform
}
export interface JiraAssignIssueArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
  accountId: string; // Atlassian account ID of the assignee
}
export interface JiraGetProjectMetadataArgs {
  projectKey: string; // Project key (e.g., "PROJ")
}
export interface JiraGetTransitionsArgs {
  issueKey: string; // Issue key (e.g., "PROJ-123")
}
export interface JiraListAssignableUsersArgs {
  projectKey: string; // Project key (e.g., "PROJ")
}
export interface JiraGetIssueTypesArgs {
  projectKey: string; // Project key (e.g., "PROJ")
}
export interface JiraDiscoverExtendedArgs {
  query: string; // Describe what you want to do (e.g., "add label to card")
  limit?: number; // Max results to return (default 5)
}
export interface JiraExecuteExtendedArgs {
  operationId: string; // The operationId from discoverExtended results
  pathParams?: any; // Path parameters, e.g., { id: "abc123" }
  queryParams?: any; // Query string parameters
  body?: any; // Request body for POST/PUT/PATCH operations
}

// Twitter Adapter Types
export interface TwitterPostTweetArgs {
  text: string; // Tweet text (max 280 characters)
}
export interface TwitterGetUserTweetsArgs {
  userId?: string; // Twitter user ID (recommended for stability and speed). Provide userId OR userName, not both.
  userName?: string; // Twitter username/handle without @ symbol (e.g., "elonmusk"). Provide userName OR userId, not both.
  cursor?: string; // Pagination cursor from previous response's nextCursor field. Do not fabricate cursor values.
  includeReplies?: boolean; // Whether to include replies in results. Defaults to false (only original tweets).
}
export interface TwitterAdvancedSearchArgs {
  query: string; // Search query with advanced syntax. Examples: "from:elonmusk", "bitcoin since:2024-01-01", "AI OR \"machine learning\"". Supported operators: from:user, to:user, since:YYYY-MM-DD, until:YYYY-MM-DD, lang:xx, filter:media, filter:links, -filter:retweets, AND, OR, -keyword, "exact phrase".
  queryType?: string; // Type of search results: "Latest" (most recent) or "Top" (most relevant). Defaults to "Latest". Only these two values are valid.
  cursor?: string; // Pagination cursor from previous response's nextCursor field. Do not fabricate cursor values.
}

// Trello Adapter Types
export interface TrelloGetBoardArgs {
  boardId: string; // The ID of the board to retrieve
}
export interface TrelloCreateCardArgs {
  name: string; // Card name/title
  idList: string; // ID of the list to add the card to
  desc?: string; // Card description (supports markdown)
  description?: string; // Card description (alias for "desc", supports markdown)
}
export interface TrelloGetCardArgs {
  cardId: string; // The ID of the card to retrieve
}
export interface TrelloUpdateCardArgs {
  cardId: string; // The ID of the card to update
  name?: string; // New card name
  desc?: string; // New card description
  description?: string; // New card description (alias for "desc", supports markdown)
  idList?: string; // Move card to a different list
  closed?: boolean; // Archive the card
}
export interface TrelloDeleteCardArgs {
  cardId: string; // The ID of the card to delete
}
export interface TrelloCreateChecklistArgs {
  cardId: string; // The ID of the card to add the checklist to
  name: string; // Checklist name
}
export interface TrelloGetChecklistArgs {
  checklistId: string; // The ID of the checklist to retrieve
}
export interface TrelloUpdateChecklistArgs {
  checklistId: string; // The ID of the checklist to update
  name: string; // New checklist name
}
export interface TrelloDeleteChecklistArgs {
  checklistId: string; // The ID of the checklist to delete
}
export interface TrelloAddCheckItemArgs {
  checklistId: string; // The ID of the checklist to add the item to
  name: string; // Check item text
}
export interface TrelloUpdateCheckItemArgs {
  cardId: string; // The ID of the card containing the check item
  checkItemId: string; // The ID of the check item to update
  name?: string; // New check item text
  state?: string; // Check state: "complete" or "incomplete"
}
export interface TrelloDeleteCheckItemArgs {
  checklistId: string; // The ID of the checklist containing the item
  checkItemId: string; // The ID of the check item to delete
}
export interface TrelloDiscoverExtendedArgs {
  query: string; // Describe what you want to do (e.g., "add label to card")
  limit?: number; // Max results to return (default 5)
}
export interface TrelloExecuteExtendedArgs {
  operationId: string; // The operationId from discoverExtended results
  pathParams?: any; // Path parameters, e.g., { id: "abc123" }
  queryParams?: any; // Query string parameters
  body?: any; // Request body for POST/PUT/PATCH operations
}

// Jupiter Adapter Types
export interface JupiterSwapArgs {
  inputMint: string; // Input token mint address
  outputMint: string; // Output token mint address
  amount: number; // Amount to swap (in smallest unit)
  inputDecimals?: number; // Number of decimals for input token. Auto-resolved from Jupiter token registry if not provided.
  slippageBps?: number; // Slippage tolerance in basis points (default: 50)
}
export interface JupiterGetHoldingsArgs {
  walletAddress?: string; // Wallet address to check (uses actor wallet if not provided)
}
export interface JupiterGetTokenSecurityArgs {
  tokenMint: string; // Token mint address to check security for
}
export interface JupiterSearchTokensArgs {
  query: string; // Search query (symbol, name, or mint address)
}
export interface JupiterRefreshSwapArgs {
  feedItemId: string; // Feed item ID containing the swap to refresh
  swapId: string; // Original swap ID
  inputMint: string; // Input token mint address
  outputMint: string; // Output token mint address
  amount: number; // Amount to swap (in UI units)
  inputDecimals: number; // Input token decimals
  slippageBps?: number; // Slippage tolerance in basis points
}
export interface JupiterLaunchTokenArgs {
  tokenName: string; // Name of the token
  tokenSymbol: string; // Token ticker symbol
  tokenDescription?: string; // Description for the token metadata
  tokenImageUrl: string; // URL of the uploaded token image (from user message)
  quoteMint?: string; // Quote token mint address. Defaults to USDC (EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v). Can also use SOL or JUP mint.
  initialMarketCap?: number; // Initial market cap in quote token units (default: 16000 for meme preset)
  migrationMarketCap?: number; // Market cap threshold for graduation/migration (default: 69000 for meme preset)
  antiSniping?: boolean; // Enable anti-sniping protection (default: false)
  feeBps?: number; // Creator trading fee in basis points: 100 (1%) or 200 (2%). Default: 100
  isLpLocked?: boolean; // Lock LP tokens (default: true)
  website?: string; // Project website URL for token metadata
  twitter?: string; // Twitter/X URL for token metadata
  telegram?: string; // Telegram URL for token metadata
}

// Crypto Adapter Types
export interface CryptoGetPriceArgs {
  tokenAddress: string; // Token contract address (EVM: 0x..., SVM: base58)
  chainName?: string; // Specific chain name (auto-detected if not provided)
}
export interface CryptoSendTokenArgs {
  recipient: string; // Contact username, user ID, or Solana wallet address
  token: string; // Token symbol (SOL, USDC), name, or mint address
  amount: number; // Amount to send (in UI units)
}
export interface CryptoMonitorPriceArgs {
  tokenAddress: string; // Token contract address to monitor
  direction: string; // Alert direction: "above" or "below"
  targetPrice: number; // Target price in USD to trigger alert
  scriptId: string; // ID of the script to execute when price target is reached
  chainName?: string; // Chain name (auto-detected if not provided)
  percentStep?: number; // Progressive alert step percentage (default: 0.1 = 10%)
}
export interface CryptoUnsubscribeAssetArgs {
  tokenAddress: string; // Token address to stop monitoring
}
export interface CryptoRefreshTransactionArgs {
  feedItemId: string; // Feed item ID containing the transaction to refresh
  transferId: string; // Original transfer ID
  recipient: string; // Recipient address
  token: string; // Token symbol or mint address
  amount: number; // Amount to send
  tokenMint?: string; // Token mint address (optional, will resolve if not provided)
  tokenDecimals?: number; // Token decimals (optional)
}

// Scripts Adapter Types
export interface ScriptsCreateScriptArgs {
  name: string; // Name of the script
  description?: string; // Description of what the script does
  runtime?: string; // Lambda runtime (default: nodejs18)
  config?: any; // Script configuration (timeout, memory, maxCostPerExecution, etc.)
  code: string; // Initial JavaScript/TypeScript code for the script
}
export interface ScriptsDeleteScriptArgs {
  scriptId: string; // ID of the script to delete
}
export interface ScriptsCreateVersionArgs {
  scriptId: string; // ID of the script
  code: string; // Updated code for the new version
  commitMessage?: string; // Description of changes in this version
}
export interface ScriptsListVersionsArgs {
  scriptId: string; // ID of the script
}
export interface ScriptsDeployScriptArgs {
  scriptId: string; // ID of the script to deploy (from createScript response at data._id)
  version?: number; // Version number to deploy (default: latest)
}
export interface ScriptsExecuteScriptArgs {
  scriptId: string; // ID of the script to execute (from createScript response at data.id)
  data?: any; // Input data to pass to the script
  trigger?: any; // Trigger information (type, source, event)
}
export interface ScriptsGetScriptArgs {
  scriptId: string; // ID of the script
}
export interface ScriptsGetExecutionsArgs {
  scriptId: string; // ID of the script
  status?: string; // Filter by status (completed, failed, running)
  limit?: number; // Maximum number of executions to return (default: 100)
}
export interface ScriptsGetExecutionArgs {
  executionId: string; // ID of the execution
}
export interface ScriptsPublishScriptArgs {
  scriptId: string; // ID of the script to publish
  pricing?: any; // Pricing configuration for the marketplace
}
export interface ScriptsUnpublishScriptArgs {
  scriptId: string; // ID of the script to unpublish
}
export interface ScriptsListMarketplaceScriptsArgs {
  name?: string; // Exact match on script name
  system?: boolean; // Filter by system scripts (scope="system") when true, user scripts when false
  search?: string; // Text search on name and description
  tags?: any[]; // Filter by tags (matches scripts with any of the specified tags)
  category?: string; // Filter by UI category (notification, data_sync, automation, utility, reporting)
  pricingModel?: string; // Filter by pricing model (free, pay-per-execution, subscription)
  staffPick?: boolean; // Filter to only staff-picked scripts when true
  minRating?: number; // Minimum rating threshold (0-5)
  requiredIntegrations?: any[]; // Filter by required integrations (e.g., ["telegram", "gmail"])
  sortBy?: string; // Sort field: rating, installCount, trendingScore, publishedAt, name (default: rating)
  sortOrder?: string; // Sort order: asc or desc (default: desc)
  limit?: number; // Maximum number of results to return (default: 50, max: 100)
  offset?: number; // Number of results to skip for pagination (default: 0)
}
export interface ScriptsGetMetricsArgs {
  scriptId: string; // ID of the script
}
export interface ScriptsCreateWebhookArgs {
  scriptId: string; // ID of the script
  name: string; // Name of the webhook
  enabled?: boolean; // Whether webhook is enabled (default: true)
}
export interface ScriptsCreateScheduleArgs {
  scriptId: string; // ID of the script
  name: string; // Name of the schedule
  cronExpression: string; // Cron expression (e.g., "0 9 * * *" for daily at 9am)
  enabled?: boolean; // Whether schedule is enabled (default: true)
  data?: any; // Data to pass to the script on scheduled execution
}
export interface ScriptsGetFlowScriptArgs {
  flowId: string; // ID of the flow to get script code for
}
export interface ScriptsModifyFlowScriptArgs {
  flowId: string; // ID of the flow to modify
  newCode: string; // New code to deploy
  commitMessage?: string; // Description of changes
}
export interface ScriptsLintScriptArgs {
  code: string; // The script code to validate
  eventType?: string; // Event type for event.data field validation (e.g., "telegram.message", "call.ended"). When provided, validates that event.data.fieldName accesses match the event type schema.
  scriptInputSchema?: any; // Schema of scriptInput fields that will be on event.data at runtime. Keys are field names, values are { type: "string"|"number"|"boolean"|"object"|"array" }. When provided, event.data field errors are reported as errors instead of warnings.
}

// Feedback Adapter Types
export interface FeedbackReportBugArgs {
  title: string; // Brief bug description
  description: string; // Detailed description of the bug
  severity: string; // Bug severity: critical, high, medium, or low
  stepsToReproduce?: any[]; // Steps to reproduce the bug
  expectedBehavior?: string; // What should happen
  actualBehavior?: string; // What actually happens
  errorDetails?: any; // Error details: { message, stack, code }
  context?: any; // Additional context: { conversationId, recentMessages, platform, appVersion }
  llmAnalysis?: string; // LLM analysis of the issue
}
export interface FeedbackReportToolFailureArgs {
  adapterType: string; // Adapter type (e.g., jupiter, crypto)
  operation: string; // Operation that failed (e.g., swap, sendToken)
  errorMessage: string; // Error message from the failure
  errorCode?: string; // Error code if available
  errorStack?: string; // Error stack trace
  args?: any; // Sanitized arguments that caused the failure
  llmAnalysis?: string; // LLM analysis of why it failed
  suggestedFix?: string; // LLM suggested fix
  context?: any; // Additional context: { conversationId, userId, timestamp }
}
export interface FeedbackReportMissingCapabilityArgs {
  userRequest: string; // What the user asked for
  reason: string; // Why it could not be fulfilled
  suggestedCapability?: string; // What capability would enable this
  relatedAdapters?: any[]; // Adapters that might be relevant
  context?: any; // Additional context: { conversationId }
}
export interface FeedbackSubmitFeedbackArgs {
  sentiment: string; // Sentiment: positive, negative, or neutral
  feedback: string; // Feedback content
  category?: string; // Category: ux, performance, feature, or general
  context?: any; // Additional context: { feature, screen }
}
export interface FeedbackSubmitFeatureRequestArgs {
  title: string; // Feature title
  description: string; // Feature description
  useCase?: string; // Why the user needs this feature
  priority?: string; // Priority: high, medium, or low
}

// Mirra Messaging Adapter Types
export interface MirraMessagingSendMessageArgs {
  groupId: string; // Group ID to send the message to (use getContacts or getGroups to get the groupId)
  content: string; // Message text content
  replyToMessageId?: string; // ID of the message to reply to (creates a threaded reply)
  automation?: any; // Automation metadata: { source: string, flowId?: string, flowTitle?: string, sessionId?: string, isAutomated?: boolean }. Use sessionId to group related messages and enable Flow-based reply routing.
  structuredData?: any[]; // Structured data for rich UI rendering: [{ displayType, templateId, data, metadata?, interactions? }]
}
export interface MirraMessagingUpdateMessageArgs {
  messageId: string; // ID of the message to update
  content: string; // New message text content
  structuredData?: any[]; // Updated structured data for rich UI rendering
}
export interface MirraMessagingGetContactsArgs {
  limit?: number; // Maximum number of contacts to return (default 50)
  offset?: number; // Offset for pagination (default 0)
}
export interface MirraMessagingFindContactArgs {
  query: string; // Username or name to search for
}
export interface MirraMessagingGetChatsArgs {
  scope?: string; // Filter by scope: direct, user, group, or all (default all)
  limit?: number; // Maximum number of chats to return (default 50)
}
export interface MirraMessagingGetGroupsArgs {
  limit?: number; // Maximum number of groups to return (default 50)
}
export interface MirraMessagingCreateGroupArgs {
  name: string; // Group name (max 100 characters)
  description?: string; // Group description (max 500 characters)
  category?: string; // Category for organization: "family", "friends", "work", or "other" (default: "other")
  memberIds?: any[]; // Array of user IDs to add as initial members
}
export interface MirraMessagingSearchMessagesArgs {
  query: string; // Keywords to search for
  contactName?: string; // Contact name to filter by sender (resolved to userId)
  groupName?: string; // Group name to limit search (resolved to groupId)
  groupId?: string; // Group ID to limit search (use groupName for name-based lookup)
  scope?: string; // "direct", "group", or "all" (default)
  startDate?: string; // ISO date for time range start
  endDate?: string; // ISO date for time range end
  includeFullText?: boolean; // Include full message text (default: false, returns snippets)
  snippetLength?: number; // Max chars for snippet (default: 200)
  limit?: number; // Max results (default 20, max 50)
  offset?: number; // Pagination offset
}

// Moltbook Adapter Types
export interface MoltbookRegisterAgentArgs {
  agentName: string; // Unique name for your agent (alphanumeric, underscores allowed)
}
export interface MoltbookCreatePostArgs {
  content: string; // Post content/body text
  title?: string; // Post title (optional)
  type?: string; // Post type: "text" or "link" (default: text)
  url?: string; // URL for link posts
  submolt?: string; // Community name to post in (optional)
}
export interface MoltbookGetPostsArgs {
  sort?: string; // Sort order: "hot", "new", "top", "rising" (default: hot)
  limit?: number; // Max posts to return (default: 25, max: 100)
  submolt?: string; // Filter by community name
}
export interface MoltbookGetPostArgs {
  postId: string; // Post ID
}
export interface MoltbookDeletePostArgs {
  postId: string; // Post ID to delete
}
export interface MoltbookCreateCommentArgs {
  postId: string; // Post ID to comment on
  content: string; // Comment content
  parentId?: string; // Parent comment ID for replies
}
export interface MoltbookGetCommentsArgs {
  postId: string; // Post ID
  sort?: string; // Sort: "top", "new", "controversial" (default: top)
}
export interface MoltbookUpvotePostArgs {
  postId: string; // Post ID to upvote
}
export interface MoltbookDownvotePostArgs {
  postId: string; // Post ID to downvote
}
export interface MoltbookUpvoteCommentArgs {
  commentId: string; // Comment ID to upvote
}
export interface MoltbookCreateSubmoltArgs {
  name: string; // Community name (alphanumeric, underscores)
  description: string; // Community description
}
export interface MoltbookGetSubmoltArgs {
  name: string; // Community name
}
export interface MoltbookSubscribeArgs {
  name: string; // Community name to subscribe to
}
export interface MoltbookUnsubscribeArgs {
  name: string; // Community name to unsubscribe from
}
export interface MoltbookFollowAgentArgs {
  agentName: string; // Agent name to follow
}
export interface MoltbookUnfollowAgentArgs {
  agentName: string; // Agent name to unfollow
}
export interface MoltbookGetProfileArgs {
  agentName: string; // Agent name
}
export interface MoltbookUpdateProfileArgs {
  description?: string; // New profile description
  metadata?: any; // Additional metadata
}
export interface MoltbookGetFeedArgs {
  limit?: number; // Max posts to return (default: 25, max: 100)
}
export interface MoltbookSearchArgs {
  query: string; // Search query
}

// Tunnel Adapter Types
export interface TunnelCallArgs {
  tunnel?: string; // Tunnel name to use (defaults to 'default')
  method?: string; // HTTP method (defaults to GET)
  path: string; // Request path (e.g., /api/query)
  headers?: any; // Request headers
  body?: any; // Request body (for POST/PUT/PATCH)
}
export interface TunnelStatusArgs {
  tunnel?: string; // Tunnel name to check (defaults to 'default')
}

// Polymarket Adapter Types
export interface PolymarketGetMarketsArgs {
  query?: string; // Search query to filter markets by question text (matched against slug)
  tag?: string; // Filter by category tag (e.g., "politics", "crypto", "sports", "science")
  limit?: number; // Maximum number of markets to return (default: 25, max: 100)
  offset?: number; // Offset for pagination (default: 0)
  active?: boolean; // If true, return only active/open markets
  closed?: boolean; // If true, return only closed/resolved markets
}
export interface PolymarketGetMarketArgs {
  conditionId?: string; // The condition ID of the market (hex string, e.g., "0xabc123...")
  slug?: string; // The market slug (URL-friendly name, alternative to conditionId)
}
export interface PolymarketGetEventsArgs {
  tag?: string; // Filter by category tag (e.g., "politics", "crypto", "sports")
  limit?: number; // Maximum number of events to return (default: 25, max: 100)
  offset?: number; // Offset for pagination (default: 0)
  active?: boolean; // If true, return only active events
  closed?: boolean; // If true, return only closed/resolved events
}
export interface PolymarketGetPriceArgs {
  tokenId: string; // The token ID of the outcome to price (available from market.outcomes or market data)
  side?: string; // Price side: "BUY" or "SELL". Defaults to "BUY".
}
export interface PolymarketGetOrderbookArgs {
  tokenId: string; // The token ID of the outcome (available from market data)
}
export interface PolymarketPlaceOrderArgs {
  tokenId: string; // The token ID of the outcome to trade (from market data)
  price: number; // Order price between 0.01 and 0.99 (implied probability)
  size: number; // Order size in number of shares (denominated in USDC)
  side: string; // Order side: "BUY" to buy outcome shares, "SELL" to sell held shares
  type?: string; // Order type: "GTC" (Good Til Cancelled, default), "GTD" (Good Til Date), "FOK" (Fill Or Kill), "FAK" (Fill And Kill)
  expiration?: number; // Unix timestamp expiration for GTD orders only
  marketQuestion?: string; // Human-readable market question (e.g. "Will Bitcoin reach $100k?"). Pass this from getMarkets results so the order card shows the market name instead of a numeric token ID.
}
export interface PolymarketExecuteOrderArgs {
  orderPayload: any; // The order payload from placeOrder: { tokenId, price, size, side, type, expiration }
}
export interface PolymarketCancelOrderArgs {
  orderId: string; // The ID of the order to cancel (from getOrders or placeOrder result)
}
export interface PolymarketExecuteCancelOrderArgs {
  orderId: string; // The ID of the order to cancel
}
export interface PolymarketRefreshOrderArgs {
  tokenId: string; // The token ID of the outcome to trade
  price: number; // Order price between 0.01 and 0.99
  size: number; // Order size in number of shares
  side: string; // Order side: "BUY" or "SELL"
  type?: string; // Order type: "GTC" (default), "GTD", "FOK", "FAK"
  expiration?: number; // Unix timestamp expiration for GTD orders
}
export interface PolymarketGetOrdersArgs {
  market?: string; // Filter by market condition ID to see orders for a specific market
  limit?: number; // Maximum number of orders to return (default: 25, max: 100)
  offset?: number; // Offset for pagination (default: 0)
}
export interface PolymarketGetTradesArgs {
  market?: string; // Filter by market condition ID
  limit?: number; // Maximum number of trades to return (default: 25, max: 100)
  offset?: number; // Offset for pagination (default: 0)
}
export interface PolymarketGetBuilderLeaderboardArgs {
  period?: string; // Time period for rankings: "daily", "weekly", "monthly", or omit for all-time
  limit?: number; // Maximum number of entries to return (default: 25, max: 100)
}
export interface PolymarketGetBuilderVolumeArgs {
  startDate?: string; // Start date in ISO 8601 format (e.g., "2024-06-01")
  endDate?: string; // End date in ISO 8601 format (e.g., "2024-06-30")
}
export interface PolymarketDiscoverExtendedArgs {
  query: string; // Describe what you want to do (e.g., "add label to card")
  limit?: number; // Max results to return (default 5)
}
export interface PolymarketExecuteExtendedArgs {
  operationId: string; // The operationId from discoverExtended results
  pathParams?: any; // Path parameters, e.g., { id: "abc123" }
  queryParams?: any; // Query string parameters
  body?: any; // Request body for POST/PUT/PATCH operations
}

// Hypertrade Adapter Types
export interface HypertradePlaceOrderArgs {
  asset: string; // Asset/coin symbol (e.g. "ETH", "BTC")
  isBuy: boolean; // True for long/buy, false for short/sell
  size: number; // Order size in asset units
  limitPrice?: number; // Limit price (required for limit orders)
  orderType?: string; // Order type: "limit" or "market" (default: "market")
  triggerPrice?: number; // Trigger price for stop/take-profit orders
  reduceOnly?: boolean; // Whether order can only reduce position (default: false)
  postOnly?: boolean; // Whether order should only be maker (default: false)
  clientOrderId?: string; // Custom client order ID for tracking
}
export interface HypertradeCancelOrderArgs {
  asset: string; // Asset/coin symbol (e.g. "ETH", "BTC")
  orderId?: number; // Order ID to cancel
  clientOrderId?: string; // Client order ID to cancel
  cancelAll?: boolean; // Cancel all orders for this asset (default: false)
}
export interface HypertradeGetPositionsArgs {
  walletAddress?: string; // EVM wallet address (uses context wallet if not provided)
}
export interface HypertradeGetOpenOrdersArgs {
  walletAddress?: string; // EVM wallet address (uses context wallet if not provided)
  asset?: string; // Filter by asset/coin symbol
}
export interface HypertradeGetBalancesArgs {
  walletAddress?: string; // EVM wallet address (uses context wallet if not provided)
}
export interface HypertradeGetMarketInfoArgs {
  asset?: string; // Specific asset/coin symbol to get info for (returns all if omitted)
}
export interface HypertradeGetOrderbookArgs {
  asset: string; // Asset/coin symbol (e.g. "ETH", "BTC")
  depth?: number; // Number of levels to return (default: all)
}
export interface HypertradeGetCandlesArgs {
  asset: string; // Asset/coin symbol (e.g. "ETH", "BTC")
  interval?: string; // Candle interval (e.g. "1m", "5m", "1h", "1d"). Default: "1h"
  startTime?: number; // Start time in milliseconds (default: 24h ago)
  endTime?: number; // End time in milliseconds (default: now)
  limit?: number; // Max number of candles to return
}
export interface HypertradeSetLeverageArgs {
  asset: string; // Asset/coin symbol (e.g. "ETH", "BTC")
  leverage: number; // Leverage multiplier (e.g. 5 for 5x)
  isCrossMargin?: boolean; // Use cross margin (default: true). False for isolated margin.
}
export interface HypertradeGetTradeHistoryArgs {
  walletAddress?: string; // EVM wallet address (uses context wallet if not provided)
  asset?: string; // Filter by asset/coin symbol
  limit?: number; // Max number of trades to return
}

// Desktop Adapter Types
export interface DesktopExecuteCommandArgs {
  command: string; // Shell command to execute (e.g., "ls -la ~/Documents")
  cwd?: string; // Working directory for the command (defaults to user home)
  timeoutMs?: number; // Timeout in milliseconds (defaults to 120000)
}
export interface DesktopReadFileArgs {
  path: string; // Absolute path to the file to read
  maxBytes?: number; // Maximum bytes to read (defaults to 1048576 = 1 MB)
}
export interface DesktopWriteFileArgs {
  path: string; // Absolute path to the file to write
  content: string; // Text content to write to the file
  append?: boolean; // If true, append to existing file instead of overwriting (defaults to false)
}
export interface DesktopListDirectoryArgs {
  path: string; // Absolute path to the directory to list
  recursive?: boolean; // If true, list recursively (max depth 3). Defaults to false.
  includeHidden?: boolean; // If true, include hidden files (starting with .). Defaults to false.
}
export interface DesktopSpawnProcessArgs {
  command: string; // Path to the executable to run (e.g., "node", "python3", "/usr/local/bin/my-app")
  args?: any[]; // Command-line arguments to pass to the process
  env?: any; // Additional environment variables to set for the process
  cwd?: string; // Working directory for the process (defaults to system default)
}
export interface DesktopKillProcessArgs {
  processId: string; // The process ID returned by spawnProcess
}

// Shopify Adapter Types
export interface ShopifyListProductsArgs {
  limit?: number; // Number of products to return per page (1-250). Defaults to 50.
  pageInfo?: string; // Cursor for pagination. Use the nextPageInfo value from a previous response to get the next page.
  status?: string; // Filter by product status: "active", "archived", or "draft".
  vendor?: string; // Filter by product vendor name.
  productType?: string; // Filter by product type.
  collectionId?: string; // Filter by collection ID to list products in a specific collection.
}
export interface ShopifyGetProductArgs {
  productId: string; // The Shopify product ID.
}
export interface ShopifyCreateProductArgs {
  title: string; // The product title.
  bodyHtml?: string; // HTML description of the product.
  vendor?: string; // The product vendor.
  productType?: string; // The product type for categorization.
  tags?: string; // Comma-separated list of tags.
  status?: string; // Product status: "active", "archived", or "draft". Defaults to "active".
  variants?: any[]; // Array of variant objects with price, sku, option1/option2/option3, inventory_quantity, weight, weight_unit, barcode, requires_shipping, taxable.
  images?: any[]; // Array of image objects with src (URL) and optional alt text.
}
export interface ShopifyUpdateProductArgs {
  productId: string; // The Shopify product ID to update.
  title?: string; // New product title.
  bodyHtml?: string; // New HTML description.
  vendor?: string; // New vendor name.
  productType?: string; // New product type.
  tags?: string; // New comma-separated tags (replaces existing tags).
  status?: string; // New status: "active", "archived", or "draft".
}
export interface ShopifyDeleteProductArgs {
  productId: string; // The Shopify product ID to delete.
}
export interface ShopifyListOrdersArgs {
  limit?: number; // Number of orders to return per page (1-250). Defaults to 50.
  pageInfo?: string; // Cursor for pagination from a previous response.
  status?: string; // Filter by order status: "open", "closed", "cancelled", or "any". Defaults to "any".
  financialStatus?: string; // Filter by financial status: "authorized", "pending", "paid", "partially_paid", "refunded", "voided", "partially_refunded", "any", "unpaid".
  fulfillmentStatus?: string; // Filter by fulfillment status: "shipped", "partial", "unshipped", "any", "unfulfilled".
  sinceId?: string; // Return orders after this order ID.
  createdAtMin?: string; // Return orders created after this date (ISO 8601 format).
  createdAtMax?: string; // Return orders created before this date (ISO 8601 format).
}
export interface ShopifyGetOrderArgs {
  orderId: string; // The Shopify order ID.
}
export interface ShopifyCreateOrderArgs {
  lineItems: any[]; // Array of line items. Each item needs either variant_id or title+price+quantity. Example: [{ variant_id: "123", quantity: 2 }] or [{ title: "Custom Item", price: "10.00", quantity: 1 }].
  email?: string; // Customer email address for the order.
  note?: string; // An optional note attached to the order.
  tags?: string; // Comma-separated tags for the order.
  financialStatus?: string; // Financial status: "pending", "authorized", "partially_paid", "paid", "partially_refunded", "refunded", "voided". Defaults to "pending".
  shippingAddress?: any; // Shipping address object with first_name, last_name, address1, address2, city, province, country, zip, phone.
  customerId?: string; // Associate the order with an existing customer by their Shopify customer ID.
}
export interface ShopifyCancelOrderArgs {
  orderId: string; // The Shopify order ID to cancel.
  reason?: string; // Cancellation reason: "customer", "fraud", "inventory", "declined", or "other".
  email?: boolean; // Whether to send a cancellation email to the customer. Defaults to true.
}
export interface ShopifyCloseOrderArgs {
  orderId: string; // The Shopify order ID to close.
}
export interface ShopifyListCustomersArgs {
  limit?: number; // Number of customers to return per page (1-250). Defaults to 50.
  pageInfo?: string; // Cursor for pagination from a previous response.
  sinceId?: string; // Return customers after this customer ID.
  createdAtMin?: string; // Return customers created after this date (ISO 8601 format).
  createdAtMax?: string; // Return customers created before this date (ISO 8601 format).
}
export interface ShopifyGetCustomerArgs {
  customerId: string; // The Shopify customer ID.
}
export interface ShopifyCreateCustomerArgs {
  firstName?: string; // Customer first name.
  lastName?: string; // Customer last name.
  email?: string; // Customer email address. Required if phone is not provided.
  phone?: string; // Customer phone number in E.164 format. Required if email is not provided.
  tags?: string; // Comma-separated tags for the customer.
  note?: string; // A note about the customer.
  addresses?: any[]; // Array of address objects with address1, city, province, country, zip, phone.
}
export interface ShopifyUpdateCustomerArgs {
  customerId: string; // The Shopify customer ID to update.
  firstName?: string; // New first name.
  lastName?: string; // New last name.
  email?: string; // New email address.
  phone?: string; // New phone number in E.164 format.
  tags?: string; // New comma-separated tags (replaces existing).
  note?: string; // New note about the customer.
}
export interface ShopifySearchCustomersArgs {
  query: string; // Search query string. Examples: "email:john@example.com", "first_name:John", or freeform text like "john doe".
  limit?: number; // Number of results to return (1-250). Defaults to 50.
}
export interface ShopifyGetInventoryLevelsArgs {
  inventoryItemIds?: string; // Comma-separated list of inventory item IDs to query.
  locationIds?: string; // Comma-separated list of location IDs to query.
  limit?: number; // Number of results to return (1-250). Defaults to 50.
}
export interface ShopifyAdjustInventoryArgs {
  inventoryItemId: string; // The inventory item ID to adjust.
  locationId: string; // The location ID where the inventory is stored.
  adjustment: number; // The quantity adjustment. Positive to add stock, negative to remove.
}
export interface ShopifyListCollectionsArgs {
  limit?: number; // Maximum number of collections to return per type (1-250). Defaults to 50. Note: up to this many custom collections AND this many smart collections may be returned.
  pageInfo?: string; // Cursor for pagination from a previous response.
}
export interface ShopifyListPagesArgs {
  limit?: number; // Number of pages per page, 1-250, default 50
  pageInfo?: string; // Cursor for pagination
}
export interface ShopifyGetPageArgs {
  pageId: string; // The Shopify page ID.
}
export interface ShopifyCreatePageArgs {
  title: string; // The page title.
  bodyHtml?: string; // HTML body content of the page.
  author?: string; // The author of the page.
  templateSuffix?: string; // The template suffix for the page.
  published?: boolean; // Whether the page is published. Defaults to true.
}
export interface ShopifyUpdatePageArgs {
  pageId: string; // The Shopify page ID to update.
  title?: string; // New page title.
  bodyHtml?: string; // New HTML body content.
  author?: string; // New author name.
  templateSuffix?: string; // New template suffix.
  published?: boolean; // Whether the page is published.
}
export interface ShopifyDeletePageArgs {
  pageId: string; // The Shopify page ID to delete.
}
export interface ShopifyListBlogsArgs {
  limit?: number; // Number of blogs per page, 1-250, default 50
  pageInfo?: string; // Cursor for pagination
}
export interface ShopifyGetBlogArgs {
  blogId: string; // The Shopify blog ID.
}
export interface ShopifyCreateBlogArgs {
  title: string; // The blog title.
  commentable?: string; // Comment policy: no, moderate, yes
}
export interface ShopifyUpdateBlogArgs {
  blogId: string; // The Shopify blog ID to update.
  title?: string; // New blog title.
  commentable?: string; // New comment policy: no, moderate, yes
}
export interface ShopifyDeleteBlogArgs {
  blogId: string; // The Shopify blog ID to delete.
}
export interface ShopifyListArticlesArgs {
  blogId: string; // The blog ID to list articles from.
  limit?: number; // Number of articles per page, 1-250, default 50
  pageInfo?: string; // Cursor for pagination
}
export interface ShopifyGetArticleArgs {
  articleId: string; // The Shopify article ID.
}
export interface ShopifyCreateArticleArgs {
  blogId: string; // The blog ID to create the article in.
  title: string; // The article title.
  author?: string; // The article author.
  bodyHtml?: string; // HTML body content of the article.
  summary?: string; // Summary or excerpt of the article.
  tags?: string; // Comma-separated list of tags.
  published?: boolean; // Whether the article is published.
  imageUrl?: string; // URL of the article featured image.
  imageAlt?: string; // Alt text for the article featured image.
}
export interface ShopifyUpdateArticleArgs {
  articleId: string; // The Shopify article ID to update.
  title?: string; // New article title.
  author?: string; // New author name.
  bodyHtml?: string; // New HTML body content.
  summary?: string; // New summary or excerpt.
  tags?: string; // New comma-separated tags.
  published?: boolean; // Whether the article is published.
}
export interface ShopifyDeleteArticleArgs {
  articleId: string; // The Shopify article ID to delete.
}
export interface ShopifyGetThemeArgs {
  themeId: string; // The Shopify theme ID.
}
export interface ShopifyPublishThemeArgs {
  themeId: string; // The Shopify theme ID to publish.
}
export interface ShopifyListThemeFilesArgs {
  themeId: string; // The Shopify theme ID.
  filenames?: string; // Comma-separated glob patterns like templates/*.json
}
export interface ShopifyGetThemeFileArgs {
  themeId: string; // The Shopify theme ID.
  filename: string; // The filename/path of the theme file (e.g., "templates/index.json").
}
export interface ShopifyUpsertThemeFilesArgs {
  themeId: string; // The Shopify theme ID.
  files: any[]; // Array of {filename, body} objects
}
export interface ShopifyDeleteThemeFilesArgs {
  themeId: string; // The Shopify theme ID.
  filenames: any[]; // Array of filenames to delete
}
export interface ShopifyListMenusArgs {
  limit?: number; // Number of menus per page, 1-250, default 50
  pageInfo?: string; // Cursor for pagination
}
export interface ShopifyGetMenuArgs {
  menuId: string; // The Shopify menu ID.
}
export interface ShopifyCreateMenuArgs {
  title: string; // The menu title.
  handle?: string; // The menu handle (URL-friendly identifier).
  items?: any[]; // Array of menu item objects with title, url, type, resourceId
}
export interface ShopifyUpdateMenuArgs {
  menuId: string; // The Shopify menu ID to update.
  title?: string; // New menu title.
  handle?: string; // New menu handle.
  items?: any[]; // New array of menu item objects with title, url, type, resourceId
}
export interface ShopifyDeleteMenuArgs {
  menuId: string; // The Shopify menu ID to delete.
}
export interface ShopifyListRedirectsArgs {
  limit?: number; // Number of redirects per page, 1-250, default 50
  pageInfo?: string; // Cursor for pagination
}
export interface ShopifyCreateRedirectArgs {
  path: string; // The old path to redirect from
  target: string; // The new URL to redirect to
}
export interface ShopifyUpdateRedirectArgs {
  redirectId: string; // The Shopify redirect ID to update.
  path?: string; // New path to redirect from.
  target?: string; // New URL to redirect to.
}
export interface ShopifyDeleteRedirectArgs {
  redirectId: string; // The Shopify redirect ID to delete.
}

// Data Adapter Types
export interface DataDefineCollectionArgs {
  name: string; // Human-readable name for the collection (e.g. "Contacts", "Sales Metrics")
  slug?: string; // URL-safe identifier (lowercase, underscores). Auto-generated from name if omitted.
  fields: any[]; // Array of field definitions. Each field has: name (string), type ("string"|"number"|"boolean"|"date"|"array"|"object"), required (boolean), description (optional string).
  description?: string; // Optional description of what this collection stores
}
export interface DataListCollectionsArgs {
  status?: string; // Filter by status: "active" (default) or "archived"
}
export interface DataGetCollectionArgs {
  slug: string; // The collection slug (e.g. "contacts")
}
export interface DataUpdateCollectionArgs {
  slug: string; // The collection slug to update
  addFields?: any[]; // New fields to add to the collection
  removeFields?: any[]; // Field names to remove from the collection
  description?: string; // New description for the collection
}
export interface DataDropCollectionArgs {
  slug: string; // The collection slug to drop
}
export interface DataInsertRecordArgs {
  collection: string; // The collection slug to insert into
  data: any; // The record data -- keys must match the collection fields
}
export interface DataInsertRecordsArgs {
  collection: string; // The collection slug to insert into
  records: any[]; // Array of record data objects to insert
}
export interface DataQueryRecordsArgs {
  collection: string; // The collection slug to query
  filter?: any; // MongoDB-style filter object. Supports $eq, $ne, $gt, $gte, $lt, $lte, $in, $regex. Filter keys are automatically prefixed with "data." so use field names directly.
  sort?: any; // Sort object, e.g. { revenue: -1 } for descending. Keys are auto-prefixed with "data.".
  limit?: number; // Max records to return (default 50, max 200)
  offset?: number; // Number of records to skip (for pagination)
}
export interface DataUpdateRecordArgs {
  collection: string; // The collection slug
  recordId: string; // The record _id to update
  data: any; // Partial record data to merge/update
}
export interface DataDeleteRecordArgs {
  collection: string; // The collection slug
  recordId: string; // The record _id to delete
}
export interface DataAggregateArgs {
  collection: string; // The collection slug
  groupBy?: string; // Field name to group by. Omit for overall aggregation.
  metrics: any[]; // Array of { field, op } where op is one of "sum", "avg", "count", "min", "max". For "count", field can be omitted.
}

// Pages Adapter Types
export interface PagesCreatePageArgs {
  path: string; // URL path for the page (e.g. "/dashboard"). Must start with /, lowercase alphanumeric and hyphens only, 2-50 chars.
  title: string; // Display title for the page
  code: string; // JSX source code. Must define a top-level function App() component. Do NOT use import/require — React, ReactDOM, Recharts (BarChart, PieChart, LineChart, ResponsiveContainer, etc.), lucide-react, and Tailwind CSS are all pre-loaded globals.
  description?: string; // Optional description of the page
  visibility?: string; // Page visibility: "private" (default) or "public"
}
export interface PagesEditPageArgs {
  pageId: string; // The page ID to edit
  edits: any[]; // Array of search-and-replace edits. Each edit has oldCode (exact string to find) and newCode (replacement string). Applied sequentially.
}
export interface PagesUpdatePageArgs {
  pageId: string; // The page ID to update
  code?: string; // New JSX source code
  title?: string; // New title
  description?: string; // New description
}
export interface PagesRevertPageArgs {
  pageId: string; // The page ID to revert
  versionIndex: number; // Index of the version to restore (0 = most recent saved version)
}
export interface PagesGetPageArgs {
  pageId?: string; // The page ID
  path?: string; // The page path (e.g. "/dashboard"). Used with the current graphId.
}
export interface PagesListPagesArgs {
  status?: string; // Filter by status: "active" (default) or "deleted"
}
export interface PagesDeletePageArgs {
  pageId: string; // The page ID to delete
}
export interface PagesPublishPageArgs {
  pageId: string; // The page ID to publish
  publicCollections?: any[]; // Optional array of collection tags for public discovery
}
export interface PagesUnpublishPageArgs {
  pageId: string; // The page ID to unpublish
}
export interface PagesGetPageUrlArgs {
  pageId: string; // The page ID
}


// ============================================================================
// Response Type Definitions
// ============================================================================

// Flows Response Types
export interface FlowsCreateFlowData {
  id: string; // Flow ID
  title: string; // Flow title
  description: string; // Truncated description
  status: string; // Flow status (active, paused, completed, failed)
  userId: string; // Owner user ID
  triggerType: string; // Trigger type (time or event)
  cronExpression: string; // Cron expression for time-based flows
  scriptId: string; // Associated script ID
  executionCount: number; // Number of executions
  lastExecutedAt: string; // Last execution timestamp (ISO 8601)
  createdAt: string; // Created timestamp (ISO 8601)
  isActive: boolean; // Whether flow is active
  scope: string; // Flow scope (user or system)
  timezone: string; // Timezone for time-based flows
  eventFilter?: object; // Event filter for event-based flows
  scriptInstallationId: string; // Script installation ID
  scriptInput?: object; // Script input data
  updatedAt: string; // Updated timestamp (ISO 8601)
  version: number; // Flow version number
  feedItemId: string; // Associated feed item ID
  isTimeBased: boolean; // Whether flow is time-based
  isEventBased: boolean; // Whether flow is event-based
}

export type FlowsCreateFlowResult = AdapterResultBase<FlowsCreateFlowData>;

export interface FlowsCreateTimeFlowData {
  id: string; // Flow ID
  title: string; // Flow title
  description: string; // Truncated description
  status: string; // Flow status (active, paused, completed, failed)
  userId: string; // Owner user ID
  triggerType: string; // Trigger type (time or event)
  cronExpression: string; // Cron expression for time-based flows
  scriptId: string; // Associated script ID
  executionCount: number; // Number of executions
  lastExecutedAt: string; // Last execution timestamp (ISO 8601)
  createdAt: string; // Created timestamp (ISO 8601)
  isActive: boolean; // Whether flow is active
  scope: string; // Flow scope (user or system)
  timezone: string; // Timezone for time-based flows
  eventFilter?: object; // Event filter for event-based flows
  scriptInstallationId: string; // Script installation ID
  scriptInput?: object; // Script input data
  updatedAt: string; // Updated timestamp (ISO 8601)
  version: number; // Flow version number
  feedItemId: string; // Associated feed item ID
  isTimeBased: boolean; // Whether flow is time-based
  isEventBased: boolean; // Whether flow is event-based
}

export type FlowsCreateTimeFlowResult = AdapterResultBase<FlowsCreateTimeFlowData>;

export interface FlowsCreateEventFlowData {
  id: string; // Flow ID
  title: string; // Flow title
  description: string; // Truncated description
  status: string; // Flow status (active, paused, completed, failed)
  userId: string; // Owner user ID
  triggerType: string; // Trigger type (time or event)
  cronExpression: string; // Cron expression for time-based flows
  scriptId: string; // Associated script ID
  executionCount: number; // Number of executions
  lastExecutedAt: string; // Last execution timestamp (ISO 8601)
  createdAt: string; // Created timestamp (ISO 8601)
  isActive: boolean; // Whether flow is active
  scope: string; // Flow scope (user or system)
  timezone: string; // Timezone for time-based flows
  eventFilter?: object; // Event filter for event-based flows
  scriptInstallationId: string; // Script installation ID
  scriptInput?: object; // Script input data
  updatedAt: string; // Updated timestamp (ISO 8601)
  version: number; // Flow version number
  feedItemId: string; // Associated feed item ID
  isTimeBased: boolean; // Whether flow is time-based
  isEventBased: boolean; // Whether flow is event-based
}

export type FlowsCreateEventFlowResult = AdapterResultBase<FlowsCreateEventFlowData>;

export interface FlowsGetFlowData {
  id: string; // Flow ID
  title: string; // Flow title
  description: string; // Truncated description
  status: string; // Flow status (active, paused, completed, failed)
  userId: string; // Owner user ID
  triggerType: string; // Trigger type (time or event)
  cronExpression: string; // Cron expression for time-based flows
  scriptId: string; // Associated script ID
  executionCount: number; // Number of executions
  lastExecutedAt: string; // Last execution timestamp (ISO 8601)
  createdAt: string; // Created timestamp (ISO 8601)
  isActive: boolean; // Whether flow is active
  scope: string; // Flow scope (user or system)
  timezone: string; // Timezone for time-based flows
  eventFilter?: object; // Event filter for event-based flows
  scriptInstallationId: string; // Script installation ID
  scriptInput?: object; // Script input data
  updatedAt: string; // Updated timestamp (ISO 8601)
  version: number; // Flow version number
  feedItemId: string; // Associated feed item ID
  isTimeBased: boolean; // Whether flow is time-based
  isEventBased: boolean; // Whether flow is event-based
}

export type FlowsGetFlowResult = AdapterResultBase<FlowsGetFlowData>;

export interface FlowsUpdateFlowData {
  id: string; // Flow ID
  title: string; // Flow title
  description: string; // Truncated description
  status: string; // Flow status (active, paused, completed, failed)
  userId: string; // Owner user ID
  triggerType: string; // Trigger type (time or event)
  cronExpression: string; // Cron expression for time-based flows
  scriptId: string; // Associated script ID
  executionCount: number; // Number of executions
  lastExecutedAt: string; // Last execution timestamp (ISO 8601)
  createdAt: string; // Created timestamp (ISO 8601)
  isActive: boolean; // Whether flow is active
  scope: string; // Flow scope (user or system)
  timezone: string; // Timezone for time-based flows
  eventFilter?: object; // Event filter for event-based flows
  scriptInstallationId: string; // Script installation ID
  scriptInput?: object; // Script input data
  updatedAt: string; // Updated timestamp (ISO 8601)
  version: number; // Flow version number
  feedItemId: string; // Associated feed item ID
  isTimeBased: boolean; // Whether flow is time-based
  isEventBased: boolean; // Whether flow is event-based
}

export type FlowsUpdateFlowResult = AdapterResultBase<FlowsUpdateFlowData>;

export interface FlowsDeleteFlowData {
  flowId: string; // Deleted flow ID
  deleted: boolean; // Whether deletion succeeded
}

export type FlowsDeleteFlowResult = AdapterResultBase<FlowsDeleteFlowData>;

export interface FlowsPauseFlowData {
  id: string; // Flow ID
  title: string; // Flow title
  description: string; // Truncated description
  status: string; // Flow status (active, paused, completed, failed)
  userId: string; // Owner user ID
  triggerType: string; // Trigger type (time or event)
  cronExpression: string; // Cron expression for time-based flows
  scriptId: string; // Associated script ID
  executionCount: number; // Number of executions
  lastExecutedAt: string; // Last execution timestamp (ISO 8601)
  createdAt: string; // Created timestamp (ISO 8601)
  isActive: boolean; // Whether flow is active
  scope: string; // Flow scope (user or system)
  timezone: string; // Timezone for time-based flows
  eventFilter?: object; // Event filter for event-based flows
  scriptInstallationId: string; // Script installation ID
  scriptInput?: object; // Script input data
  updatedAt: string; // Updated timestamp (ISO 8601)
  version: number; // Flow version number
  feedItemId: string; // Associated feed item ID
  isTimeBased: boolean; // Whether flow is time-based
  isEventBased: boolean; // Whether flow is event-based
}

export type FlowsPauseFlowResult = AdapterResultBase<FlowsPauseFlowData>;

export interface FlowsResumeFlowData {
  id: string; // Flow ID
  title: string; // Flow title
  description: string; // Truncated description
  status: string; // Flow status (active, paused, completed, failed)
  userId: string; // Owner user ID
  triggerType: string; // Trigger type (time or event)
  cronExpression: string; // Cron expression for time-based flows
  scriptId: string; // Associated script ID
  executionCount: number; // Number of executions
  lastExecutedAt: string; // Last execution timestamp (ISO 8601)
  createdAt: string; // Created timestamp (ISO 8601)
  isActive: boolean; // Whether flow is active
  scope: string; // Flow scope (user or system)
  timezone: string; // Timezone for time-based flows
  eventFilter?: object; // Event filter for event-based flows
  scriptInstallationId: string; // Script installation ID
  scriptInput?: object; // Script input data
  updatedAt: string; // Updated timestamp (ISO 8601)
  version: number; // Flow version number
  feedItemId: string; // Associated feed item ID
  isTimeBased: boolean; // Whether flow is time-based
  isEventBased: boolean; // Whether flow is event-based
}

export type FlowsResumeFlowResult = AdapterResultBase<FlowsResumeFlowData>;

export interface FlowsRecordExecutionData {
  id: string; // Flow ID
  title: string; // Flow title
  description: string; // Truncated description
  status: string; // Flow status (active, paused, completed, failed)
  userId: string; // Owner user ID
  triggerType: string; // Trigger type (time or event)
  cronExpression: string; // Cron expression for time-based flows
  scriptId: string; // Associated script ID
  executionCount: number; // Number of executions
  lastExecutedAt: string; // Last execution timestamp (ISO 8601)
  createdAt: string; // Created timestamp (ISO 8601)
  isActive: boolean; // Whether flow is active
  scope: string; // Flow scope (user or system)
  timezone: string; // Timezone for time-based flows
  eventFilter?: object; // Event filter for event-based flows
  scriptInstallationId: string; // Script installation ID
  scriptInput?: object; // Script input data
  updatedAt: string; // Updated timestamp (ISO 8601)
  version: number; // Flow version number
  feedItemId: string; // Associated feed item ID
  isTimeBased: boolean; // Whether flow is time-based
  isEventBased: boolean; // Whether flow is event-based
}

export type FlowsRecordExecutionResult = AdapterResultBase<FlowsRecordExecutionData>;

export interface FlowSummary {
  id: string; // Flow ID
  title: string; // Flow title
  description: string; // Truncated description
  status: string; // Flow status (active, paused, completed, failed)
  userId: string; // Owner user ID
  triggerType: string; // Trigger type (time or event)
  cronExpression: string; // Cron expression for time-based flows
  scriptId: string; // Associated script ID
  executionCount: number; // Number of executions
  lastExecutedAt: string; // Last execution timestamp (ISO 8601)
  createdAt: string; // Created timestamp (ISO 8601)
  isActive: boolean; // Whether flow is active
}

export interface FlowsListFlowsData {
  count: number; // Number of flows
  flows: FlowSummary[]; // List of flows
}

export type FlowsListFlowsResult = AdapterResultBase<FlowsListFlowsData>;

export interface FlowsSearchFlowsData {
  count: number; // Number of matching flows
  flows: FlowSummary[]; // List of matching flows
}

export type FlowsSearchFlowsResult = AdapterResultBase<FlowsSearchFlowsData>;

export interface FlowsGetFlowsByEventTypeData {
  eventType: string; // Queried event type
  count: number; // Number of flows
  flows: FlowSummary[]; // List of flows for event type
}

export type FlowsGetFlowsByEventTypeResult = AdapterResultBase<FlowsGetFlowsByEventTypeData>;

export interface EventType {
  constant: string; // Event type constant name
  eventType: string; // Full event type string
  source: string; // Event source/category
  description: string; // Event description
  hasTemplates: boolean; // Whether templates are available
}

export interface FlowsListEventTypesData {
  count: number; // Number of event types
  eventTypes: EventType[]; // List of event types
}

export type FlowsListEventTypesResult = AdapterResultBase<FlowsListEventTypesData>;

export interface ConditionResult {
  field: string; // Field name
  operator: string; // Operator used
  expected: string; // Expected value (stringified)
  actual: string; // Actual value (stringified)
  passed: boolean; // Whether condition passed
}

export interface TestEvent {
  id: string; // Test event ID
  type: string; // Event type
  source: string; // Event source
  summary: string; // Human-readable summary
}

export interface FlowsTestFlowData {
  success: boolean; // Overall test success
  flowId: string; // Tested flow ID
  mode: string; // Test mode (dryRun or fullExecution)
  triggerMatched: boolean; // Whether trigger conditions matched
  conditionResults: ConditionResult[]; // Individual condition results
  testEvent: TestEvent; // Generated test event info
  executionId: string; // Execution ID (if executed)
  executionStatus: string; // Execution status (success, error, timeout)
  executionDuration: number; // Execution duration in ms
  executionError: string; // Error message if failed
  tokensConsumed: number; // Tokens consumed
  recommendations: string[]; // Actionable recommendations
}

export type FlowsTestFlowResult = AdapterResultBase<FlowsTestFlowData>;

export interface FlowsValidateTriggerData {
  flowId: string; // Flow ID
  matched: boolean; // Whether trigger matched
  conditionResults: ConditionResult[]; // Individual condition results
}

export type FlowsValidateTriggerResult = AdapterResultBase<FlowsValidateTriggerData>;

export interface FlowsCreateBatchOperationData {
  flowId: string; // Created batch flow ID
  title: string; // Batch operation title
  operationCount: number; // Total operations to process
  batchSize: number; // Operations per execution
  intervalSeconds: number; // Seconds between batches
  estimatedCompletionMinutes: number; // Estimated completion time
  message: string; // Confirmation message
  createdAt: string; // Created timestamp (ISO 8601)
}

export type FlowsCreateBatchOperationResult = AdapterResultBase<FlowsCreateBatchOperationData>;

export interface FlowsPublishFlowData {
  flowId: string; // Published flow ID
  isPublished: boolean; // Whether flow is published
  status: string; // Published status
  publishedAt: string; // Published timestamp (ISO 8601)
  pricing: object; // Pricing configuration
  category: string; // Marketplace category
  tags: string[]; // Marketplace tags
}

export type FlowsPublishFlowResult = AdapterResultBase<FlowsPublishFlowData>;

export interface FlowsUnpublishFlowData {
  flowId: string; // Unpublished flow ID
  isPublished: boolean; // Whether flow is published (false)
  status: string; // Published status (archived)
}

export type FlowsUnpublishFlowResult = AdapterResultBase<FlowsUnpublishFlowData>;

// Memory Response Types
export interface MemoryCreateData {
  id: string; // Entity ID
  type: string; // Entity type
  name: string; // Entity name/title
  content: string; // Full entity content
  status: string; // Entity status
  priority: string; // Entity priority
  graphId: string; // Graph ID
  createdAt: string; // Created timestamp (ISO 8601)
  updatedAt: string; // Updated timestamp (ISO 8601)
  createdByUserId: string; // Creator user ID
  createdByName: string; // Creator username
  assignedToUserId: string; // Assigned user ID
  assignedToName: string; // Assigned username
  dueAt: string; // Due date (ISO 8601)
  tags: string[]; // Tags array
}

export type MemoryCreateResult = AdapterResultBase<MemoryCreateData>;

export interface MemoryCreateTaskData {
  id: string; // Task ID
  type: string; // Always "task"
  content: string; // Task content/description
  status: string; // Task status (pending, completed)
  priority: string; // Task priority (high, medium, low)
  graphId: string; // Graph ID where task resides
  createdAt: string; // Created timestamp (ISO 8601)
  createdByUserId: string; // Creator user ID
  createdByName: string; // Creator username
  assignedToUserId: string; // Assigned user ID
  assignedToName: string; // Assigned username
  assignmentWarning: string; // Warning if assignment had issues
  dueAt: string; // Due date (ISO 8601)
  tags: string[]; // Tags array
}

export type MemoryCreateTaskResult = AdapterResultBase<MemoryCreateTaskData>;

export interface MemoryEntitySummary {
  id: string; // Entity ID
  type: string; // Entity type (task, note, idea, etc.)
  name: string; // Entity name/title
  description: string; // Truncated content preview
  status: string; // Entity status
  priority: string; // Entity priority
  graphId: string; // Graph ID where entity resides
  createdAt: string; // Created timestamp (ISO 8601)
  score?: number; // Relevance score (0-1)
}

export interface MemorySearchData {
  query: string; // Search query used
  count: number; // Number of results
  results: MemoryEntitySummary[]; // Search results
}

export type MemorySearchResult = AdapterResultBase<MemorySearchData>;

export interface MemoryQueryData {
  type: string; // Type filter used or "all"
  count: number; // Number of results
  offset: number; // Pagination offset
  limit: number; // Pagination limit
  entities: MemoryEntitySummary[]; // Query results
}

export type MemoryQueryResult = AdapterResultBase<MemoryQueryData>;

export interface MemoryFindOneData {
  id: string; // Entity ID
  type: string; // Entity type
  name: string; // Entity name/title
  content: string; // Full entity content
  status: string; // Entity status
  priority: string; // Entity priority
  graphId: string; // Graph ID
  createdAt: string; // Created timestamp (ISO 8601)
  updatedAt: string; // Updated timestamp (ISO 8601)
  createdByUserId: string; // Creator user ID
  createdByName: string; // Creator username
  assignedToUserId: string; // Assigned user ID
  assignedToName: string; // Assigned username
  dueAt: string; // Due date (ISO 8601)
  tags: string[]; // Tags array
}

export type MemoryFindOneResult = AdapterResultBase<MemoryFindOneData>;

export interface MemoryUpdateData {
  id: string; // Updated entity ID
  updated: boolean; // Whether update succeeded
  updatedAt: string; // Update timestamp (ISO 8601)
}

export type MemoryUpdateResult = AdapterResultBase<MemoryUpdateData>;

export interface MemoryDeleteData {
  id: string; // Deleted entity ID
  deleted: boolean; // Whether deletion succeeded
  deletedAt: string; // Deletion timestamp (ISO 8601)
}

export type MemoryDeleteResult = AdapterResultBase<MemoryDeleteData>;

export interface MemoryShareData {
  entityId: string; // Shared entity ID
  success: boolean; // Whether share succeeded
  message: string; // Status message
  graphIds: string[]; // All graphs entity is shared with
  targetGraphId: string; // Target graph ID
  sharedAt: string; // Share timestamp (ISO 8601)
}

export type MemoryShareResult = AdapterResultBase<MemoryShareData>;

export interface MemoryUnshareData {
  entityId: string; // Unshared entity ID
  success: boolean; // Whether unshare succeeded
  message: string; // Status message
  graphIds: string[]; // Remaining graphs
  removedGraphId: string; // Removed graph ID
}

export type MemoryUnshareResult = AdapterResultBase<MemoryUnshareData>;

export interface MemoryGraphInfo {
  graphId: string; // Graph ID
  graphType: string; // Graph type: personal, group, user_contact
  graphName: string; // Graph display name
  isPrimary: boolean; // Whether this is the primary graph
  sharedAt: string; // Share timestamp (ISO 8601)
  sharedByUserId: string; // User who shared
}

export interface MemoryListGraphsData {
  entityId: string; // Entity ID
  primaryGraphId: string; // Primary graph ID
  totalGraphs: number; // Total graph count
  graphs: MemoryGraphInfo[]; // Graph information
}

export type MemoryListGraphsResult = AdapterResultBase<MemoryListGraphsData>;

export interface MemoryTaskCompletionData {
  period: string; // Time period (day, week, month)
  completed: number; // Completed task count
  total: number; // Total task count
  rate: number; // Completion rate percentage (0-100)
}

export type MemoryGetTaskCompletionResult = AdapterResultBase<MemoryTaskCompletionData>;

export interface MemoryReminder {
  id: string; // Reminder ID
  title: string; // Reminder title
  type: string; // Reminder type
  dueAt: string; // Due date (ISO 8601)
  daysUntilDue: number; // Days until due
}

export interface MemoryUpcomingRemindersData {
  days: number; // Days lookahead
  count: number; // Reminder count
  reminders: MemoryReminder[]; // Upcoming reminders
}

export type MemoryGetUpcomingRemindersResult = AdapterResultBase<MemoryUpcomingRemindersData>;

export interface MemoryStatsData {
  period: string; // Time period analyzed
  total: number; // Total memory count
  taskCount: number; // Task count
  noteCount: number; // Note count
  ideaCount: number; // Idea count
  completedCount: number; // Completed items count
  pendingCount: number; // Pending items count
}

export type MemoryGetMemoryStatsResult = AdapterResultBase<MemoryStatsData>;

// AI Services Response Types
export interface AIChatData {
  content: string; // AI response text content
  model: string; // Model used for generation
  inputTokens: number; // Number of input tokens consumed
  outputTokens: number; // Number of output tokens generated
  totalTokens: number; // Total tokens (input + output)
}

export type AiChatResult = AdapterResultBase<AIChatData>;

export interface AIDecideData {
  selectedOption: string; // ID of the selected option
  reasoning: string; // Explanation of why this option was chosen
}

export type AiDecideResult = AdapterResultBase<AIDecideData>;

// Documents Response Types
export interface DocumentUploadData {
  documentId: string; // Created document ID
  chunkCount: number; // Number of chunks created
  graphIds: string[]; // Array of graph IDs
  primaryGraphId: string; // Primary/owner graph ID
  processingTimeMs: number; // Processing time in milliseconds
}

export type DocumentUploadResult = AdapterResultBase<DocumentUploadData>;

export interface DocumentChunk {
  chunkId: string; // Unique chunk ID
  documentId: string; // Parent document ID
  content: string; // Chunk text content
  position: number; // Position/order in document
}

export interface DocumentGetData {
  documentId: string; // Document ID
  title: string; // Document title
  filename: string; // Original filename
  mimeType: string; // MIME type
  fileSize: number; // File size in bytes
  processingStatus: string; // Processing status
  chunkCount: number; // Number of chunks
  graphIds: string[]; // Graph IDs document is in
  primaryGraphId: string; // Primary graph ID
  createdAt: number; // Creation timestamp
  createdByUserId: string; // Creator user ID
  hasMultipleGraphs: boolean; // Whether shared to multiple graphs
  chunks: DocumentChunk[]; // Document chunks
}

export type DocumentGetResult = AdapterResultBase<DocumentGetData>;

export interface DocumentGetStatusData {
  documentId: string; // Document ID
  processingStatus: string; // Status: processing, completed, failed
  processingError: string | null; // Error message if failed
  chunkCount: number; // Number of chunks
  extractedAt: number | null; // Text extraction timestamp
  processingCompletedAt: number | null; // Processing completion timestamp
}

export type DocumentGetStatusResult = AdapterResultBase<DocumentGetStatusData>;

export interface DocumentGetChunksData {
  documentId: string; // Document ID
  count: number; // Number of chunks
  chunks: DocumentChunk[]; // Document chunks
}

export type DocumentGetChunksResult = AdapterResultBase<DocumentGetChunksData>;

export interface DocumentDeleteData {
  documentId: string; // Deleted document ID
  deleted: boolean; // Whether deletion succeeded
  chunksDeleted: number; // Number of chunks deleted
}

export type DocumentDeleteResult = AdapterResultBase<DocumentDeleteData>;

export interface DocumentShareData {
  documentId: string; // Document ID
  graphIds: string[]; // Updated graph IDs
  sharedToGraphId: string; // Target graph ID
  sharedByUserId: string; // User who shared
  sharedAt: number; // Share timestamp
}

export type DocumentShareResult = AdapterResultBase<DocumentShareData>;

export interface DocumentUnshareData {
  documentId: string; // Document ID
  graphIds: string[]; // Updated graph IDs
  removedGraphId: string; // Removed graph ID
}

export type DocumentUnshareResult = AdapterResultBase<DocumentUnshareData>;

export interface DocumentGraphInfo {
  graphId: string; // Graph ID
  isPrimary: boolean; // Whether this is the primary/original graph
  sharedAt: number; // Unix timestamp when shared
  sharedByUserId: string | null; // User ID who shared (null for primary)
  shareReason: string | null; // Reason for sharing (if provided)
}

export interface DocumentListGraphsData {
  documentId: string; // Document ID
  count: number; // Number of graphs
  graphs: DocumentGraphInfo[]; // Graph information
}

export type DocumentListGraphsResult = AdapterResultBase<DocumentListGraphsData>;

export interface DocumentSearchResultItem {
  chunkId: string; // Unique chunk ID
  documentId: string; // Parent document ID
  content: string; // Chunk text content
  position: number; // Position/order in document
  score: number; // Similarity score 0-1
}

export interface DocumentSearchData {
  graphId: string; // Searched graph ID
  count: number; // Number of results
  results: DocumentSearchResultItem[]; // Search results
}

export type DocumentSearchResult = AdapterResultBase<DocumentSearchData>;

export interface DocumentSummary {
  documentId: string; // Unique document ID
  title: string; // Document title
  filename: string; // Original filename
  mimeType: string; // MIME type of document
  fileSize: number; // File size in bytes
  processingStatus: string; // Processing status: processing, completed, failed
  chunkCount: number; // Number of chunks document was split into
  graphIds: string[]; // Array of graph IDs document is shared in
  createdAt: number; // Unix timestamp of creation
  createdByUserId: string; // User ID who created document
}

export interface DocumentListData {
  graphId: string; // Listed graph ID
  count: number; // Number of documents
  documents: DocumentSummary[]; // Document summaries
}

export type DocumentListResult = AdapterResultBase<DocumentListData>;

// Feed Items Response Types
export interface FeedItemCreateData {
  feedItemId: string; // Unique ID of the created feed item
  title: string; // Title of the feed item
  itemType: 'informative' | 'actionable' | 'error'; // Type of feed item
  subType: string; // Subtype of the feed item
  status: string; // Status of the feed item (pending, completed)
  graphId: string; // Graph ID where feed item was created
  createdAt: string; // Creation timestamp (ISO 8601)
  hasActions: boolean; // Whether feed item has action buttons
  blockCount: number; // Number of content blocks
}

export type FeedItemsCreateFeedItemResult = AdapterResultBase<FeedItemCreateData>;

// Telegram Response Types
export interface TelegramSendMessageData {
  messageId: number; // ID of the sent message
  chatId: string; // Chat ID where message was sent
  text: string; // Message text that was sent
  sentAt: string; // ISO 8601 timestamp when sent
}

export type TelegramSendMessageResult = AdapterResultBase<TelegramSendMessageData>;

export interface TelegramChat {
  id: string; // Chat ID
  title: string; // Chat title/name
  type: 'private' | 'group' | 'channel'; // Chat type
  username: string | null; // Chat username (if available)
  lastMessageDate: string | null; // ISO 8601 date of last message
  unreadCount: number; // Number of unread messages
  unreadMentionsCount: number; // Number of unread mentions
  pinned: boolean; // Whether chat is pinned
  archived: boolean; // Whether chat is archived
  memberCount: number; // Number of members (for groups/channels)
  relevanceScore?: number; // Relevance score when query is provided
}

export interface TelegramPaginationInfo {
  totalCount: number; // Total number of matching chats
  limit: number; // Maximum items per page
  offset: number; // Current offset
  hasMore: boolean; // Whether more results are available
}

export interface TelegramSearchChatsData {
  items: TelegramChat[]; // List of matching chats
  pagination: TelegramPaginationInfo; // Pagination metadata
}

export type TelegramSearchChatsResult = AdapterResultBase<TelegramSearchChatsData>;

export interface TelegramMessage {
  id: string; // Message ID
  text: string; // Message text content
  caption: string | null; // Caption for media messages
  date: string; // ISO 8601 timestamp
  chatId: string; // Chat ID where message was sent
  senderId: string; // Sender user ID
  senderName: string; // Sender display name
  hasMedia: boolean; // Whether message has media attachment
  mediaType: string | null; // Media type: photo, video, document, etc.
  isOutgoing: boolean; // Whether message was sent by the user
  replyToMessageId: string | null; // ID of message being replied to
}

export interface TelegramSearchMessagesData {
  messages: TelegramMessage[]; // List of matching messages
  count: number; // Number of messages returned
}

export type TelegramSearchMessagesResult = AdapterResultBase<TelegramSearchMessagesData>;

export interface TelegramGetChatMessagesData {
  messages: TelegramMessage[]; // List of messages from the chat
  count: number; // Number of messages returned
  chatId?: string; // Chat ID the messages are from
}

export type TelegramGetChatMessagesResult = AdapterResultBase<TelegramGetChatMessagesData>;

export interface TelegramUnreadSummaryEntry {
  chatId: string; // Chat ID
  chatName: string; // Chat display name
  chatType: 'private' | 'group' | 'channel'; // Chat type
  unreadCount: number; // Number of unread messages
  hasMention: boolean; // Whether there are unread mentions
  lastMessageText: string | null; // Text of last message
  lastMessageSender: string | null; // Sender of last message
  lastMessageDate: string | null; // ISO 8601 date of last message
}

export interface TelegramUnreadSummaryData {
  chats: TelegramUnreadSummaryEntry[]; // List of chats with unread information
  totalUnread: number; // Total unread messages across all chats
  chatsWithUnread: number; // Number of chats with unread messages
}

export type TelegramGetUnreadSummaryResult = AdapterResultBase<TelegramUnreadSummaryData>;

export interface TelegramMarkAsReadData {
  success: boolean; // Whether the operation succeeded
  chatId: string; // Chat ID that was marked as read
  markedAt: string; // ISO 8601 timestamp when marked
}

export type TelegramMarkAsReadResult = AdapterResultBase<TelegramMarkAsReadData>;

export interface TelegramMentionsData {
  mentions: TelegramMessage[]; // List of messages with mentions
  count: number; // Number of mentions returned
}

export type TelegramGetMentionsResult = AdapterResultBase<TelegramMentionsData>;

export interface TelegramLeaveGroupData {
  success: boolean; // Whether the operation succeeded
  chatId: string; // Chat ID that was left
  leftAt: string; // ISO 8601 timestamp when left
}

export type TelegramLeaveGroupResult = AdapterResultBase<TelegramLeaveGroupData>;

// Gmail Response Types
export interface GoogleGmailSendEmailData {
  messageId: string; // ID of the sent message
  to: string; // Recipient email address
  subject: string; // Email subject
  sentAt: string; // ISO timestamp when sent
}

export type GoogleGmailSendEmailResult = AdapterResultBase<GoogleGmailSendEmailData>;

export interface GoogleGmailAttachment {
  filename: string; // Attachment filename
  mimeType: string; // MIME type
  size: number; // Size in bytes
  attachmentId: string; // Attachment ID
}

export interface GoogleGmailGetEmailData {
  id: string; // Unique email ID
  threadId: string; // Thread ID
  subject: string; // Email subject
  from: string; // Sender email address
  to: string; // Recipient email address
  cc?: string; // CC recipients
  bcc?: string; // BCC recipients
  date: string; // ISO timestamp of email
  body: string; // Plain text body content
  bodyHtml?: string; // HTML body content
  snippet: string; // Email preview snippet
  labelIds: string[]; // Gmail label IDs
  isUnread: boolean; // Whether email is unread
  hasAttachments: boolean; // Whether email has attachments
  attachments?: GoogleGmailAttachment[]; // Attachment metadata
}

export type GoogleGmailGetEmailResult = AdapterResultBase<GoogleGmailGetEmailData>;

export interface GoogleGmailEmailSummary {
  id: string; // Unique email ID
  threadId: string; // Thread ID
  subject: string; // Email subject
  from: string; // Sender email address
  to: string; // Recipient email address
  date: string; // ISO timestamp
  snippet: string; // Preview snippet
  labelIds: string[]; // Gmail label IDs
  isUnread: boolean; // Whether email is unread
  hasAttachments: boolean; // Whether email has attachments
}

export interface GoogleGmailSearchEmailsData {
  query: string; // Search query used
  count: number; // Number of results
  emails: GoogleGmailEmailSummary[]; // List of matching emails
}

export type GoogleGmailSearchEmailsResult = AdapterResultBase<GoogleGmailSearchEmailsData>;

export interface GoogleGmailListEmailsData {
  query: string; // Search query used
  count: number; // Number of results
  emails: GoogleGmailEmailSummary[]; // List of emails
}

export type GoogleGmailListEmailsResult = AdapterResultBase<GoogleGmailListEmailsData>;

export interface GoogleGmailCreateDraftData {
  draftId: string; // ID of created draft
  subject: string; // Draft subject
  to: string; // Recipient email address
}

export type GoogleGmailCreateDraftResult = AdapterResultBase<GoogleGmailCreateDraftData>;

export interface GoogleGmailUpdateDraftData {
  draftId: string; // ID of updated draft
  updated: boolean; // Whether update succeeded
}

export type GoogleGmailUpdateDraftResult = AdapterResultBase<GoogleGmailUpdateDraftData>;

export interface GoogleGmailDeleteDraftData {
  draftId: string; // ID of deleted draft
  deleted: boolean; // Whether deletion succeeded
}

export type GoogleGmailDeleteDraftResult = AdapterResultBase<GoogleGmailDeleteDraftData>;

export interface GoogleGmailDraftSummary {
  id: string; // Draft ID
  messageId: string; // Associated message ID
  subject: string; // Draft subject
  to: string; // Recipient email
  snippet: string; // Preview snippet
}

export interface GoogleGmailListDraftsData {
  count: number; // Number of drafts
  drafts: GoogleGmailDraftSummary[]; // List of drafts
}

export type GoogleGmailListDraftsResult = AdapterResultBase<GoogleGmailListDraftsData>;

export interface GoogleGmailDeleteEmailData {
  messageId: string; // ID of deleted email
  deleted: 'permanent' | 'trash'; // Type of deletion
}

export type GoogleGmailDeleteEmailResult = AdapterResultBase<GoogleGmailDeleteEmailData>;

export interface GoogleGmailBulkDeleteEmailsData {
  deletedCount: number; // Number of emails deleted
  messageIds: string[]; // IDs of deleted emails
  deleted: 'permanent' | 'trash'; // Type of deletion
}

export type GoogleGmailBulkDeleteEmailsResult = AdapterResultBase<GoogleGmailBulkDeleteEmailsData>;

// Google Calendar Response Types
export interface GoogleCalendarAttendee {
  email: string; // Attendee email address
  name?: string; // Attendee display name
  responseStatus?: string; // Response status: needsAction, declined, tentative, accepted
  isOrganizer?: boolean; // Whether this attendee is the organizer
  isSelf?: boolean; // Whether this is the authenticated user
}

export interface GoogleCalendarGetEventData {
  id: string; // Calendar event ID
  summary: string; // Event title
  description: string; // Event description
  location: string; // Event location
  startTime: string; // Start time (ISO 8601)
  endTime: string; // End time (ISO 8601)
  isAllDay: boolean; // Whether this is an all-day event
  timeZone: string; // Event timezone
  creator: GoogleCalendarAttendee; // Event creator
  organizer: GoogleCalendarAttendee; // Event organizer
  attendees: GoogleCalendarAttendee[]; // List of attendees
  attendeeCount: number; // Number of attendees
  status: string; // Event status: confirmed, tentative, cancelled
  htmlLink: string; // Link to view event in Google Calendar
  isRecurring: boolean; // Whether this is a recurring event
  recurringEventId?: string; // ID of the recurring event series
  created: string; // When the event was created (ISO 8601)
  updated: string; // When the event was last updated (ISO 8601)
}

export type GoogleCalendarGetEventResult = AdapterResultBase<GoogleCalendarGetEventData>;

export interface GoogleCalendarEventSummary {
  id: string; // Calendar event ID
  summary: string; // Event title
  location: string; // Event location
  startTime: string; // Start time (ISO 8601)
  endTime: string; // End time (ISO 8601)
  isAllDay: boolean; // Whether this is an all-day event
  status: string; // Event status: confirmed, tentative, cancelled
  htmlLink: string; // Link to view event in Google Calendar
  isRecurring: boolean; // Whether this is a recurring event
  attendeeCount: number; // Number of attendees
}

export interface GoogleCalendarListEventsData {
  count: number; // Number of events returned
  query?: string; // Search query used
  timeMin?: string; // Start of time range
  timeMax?: string; // End of time range
  events: GoogleCalendarEventSummary[]; // List of calendar events
}

export type GoogleCalendarListEventsResult = AdapterResultBase<GoogleCalendarListEventsData>;

export interface GoogleCalendarListEventsData {
  count: number; // Number of events returned
  query?: string; // Search query used
  timeMin?: string; // Start of time range
  timeMax?: string; // End of time range
  events: GoogleCalendarEventSummary[]; // List of calendar events
}

export type GoogleCalendarGetEventsResult = AdapterResultBase<GoogleCalendarListEventsData>;

export interface GoogleCalendarSearchEventsData {
  count: number; // Number of events returned
  query: string; // Search query used
  timeMin?: string; // Start of time range
  timeMax?: string; // End of time range
  events: GoogleCalendarEventSummary[]; // List of matching calendar events
}

export type GoogleCalendarSearchEventsResult = AdapterResultBase<GoogleCalendarSearchEventsData>;

export interface GoogleCalendarCreateEventData {
  eventId: string; // Created event ID
  summary: string; // Event title
  start: object; // Event start time
  end: object; // Event end time
  htmlLink: string; // Link to view event in Google Calendar
}

export type GoogleCalendarCreateEventResult = AdapterResultBase<GoogleCalendarCreateEventData>;

export interface GoogleCalendarUpdateEventData {
  eventId: string; // Updated event ID
  summary: string; // Event title
  updated: boolean; // Whether the update succeeded
}

export type GoogleCalendarUpdateEventResult = AdapterResultBase<GoogleCalendarUpdateEventData>;

export interface GoogleCalendarDeleteEventData {
  eventId: string; // Deleted event ID
  deleted: boolean; // Whether the deletion succeeded
}

export type GoogleCalendarDeleteEventResult = AdapterResultBase<GoogleCalendarDeleteEventData>;

// Google Drive Response Types
export interface GoogleDriveFileSummary {
  id: string; // File ID
  name: string; // File name
  mimeType: string; // MIME type
  mimeTypeReadable: string; // Human-readable file type
  createdAt: string; // ISO 8601 creation date
  modifiedAt: string; // ISO 8601 modification date
  isFolder: boolean; // Whether this is a folder
}

export interface GoogleDriveListFilesData {
  count: number; // Number of files returned
  query?: string; // Search query used
  files: GoogleDriveFileSummary[]; // Array of file summaries
}

export type GoogleDriveListFilesResult = AdapterResultBase<GoogleDriveListFilesData>;

export interface GoogleDriveSearchFilesData {
  count: number; // Number of files returned
  query: string; // Search query used
  files: GoogleDriveFileSummary[]; // Array of matching file summaries
}

export type GoogleDriveSearchFilesResult = AdapterResultBase<GoogleDriveSearchFilesData>;

export interface GoogleDriveOwner {
  name: string; // Owner name
  email: string; // Owner email
}

export interface GoogleDriveGetFileInfoData {
  id: string; // File ID
  name: string; // File name
  mimeType: string; // MIME type
  mimeTypeReadable: string; // Human-readable file type
  size: number; // File size in bytes
  createdAt: string; // ISO 8601 creation date
  modifiedAt: string; // ISO 8601 modification date
  webViewLink: string | null; // Web view URL
  parents: string[]; // Parent folder IDs
  owner: GoogleDriveOwner | null; // File owner
  isFolder: boolean; // Whether this is a folder
  isTrashed: boolean; // Whether file is in trash
}

export type GoogleDriveGetFileInfoResult = AdapterResultBase<GoogleDriveGetFileInfoData>;

export interface GoogleDriveCreateFileData {
  fileId: string; // Created file ID
  name: string; // File name
  mimeType: string; // MIME type
  webViewLink?: string; // Web view URL
}

export type GoogleDriveCreateFileResult = AdapterResultBase<GoogleDriveCreateFileData>;

export interface GoogleDriveCreateFolderData {
  folderId: string; // Created folder ID
  name: string; // Folder name
  webViewLink?: string; // Web view URL
}

export type GoogleDriveCreateFolderResult = AdapterResultBase<GoogleDriveCreateFolderData>;

export interface GoogleDriveDownloadFileData {
  data: string; // Base64-encoded file content
  mimeType: string; // MIME type of downloaded file
}

export type GoogleDriveDownloadFileResult = AdapterResultBase<GoogleDriveDownloadFileData>;

export interface GoogleDriveMoveFileData {
  fileId: string; // Moved file ID
  name: string; // File name
  moved: boolean; // Whether move succeeded
}

export type GoogleDriveMoveFileResult = AdapterResultBase<GoogleDriveMoveFileData>;

export interface GoogleDriveShareFileData {
  fileId: string; // Shared file ID
  permissionId: string; // Created permission ID
  role: string; // Permission role granted
  shared: boolean; // Whether share succeeded
}

export type GoogleDriveShareFileResult = AdapterResultBase<GoogleDriveShareFileData>;

export interface GoogleDriveDeleteFileData {
  fileId: string; // Deleted file ID
  deleted: string; // Deletion type: permanent or trash
}

export type GoogleDriveDeleteFileResult = AdapterResultBase<GoogleDriveDeleteFileData>;

export interface GoogleDriveUpdateFileData {
  fileId: string; // Updated file ID
  name: string; // File name
  updated: boolean; // Whether update succeeded
}

export type GoogleDriveUpdateFileResult = AdapterResultBase<GoogleDriveUpdateFileData>;

// Google Sheets Response Types
export interface GoogleSheetsCreateSpreadsheetData {
  spreadsheetId: string; // Created spreadsheet ID
  title: string; // Spreadsheet title
  url: string; // URL to open spreadsheet in browser
}

export type GoogleSheetsCreateSpreadsheetResult = AdapterResultBase<GoogleSheetsCreateSpreadsheetData>;

export interface GoogleSheetsSheetInfo {
  sheetId: number; // Numeric sheet ID
  title: string; // Sheet tab name
  index: number; // Sheet index (0-based)
  rowCount: number; // Total rows in sheet
  columnCount: number; // Total columns in sheet
  isHidden: boolean; // Whether sheet is hidden
}

export interface GoogleSheetsNamedRange {
  name: string; // Named range identifier
  range: string; // Range in A1 notation
  sheetId?: number; // Sheet ID containing the range
}

export interface GoogleSheetsGetSpreadsheetData {
  spreadsheetId: string; // Spreadsheet ID
  title: string; // Spreadsheet title
  url: string; // URL to open spreadsheet
  locale: string; // Spreadsheet locale (e.g., en_US)
  timeZone: string; // Spreadsheet timezone
  sheets: GoogleSheetsSheetInfo[]; // List of sheets in the spreadsheet
  namedRanges: GoogleSheetsNamedRange[]; // List of named ranges
}

export type GoogleSheetsGetSpreadsheetResult = AdapterResultBase<GoogleSheetsGetSpreadsheetData>;

export interface GoogleSheetsReadRangeData {
  spreadsheetId: string; // Spreadsheet ID
  range: string; // Range that was read
  values: any[][]; // 2D array of cell values
  rowCount: number; // Number of rows returned
  columnCount: number; // Number of columns in widest row
  isEmpty: boolean; // Whether the range is empty
}

export type GoogleSheetsReadRangeResult = AdapterResultBase<GoogleSheetsReadRangeData>;

export interface GoogleSheetsWriteRangeData {
  spreadsheetId: string; // Spreadsheet ID
  updatedRange: string; // Range that was updated
  updatedRows: number; // Number of rows updated
  updatedColumns: number; // Number of columns updated
  updatedCells: number; // Total cells updated
}

export type GoogleSheetsWriteRangeResult = AdapterResultBase<GoogleSheetsWriteRangeData>;

export interface GoogleSheetsAppendRowData {
  spreadsheetId: string; // Spreadsheet ID
  sheetName: string; // Sheet name
  appendedRange: string; // Range where data was appended
  appendedRows: number; // Number of rows appended
  appendedCells: number; // Total cells appended
  values: any[]; // Values that were appended
}

export type GoogleSheetsAppendRowResult = AdapterResultBase<GoogleSheetsAppendRowData>;

export interface GoogleSheetsInsertAtCellData {
  spreadsheetId: string; // Spreadsheet ID
  cell: string; // Cell reference (e.g., Sheet1!A1)
  value: any; // Value that was inserted
  previousValue?: any; // Previous cell value if any
  formatted: boolean; // Whether formatting was applied
}

export type GoogleSheetsInsertAtCellResult = AdapterResultBase<GoogleSheetsInsertAtCellData>;

export interface GoogleSheetsInsertFormulaData {
  spreadsheetId: string; // Spreadsheet ID
  cell: string; // Cell reference
  formula: string; // Formula that was inserted
}

export type GoogleSheetsInsertFormulaResult = AdapterResultBase<GoogleSheetsInsertFormulaData>;

export interface GoogleSheetsFormatRangeData {
  spreadsheetId: string; // Spreadsheet ID
  range: string; // Range that was formatted
  formattingApplied: string[]; // List of formatting options applied
}

export type GoogleSheetsFormatRangeResult = AdapterResultBase<GoogleSheetsFormatRangeData>;

export interface GoogleSheetsCreateChartData {
  spreadsheetId: string; // Spreadsheet ID
  chartType: string; // Type of chart created
  title: string; // Chart title
  dataRange: string; // Data range used for chart
  positionRow: number; // Row where chart is anchored
  positionColumn: string; // Column where chart is anchored
}

export type GoogleSheetsCreateChartResult = AdapterResultBase<GoogleSheetsCreateChartData>;

export interface GoogleSheetsFindAndReplaceData {
  spreadsheetId: string; // Spreadsheet ID
  findText: string; // Text that was searched for
  replaceText: string; // Replacement text
  occurrencesReplaced: number; // Number of replacements made
  sheetName?: string; // Sheet searched (null for all)
  matchCase: boolean; // Whether search was case-sensitive
  matchEntireCell: boolean; // Whether entire cell match required
}

export type GoogleSheetsFindAndReplaceResult = AdapterResultBase<GoogleSheetsFindAndReplaceData>;

export interface GoogleSheetsInsertMultipleRowsData {
  spreadsheetId: string; // Spreadsheet ID
  sheetName: string; // Sheet name
  rowsInserted: number; // Number of rows inserted
  cellsInserted: number; // Total cells inserted
  startingRow?: number; // Starting row (null if appended)
  formatted: boolean; // Whether formatting was applied
}

export type GoogleSheetsInsertMultipleRowsResult = AdapterResultBase<GoogleSheetsInsertMultipleRowsData>;

export interface GoogleSheetsClearRangeData {
  spreadsheetId: string; // Spreadsheet ID
  range: string; // Range that was cleared
  cellsCleared: number; // Number of cells cleared
}

export type GoogleSheetsClearRangeResult = AdapterResultBase<GoogleSheetsClearRangeData>;

export interface GoogleSheetsInsertRowsData {
  spreadsheetId: string; // Spreadsheet ID
  sheetId: number; // Numeric sheet ID
  operation: string; // Operation type (insert)
  startRowIndex: number; // Row index where insertion started (0-indexed)
  numRows: number; // Number of rows inserted
}

export type GoogleSheetsInsertRowsResult = AdapterResultBase<GoogleSheetsInsertRowsData>;

export interface GoogleSheetsDeleteRowsData {
  spreadsheetId: string; // Spreadsheet ID
  sheetId: number; // Numeric sheet ID
  operation: string; // Operation type (delete)
  startRowIndex: number; // Row index where deletion started (0-indexed)
  numRows: number; // Number of rows deleted
}

export type GoogleSheetsDeleteRowsResult = AdapterResultBase<GoogleSheetsDeleteRowsData>;

export interface GoogleSheetsInsertColumnsData {
  spreadsheetId: string; // Spreadsheet ID
  sheetId: number; // Numeric sheet ID
  operation: string; // Operation type (insert)
  startColumnIndex: number; // Column index where insertion started (0-indexed)
  startColumnLetter: string; // Column letter where insertion started
  numColumns: number; // Number of columns inserted
}

export type GoogleSheetsInsertColumnsResult = AdapterResultBase<GoogleSheetsInsertColumnsData>;

export interface GoogleSheetsDeleteColumnsData {
  spreadsheetId: string; // Spreadsheet ID
  sheetId: number; // Numeric sheet ID
  operation: string; // Operation type (delete)
  startColumnIndex: number; // Column index where deletion started (0-indexed)
  startColumnLetter: string; // Column letter where deletion started
  numColumns: number; // Number of columns deleted
}

export type GoogleSheetsDeleteColumnsResult = AdapterResultBase<GoogleSheetsDeleteColumnsData>;

export interface GoogleSheetsCopyRangeData {
  spreadsheetId: string; // Spreadsheet ID
  sourceSheetId: number; // Source sheet ID
  sourceRange: string; // Source range in A1 notation
  targetSheetId: number; // Target sheet ID
  targetStartCell: string; // Target start cell
}

export type GoogleSheetsCopyRangeResult = AdapterResultBase<GoogleSheetsCopyRangeData>;

// Google Docs Response Types
export interface GoogleDocsCreateDocumentData {
  documentId: string; // ID of the created document
  title: string; // Title of the created document
}

export type GoogleDocsCreateDocumentResult = AdapterResultBase<GoogleDocsCreateDocumentData>;

export interface GoogleDocsDocumentData {
  documentId: string; // ID of the document
  title: string; // Title of the document
  revisionId: string; // Current revision ID
  body: string; // Plain text content of the document
  bodyLength: number; // Character count of the body
  lastEditedTime?: string; // ISO 8601 timestamp of last edit
  url: string; // URL to the document
  hasContent: boolean; // Whether document has any text content
}

export type GoogleDocsGetDocumentResult = AdapterResultBase<GoogleDocsDocumentData>;

export interface GoogleDocsContentData {
  documentId: string; // ID of the document
  content: string; // Plain text content of the document
}

export type GoogleDocsGetDocumentContentResult = AdapterResultBase<GoogleDocsContentData>;

export interface GoogleDocsWriteResultData {
  documentId: string; // ID of the document
  success: boolean; // Whether the operation succeeded
  feedback: string; // Human-readable feedback about the operation
}

export type GoogleDocsAppendTextResult = AdapterResultBase<GoogleDocsWriteResultData>;

export interface GoogleDocsWriteResultData {
  documentId: string; // ID of the document
  success: boolean; // Whether the operation succeeded
  feedback: string; // Human-readable feedback about the operation
}

export type GoogleDocsInsertTextAtPositionResult = AdapterResultBase<GoogleDocsWriteResultData>;

export interface GoogleDocsWriteResultData {
  documentId: string; // ID of the document
  success: boolean; // Whether the operation succeeded
  feedback: string; // Human-readable feedback about the operation
}

export type GoogleDocsInsertTextAfterResult = AdapterResultBase<GoogleDocsWriteResultData>;

export interface GoogleDocsWriteResultData {
  documentId: string; // ID of the document
  success: boolean; // Whether the operation succeeded
  feedback: string; // Human-readable feedback about the operation
}

export type GoogleDocsInsertHeadingResult = AdapterResultBase<GoogleDocsWriteResultData>;

export interface GoogleDocsWriteResultData {
  documentId: string; // ID of the document
  success: boolean; // Whether the operation succeeded
  feedback: string; // Human-readable feedback about the operation
}

export type GoogleDocsInsertListResult = AdapterResultBase<GoogleDocsWriteResultData>;

export interface GoogleDocsWriteResultData {
  documentId: string; // ID of the document
  success: boolean; // Whether the operation succeeded
  feedback: string; // Human-readable feedback about the operation
}

export type GoogleDocsInsertTableResult = AdapterResultBase<GoogleDocsWriteResultData>;

export interface GoogleDocsWriteResultData {
  documentId: string; // ID of the document
  success: boolean; // Whether the operation succeeded
  feedback: string; // Human-readable feedback about the operation
}

export type GoogleDocsReplaceTextResult = AdapterResultBase<GoogleDocsWriteResultData>;

export interface GoogleDocsWriteResultData {
  documentId: string; // ID of the document
  success: boolean; // Whether the operation succeeded
  feedback: string; // Human-readable feedback about the operation
}

export type GoogleDocsUpdateDocumentContentResult = AdapterResultBase<GoogleDocsWriteResultData>;

export interface GoogleDocsSectionResultData {
  documentId: string; // ID of the document
  title: string; // Title of the document
  url: string; // URL to the document
  heading: string; // The heading text that was created
  insertionIndex: number; // Character position where section was inserted
  success: boolean; // Whether the operation succeeded
}

export type GoogleDocsCreateSectionResult = AdapterResultBase<GoogleDocsSectionResultData>;

export interface GoogleDocsInsertionPointData {
  documentId: string; // ID of the document
  title: string; // Title of the document
  url: string; // URL to the document
  position: number; // Character position for insertion
  context: string; // Text context around the insertion point
  documentLength: number; // Total character length of the document
}

export type GoogleDocsFindInsertionPointResult = AdapterResultBase<GoogleDocsInsertionPointData>;

// Jira Response Types
export interface JiraGetIssueData {
  id: string; // Unique issue ID
  key: string; // Issue key (e.g., PROJ-123)
  summary: string; // Issue summary/title
  description: string; // Issue description (extracted from ADF)
  status: string; // Status name
  statusId: string; // Status ID
  issueType: string; // Issue type name
  issueTypeId: string; // Issue type ID
  priority: string; // Priority name
  priorityId: string; // Priority ID
  assignee: string; // Assignee display name
  assigneeAccountId: string; // Assignee account ID
  reporter: string; // Reporter display name
  reporterAccountId: string; // Reporter account ID
  projectKey: string; // Project key
  projectName: string; // Project name
  projectId: string; // Project ID
  labels: string[]; // Issue labels
  created: string; // Created timestamp (ISO 8601)
  updated: string; // Updated timestamp (ISO 8601)
  isAssigned: boolean; // Whether issue has an assignee
  hasLabels: boolean; // Whether issue has labels
}

export type JiraGetIssueResult = AdapterResultBase<JiraGetIssueData>;

export interface JiraIssueSummary {
  id: string; // Unique issue ID
  key: string; // Issue key (e.g., PROJ-123)
  summary: string; // Issue summary/title
  status: string; // Status name
  statusId: string; // Status ID
  issueType: string; // Issue type name
  issueTypeId: string; // Issue type ID
  priority: string; // Priority name
  priorityId: string; // Priority ID
  assignee: string; // Assignee display name
  assigneeAccountId: string; // Assignee account ID
  projectKey: string; // Project key
  projectName: string; // Project name
  labels: string[]; // Issue labels
  created: string; // Created timestamp (ISO 8601)
  updated: string; // Updated timestamp (ISO 8601)
  isAssigned: boolean; // Whether issue has an assignee
}

export interface JiraSearchIssuesData {
  jql: string; // JQL query used
  count: number; // Number of results
  issues: JiraIssueSummary[]; // List of matching issues
}

export type JiraSearchIssuesResult = AdapterResultBase<JiraSearchIssuesData>;

export interface JiraCreateIssueData {
  issueKey: string; // Created issue key
  issueId: string; // Created issue ID
  summary: string; // Issue summary
}

export type JiraCreateIssueResult = AdapterResultBase<JiraCreateIssueData>;

export interface JiraUpdateIssueData {
  issueKey: string; // Updated issue key
  updated: boolean; // Whether update succeeded
}

export type JiraUpdateIssueResult = AdapterResultBase<JiraUpdateIssueData>;

export interface JiraDeleteIssueData {
  issueKey: string; // Deleted issue key
  deleted: boolean; // Whether deletion succeeded
}

export type JiraDeleteIssueResult = AdapterResultBase<JiraDeleteIssueData>;

export interface JiraAddCommentData {
  issueKey: string; // Issue key
  commentId: string; // Created comment ID
  added: boolean; // Whether comment was added
}

export type JiraAddCommentResult = AdapterResultBase<JiraAddCommentData>;

export interface JiraTransitionIssueData {
  issueKey: string; // Issue key
  transitioned: boolean; // Whether transition succeeded
  transitionId: string; // Transition ID used
}

export type JiraTransitionIssueResult = AdapterResultBase<JiraTransitionIssueData>;

export interface JiraAssignIssueData {
  issueKey: string; // Issue key
  accountId: string; // Assigned user account ID
  assigned: boolean; // Whether assignment succeeded
}

export type JiraAssignIssueResult = AdapterResultBase<JiraAssignIssueData>;

export interface JiraProject {
  id: string; // Project ID
  key: string; // Project key
  name: string; // Project name
  projectTypeKey: string; // Project type key
  leadName: string; // Project lead name
  leadAccountId: string; // Project lead account ID
}

export interface JiraGetProjectsData {
  count: number; // Number of projects
  projects: JiraProject[]; // List of projects
}

export type JiraGetProjectsResult = AdapterResultBase<JiraGetProjectsData>;

export interface JiraListProjectsData {
  count: number; // Number of projects
  projects: JiraProject[]; // List of projects
}

export type JiraListProjectsResult = AdapterResultBase<JiraListProjectsData>;

export interface JiraIssueType {
  id: string; // Issue type ID
  name: string; // Issue type name
  description: string; // Issue type description
  isSubtask: boolean; // Whether this is a subtask type
}

export interface JiraPriority {
  id: string; // Priority ID
  name: string; // Priority name
  description: string; // Priority description
}

export interface JiraGetProjectMetadataData {
  projectKey: string; // Project key
  projectName: string; // Project name
  issueTypeCount: number; // Number of issue types
  issueTypes: JiraIssueType[]; // Available issue types
  priorityCount: number; // Number of priorities
  priorities: JiraPriority[]; // Available priorities
}

export type JiraGetProjectMetadataResult = AdapterResultBase<JiraGetProjectMetadataData>;

export interface JiraTransition {
  id: string; // Transition ID
  name: string; // Transition name
  toStatus: string; // Target status name
  toStatusId: string; // Target status ID
}

export interface JiraGetTransitionsData {
  issueKey: string; // Issue key
  count: number; // Number of transitions
  transitions: JiraTransition[]; // Available transitions
}

export type JiraGetTransitionsResult = AdapterResultBase<JiraGetTransitionsData>;

export interface JiraUser {
  accountId: string; // User account ID
  displayName: string; // User display name
  emailAddress?: string; // User email address
  active: boolean; // Whether user is active
}

export interface JiraListAssignableUsersData {
  projectKey: string; // Project key
  count: number; // Number of users
  users: JiraUser[]; // Assignable users
}

export type JiraListAssignableUsersResult = AdapterResultBase<JiraListAssignableUsersData>;

export interface JiraGetIssueTypesData {
  projectKey: string; // Project key
  count: number; // Number of issue types
  issueTypes: JiraIssueType[]; // Available issue types
}

export type JiraGetIssueTypesResult = AdapterResultBase<JiraGetIssueTypesData>;

// Twitter Response Types
export interface TwitterPostTweetData {
  tweetId: string; // ID of the posted tweet
  text: string; // Text content of the posted tweet
}

export type TwitterPostTweetResult = AdapterResultBase<TwitterPostTweetData>;

export interface TwitterNormalizedTweet {
  id: string; // Tweet ID
  text: string; // Tweet text content
  url: string; // Direct URL to the tweet
  createdAt: string; // Tweet creation time (ISO 8601)
  lang?: string; // Tweet language code
  likeCount: number; // Number of likes
  retweetCount: number; // Number of retweets
  replyCount: number; // Number of replies
  quoteCount: number; // Number of quote tweets
  viewCount: number; // Number of views
  bookmarkCount: number; // Number of bookmarks
  isReply: boolean; // Whether this is a reply to another tweet
  isRetweet: boolean; // Whether this is a retweet
  source?: string; // Source application of the tweet
  authorId: string; // Author user ID
  authorName: string; // Author display name
  authorUserName: string; // Author username/handle
  authorFollowers: number; // Author follower count
  authorFollowing: number; // Author following count
  authorIsVerified: boolean; // Whether the author is verified
  authorVerifiedType?: string; // Type of verification (blue, business, government)
  authorCreatedAt?: string; // Author account creation date
}

export interface TwitterGetUserTweetsData {
  tweets: TwitterNormalizedTweet[]; // List of normalized tweets
  hasNextPage: boolean; // Whether more tweets are available
  nextCursor: string; // Cursor for fetching the next page
  totalRetrieved: number; // Number of tweets retrieved in this response
}

export type TwitterGetUserTweetsResult = AdapterResultBase<TwitterGetUserTweetsData>;

export interface TwitterAdvancedSearchData {
  query: string; // Search query used
  queryType: string; // Type of search: Latest or Top
  tweets: TwitterNormalizedTweet[]; // List of matching tweets
  hasNextPage: boolean; // Whether more results are available
  nextCursor: string; // Cursor for fetching the next page
  totalRetrieved: number; // Number of tweets retrieved in this response
}

export type TwitterAdvancedSearchResult = AdapterResultBase<TwitterAdvancedSearchData>;

// Trello Response Types
export interface TrelloBoard {
  id: string; // Board ID
  name: string; // Board name
  description: string; // Board description
  url: string; // Board URL
  closed: boolean; // Whether board is closed/archived
  starred: boolean; // Whether board is starred
  listCount: number; // Number of lists in the board
}

export interface TrelloGetBoardsData {
  boards: TrelloBoard[]; // List of boards
  count: number; // Number of boards returned
}

export type TrelloGetBoardsResult = AdapterResultBase<TrelloGetBoardsData>;

export interface TrelloList {
  id: string; // List ID
  name: string; // List name
  closed: boolean; // Whether list is closed/archived
  position: number; // List position
  boardId: string; // ID of the parent board
}

export interface TrelloGetBoardData {
  id: string; // Board ID
  name: string; // Board name
  description: string; // Board description
  url: string; // Board URL
  closed: boolean; // Whether board is closed
  starred: boolean; // Whether board is starred
  lists: TrelloList[]; // Lists in the board
  listCount: number; // Number of lists
}

export type TrelloGetBoardResult = AdapterResultBase<TrelloGetBoardData>;

export interface TrelloCard {
  id: string; // Card ID
  name: string; // Card name/title
  description: string; // Card description
  url: string; // Card URL
  shortUrl: string; // Short card URL
  closed: boolean; // Whether card is archived
  position: number; // Card position in list
  listId: string; // ID of the parent list
  boardId: string; // ID of the parent board
  dueDate: string | null; // Due date in ISO 8601 format
  dueComplete: boolean; // Whether due date is marked complete
  labels: string[]; // Array of label names
  checklistCount: number; // Number of checklists on the card
  attachmentCount: number; // Number of attachments
  commentCount: number; // Number of comments
}

export interface TrelloCreateCardData {
  card: TrelloCard; // Created card
}

export type TrelloCreateCardResult = AdapterResultBase<TrelloCreateCardData>;

export interface TrelloGetCardData {
  card: TrelloCard; // Card details
}

export type TrelloGetCardResult = AdapterResultBase<TrelloGetCardData>;

export interface TrelloUpdateCardData {
  card: TrelloCard; // Updated card
}

export type TrelloUpdateCardResult = AdapterResultBase<TrelloUpdateCardData>;

export interface TrelloDeleteCardData {
  success: boolean; // Whether deletion succeeded
  deletedId: string; // ID of the deleted entity
  deletedAt: string; // ISO 8601 timestamp of deletion
}

export type TrelloDeleteCardResult = AdapterResultBase<TrelloDeleteCardData>;

export interface TrelloChecklist {
  id: string; // Checklist ID
  name: string; // Checklist name
  cardId: string; // ID of the parent card
  boardId: string; // ID of the parent board
  position: number; // Checklist position
  checkItemCount: number; // Total number of check items
  checkItemsChecked: number; // Number of completed check items
}

export interface TrelloCheckItem {
  id: string; // Check item ID
  name: string; // Check item text
  checklistId: string; // ID of the parent checklist
  state: 'complete' | 'incomplete'; // Completion state
  position: number; // Check item position
}

export interface TrelloCreateChecklistData {
  checklist: TrelloChecklist; // Created checklist
  checkItems: TrelloCheckItem[]; // Check items in the checklist
}

export type TrelloCreateChecklistResult = AdapterResultBase<TrelloCreateChecklistData>;

export interface TrelloGetChecklistData {
  checklist: TrelloChecklist; // Checklist details
  checkItems: TrelloCheckItem[]; // Check items in the checklist
}

export type TrelloGetChecklistResult = AdapterResultBase<TrelloGetChecklistData>;

export interface TrelloUpdateChecklistData {
  checklist: TrelloChecklist; // Updated checklist
  checkItems: TrelloCheckItem[]; // Check items in the checklist
}

export type TrelloUpdateChecklistResult = AdapterResultBase<TrelloUpdateChecklistData>;

export interface TrelloDeleteChecklistData {
  success: boolean; // Whether deletion succeeded
  deletedId: string; // ID of the deleted entity
  deletedAt: string; // ISO 8601 timestamp of deletion
}

export type TrelloDeleteChecklistResult = AdapterResultBase<TrelloDeleteChecklistData>;

export interface TrelloAddCheckItemData {
  checkItem: TrelloCheckItem; // Created check item
}

export type TrelloAddCheckItemResult = AdapterResultBase<TrelloAddCheckItemData>;

export interface TrelloUpdateCheckItemData {
  checkItem: TrelloCheckItem; // Updated check item
}

export type TrelloUpdateCheckItemResult = AdapterResultBase<TrelloUpdateCheckItemData>;

export interface TrelloDeleteCheckItemData {
  success: boolean; // Whether deletion succeeded
  deletedId: string; // ID of the deleted entity
  deletedAt: string; // ISO 8601 timestamp of deletion
}

export type TrelloDeleteCheckItemResult = AdapterResultBase<TrelloDeleteCheckItemData>;

// Jupiter Response Types
export interface JupiterSwapData {
  type: 'pending_transaction'; // Response type
  transaction: string; // Base64 encoded serialized transaction
  requestId: string; // Jupiter request ID (for execute endpoint)
  signerWallet: string; // Wallet address that needs to sign
  expiresAt: string; // Expiration timestamp (ISO 8601)
  inputMint: string; // Input token mint address
  outputMint: string; // Output token mint address
  inputAmount: string; // Input amount as string
  inputDecimals: number; // Input token decimals
  expectedOutputAmount: string; // Expected output amount
  priceImpact: string; // Price impact percentage
  slippageBps: number; // Slippage tolerance in basis points
  hasRoutePlan: boolean; // Whether swap has a route plan
  routeStepCount: number; // Number of steps in route
}

export type JupiterSwapResult = AdapterResultBase<JupiterSwapData>;

export interface JupiterTokenBalance {
  mint: string; // Token mint address
  symbol: string; // Token symbol
  name: string; // Token name
  decimals: number; // Token decimals
  balance: string; // Raw balance string
  uiBalance: number; // Human-readable balance
  logoURI: string; // Token logo URL (empty if not available)
  priceUsd: number; // Token price in USD (0 if not available)
  valueUsd: number; // Total value in USD (0 if not available)
  accountCount: number; // Number of token accounts for this mint
}

export interface JupiterGetHoldingsData {
  owner: string; // Wallet owner address
  solBalance: number; // Native SOL balance
  totalValueUsd: number; // Total portfolio value in USD
  tokenCount: number; // Number of tokens held
  tokens: JupiterTokenBalance[]; // List of token balances
}

export type JupiterGetHoldingsResult = AdapterResultBase<JupiterGetHoldingsData>;

export interface JupiterSecurityWarning {
  type: string; // Warning type
  message: string; // Warning message
  severity: 'info' | 'warning' | 'critical'; // Warning severity
  source: string; // Warning source (empty if not available)
}

export interface JupiterTokenSecurityData {
  mint: string; // Token mint address
  riskLevel: 'safe' | 'low' | 'medium' | 'high' | 'critical'; // Overall risk level
  warningCount: number; // Number of warnings
  hasCriticalWarning: boolean; // Whether there are critical warnings
  hasFreezableWarning: boolean; // Whether token can be frozen
  hasMintableWarning: boolean; // Whether token can be minted
  warnings: JupiterSecurityWarning[]; // List of security warnings
}

export type JupiterGetTokenSecurityResult = AdapterResultBase<JupiterTokenSecurityData>;

export interface JupiterTokenSearchResult {
  mint: string; // Token mint address
  symbol: string; // Token symbol
  name: string; // Token name
  decimals: number; // Token decimals
  iconUrl: string; // Token icon URL (empty if not available)
  twitter: string; // Twitter handle (empty if not available)
  telegram: string; // Telegram link (empty if not available)
  website: string; // Website URL (empty if not available)
  holderCount: number; // Number of token holders
  circSupply: number; // Circulating supply
  totalSupply: number; // Total supply
  tokenProgram: string; // Token program ID
  launchpad: string; // Launchpad name (empty if not available)
  mintAuthorityDisabled: boolean; // Whether mint authority is disabled
  freezeAuthorityDisabled: boolean; // Whether freeze authority is disabled
  topHoldersPercentage: number; // Percentage held by top holders
  devBalancePercentage: number; // Percentage held by dev
  isSuspicious: boolean; // Whether token is flagged as suspicious
  highSingleOwnership: boolean; // Whether there is high single ownership
  organicScore: number; // Organic activity score
  organicScoreLabel: string; // Organic score label
  isVerified: boolean; // Whether token is verified
  fdv: number; // Fully diluted valuation (0 if not available)
  marketCap: number; // Market cap (0 if not available)
  priceUsd: number; // Price in USD (0 if not available)
  liquidity: number; // Liquidity (0 if not available)
  dailyPriceChange: number; // 24h price change (0 if not available)
  dailyHolderChange: number; // 24h holder change (0 if not available)
  dailyLiquidityChange: number; // 24h liquidity change (0 if not available)
  dailyVolumeChange: number; // 24h volume change (0 if not available)
  dailyBuyVolume: number; // 24h buy volume (0 if not available)
  dailySellVolume: number; // 24h sell volume (0 if not available)
  tags: string[]; // Token tags
}

export interface JupiterSearchTokensData {
  query: string; // Search query used
  count: number; // Number of results
  results: JupiterTokenSearchResult[]; // List of matching tokens
}

export type JupiterSearchTokensResult = AdapterResultBase<JupiterSearchTokensData>;

export interface JupiterRefreshSwapData {
  type: 'pending_transaction'; // Response type
  transaction: string; // Base64 encoded serialized transaction
  requestId: string; // Jupiter request ID (for execute endpoint)
  signerWallet: string; // Wallet address that needs to sign
  expiresAt: string; // Expiration timestamp (ISO 8601)
  refreshedAt: string; // Refresh timestamp (ISO 8601)
  inputMint: string; // Input token mint address
  outputMint: string; // Output token mint address
  inputAmount: string; // Input amount as string
  inputDecimals: number; // Input token decimals
  expectedOutputAmount: string; // Expected output amount
  priceImpact: string; // Price impact percentage
  slippageBps: number; // Slippage tolerance in basis points
  hasRoutePlan: boolean; // Whether swap has a route plan
  routeStepCount: number; // Number of steps in route
}

export type JupiterRefreshSwapResult = AdapterResultBase<JupiterRefreshSwapData>;

export interface JupiterLaunchTokenData {
  type: 'pending_transaction'; // Response type
  transaction: string; // Base64 encoded unsigned transaction
  mint: string; // New token mint address
  signerWallet: string; // Wallet that needs to sign
  expiresAt: string; // Expiration timestamp (ISO 8601)
  tokenName: string; // Token name
  tokenSymbol: string; // Token symbol
  imageUrl: string; // Onchain image URL (from Jupiter)
}

export type JupiterLaunchTokenResult = AdapterResultBase<JupiterLaunchTokenData>;

// Crypto Response Types
export interface CryptoGetPriceData {
  tokenAddress: string; // Token contract address
  chain: 'evm' | 'svm'; // Chain type
  chainName: string; // Chain name (e.g., solana, ethereum)
  priceUsd: number; // Current price in USD
  timestamp: string; // Price timestamp (ISO 8601)
  block: number | null; // Block number of price (if available)
  source: string | null; // Price data source
}

export type CryptoGetPriceResult = AdapterResultBase<CryptoGetPriceData>;

export interface CryptoSendTokenData {
  type: string; // Always "pending_transaction"
  transferId: string; // Unique transfer identifier
  transaction: string; // Base64 encoded serialized transaction
  signerWallet: string; // Wallet address that will sign
  tokenMint: string; // Token mint address
  tokenSymbol: string; // Token symbol (e.g., SOL, USDC)
  tokenName: string; // Token display name
  tokenDecimals: number; // Token decimal places
  amount: string; // Amount to send (string for precision)
  recipientAddress: string; // Recipient wallet address
  recipientDisplayName: string; // Recipient display name
  isContact: boolean; // Whether recipient is a contact
  estimatedFee: string; // Estimated transaction fee
  senderAddress: string; // Sender wallet address
  expiresAt: string; // Transaction expiry (ISO 8601)
}

export type CryptoSendTokenResult = AdapterResultBase<CryptoSendTokenData>;

export interface CryptoMonitorPriceData {
  flowId: string; // Created flow ID
  tokenAddress: string; // Token contract address
  chain: 'evm' | 'svm'; // Chain type
  chainName: string; // Chain name
  currentPrice: number; // Current price when monitor was created
  targetPrice: number; // Target price for alert
  direction: 'above' | 'below'; // Alert direction
  percentStep: number; // Progressive alert step percentage
  status: string; // Monitor status (always "active")
}

export type CryptoMonitorPriceResult = AdapterResultBase<CryptoMonitorPriceData>;

export interface CryptoMonitorEntry {
  assignmentId: string; // Flow assignment ID
  title: string; // Monitor title
  tokenAddress: string; // Token contract address
  chain: string; // Chain type (evm or svm)
  chainName: string; // Chain name
  direction: string; // Alert direction (above or below)
  targetPrice?: number; // Target price in USD
  currentStep?: number; // Current step in progressive alerts
  maxSteps?: number; // Maximum steps
  nextThreshold?: number; // Next threshold price
  stepValue?: number; // Step percentage value
  status: string; // Monitor status
  createdAt?: string; // Creation timestamp (ISO 8601)
}

export interface CryptoListSubscriptionsData {
  monitors: CryptoMonitorEntry[]; // List of active price monitors
  count: number; // Number of active monitors
}

export type CryptoListSubscriptionsResult = AdapterResultBase<CryptoListSubscriptionsData>;

export interface CryptoUnsubscribeAssetData {
  tokenAddress: string; // Token contract address
  chain: 'evm' | 'svm'; // Chain type
  deletedAssignments: string[]; // IDs of deleted assignments
  count: number; // Number of deleted monitors
  status: string; // Operation status
  message?: string; // Optional message
}

export type CryptoUnsubscribeAssetResult = AdapterResultBase<CryptoUnsubscribeAssetData>;

export interface CryptoRefreshTransactionData {
  type: string; // Always "pending_transaction"
  transferId: string; // Unique transfer identifier
  transaction: string; // Base64 encoded serialized transaction
  signerWallet: string; // Wallet address that will sign
  tokenMint: string; // Token mint address
  tokenSymbol: string; // Token symbol (e.g., SOL, USDC)
  tokenName: string; // Token display name
  tokenDecimals: number; // Token decimal places
  amount: string; // Amount to send (string for precision)
  recipientAddress: string; // Recipient wallet address
  recipientDisplayName: string; // Recipient display name
  isContact: boolean; // Whether recipient is a contact
  estimatedFee: string; // Estimated transaction fee
  senderAddress: string; // Sender wallet address
  expiresAt: string; // Transaction expiry (ISO 8601)
  refreshedAt: string; // Refresh timestamp (ISO 8601)
}

export type CryptoRefreshTransactionResult = AdapterResultBase<CryptoRefreshTransactionData>;

// Scripts Response Types
export interface ScriptCreateData {
  id: string; // Created script ID
  name: string; // Script name
  description: string; // Script description
  runtime: string; // Lambda runtime (e.g., nodejs18)
  timeout: number; // Timeout in seconds
  memory: number; // Memory in MB
  activeVersion: number; // Active version number
  isPublished: boolean; // Whether published
  isPrivate: boolean; // Whether private
  status: string; // Script status
  deploymentStatus: string; // Deployment status
  apiKey: string; // API key for script execution (only returned on creation)
  installationId: string; // Auto-created installation ID
  createdAt: string; // Created timestamp (ISO 8601)
}

export type ScriptsCreateScriptResult = AdapterResultBase<ScriptCreateData>;

export interface ScriptDeleteData {
  deleted: boolean; // Whether deletion succeeded
  scriptId: string; // Deleted script ID
  hardDeleted: boolean; // Whether script was permanently deleted
  installationsRemoved: number; // Number of installations removed
  preservedInstallations: number; // Number of installations preserved (soft delete)
}

export type ScriptsDeleteScriptResult = AdapterResultBase<ScriptDeleteData>;

export interface ScriptVersionCreateData {
  id: string; // Version document ID
  scriptId: string; // Parent script ID
  version: number; // Version number
  isActive: boolean; // Whether this version is active
  commitMessage: string; // Commit message for this version
  codeHash: string; // Hash of the code
  createdAt: string; // Created timestamp (ISO 8601)
  deployedAt: string; // Deployed timestamp (ISO 8601) or empty
}

export type ScriptsCreateVersionResult = AdapterResultBase<ScriptVersionCreateData>;

export interface ScriptVersion {
  id: string; // Version document ID
  scriptId: string; // Parent script ID
  version: number; // Version number
  isActive: boolean; // Whether this version is active
  commitMessage: string; // Commit message for this version
  codeHash: string; // Hash of the code
  createdAt: string; // Created timestamp (ISO 8601)
  deployedAt: string; // Deployed timestamp (ISO 8601) or empty
}

export interface ScriptVersionListData {
  count: number; // Number of versions
  versions: ScriptVersion[]; // List of script versions
}

export type ScriptsListVersionsResult = AdapterResultBase<ScriptVersionListData>;

export interface ScriptDeployData {
  scriptId: string; // Deployed script ID
  version: number; // Deployed version number
  lambdaFunctionName: string; // AWS Lambda function name
  lambdaArn: string; // AWS Lambda ARN
  deployedAt: string; // Deployment timestamp (ISO 8601)
}

export type ScriptsDeployScriptResult = AdapterResultBase<ScriptDeployData>;

export interface ScriptExecuteData {
  executionId: string; // Unique execution ID
  scriptId: string; // Executed script ID
  status: string; // Execution status
  output: any; // Script output data
  duration: number; // Execution duration in milliseconds
  logs: string[]; // Execution logs
  error: string; // Error message (empty if no error)
  createdAt: string; // Execution timestamp (ISO 8601)
}

export type ScriptsExecuteScriptResult = AdapterResultBase<ScriptExecuteData>;

export interface ScriptGetData {
  id: string; // Script ID
  name: string; // Script name
  description: string; // Script description
  runtime: string; // Lambda runtime
  timeout: number; // Timeout in seconds
  memory: number; // Memory in MB
  activeVersion: number; // Active version number
  isPublished: boolean; // Whether published
  isPrivate: boolean; // Whether private
  status: string; // Script status
  deploymentStatus: string; // Deployment status
  lambdaFunctionName: string; // Lambda function name
  lambdaArn: string; // Lambda ARN
  totalExecutions: number; // Total executions
  totalCost: number; // Total cost in USD
  avgDuration: number; // Average duration in ms
  errorRate: number; // Error rate (0-1)
  createdAt: string; // Created timestamp (ISO 8601)
  deployedAt: string; // Deployed timestamp (ISO 8601) or empty
  publishedAt: string; // Published timestamp (ISO 8601) or empty
  lastExecutedAt: string; // Last execution timestamp (ISO 8601) or empty
}

export type ScriptsGetScriptResult = AdapterResultBase<ScriptGetData>;

export interface ScriptSummary {
  id: string; // Unique script ID
  name: string; // Script name
  description: string; // Script description
  activeVersion: number; // Currently active version number
  isPublished: boolean; // Whether script is published to marketplace
  status: string; // Script status (draft, published, archived)
  deploymentStatus: string; // Deployment status (pending, deploying, deployed, failed)
  totalExecutions: number; // Total number of executions
  createdAt: string; // Created timestamp (ISO 8601)
}

export interface ScriptListData {
  count: number; // Number of scripts
  scripts: ScriptSummary[]; // List of scripts
}

export type ScriptsListScriptsResult = AdapterResultBase<ScriptListData>;

export interface ScriptExecutionSummary {
  executionId: string; // Unique execution ID
  scriptId: string; // Script that was executed
  status: string; // Execution status (running, completed, failed)
  duration: number; // Execution duration in milliseconds
  createdAt: string; // Execution timestamp (ISO 8601)
  hasError: boolean; // Whether execution had an error
}

export interface ScriptExecutionsData {
  scriptId: string; // Script ID
  count: number; // Number of executions
  executions: ScriptExecutionSummary[]; // List of executions
}

export type ScriptsGetExecutionsResult = AdapterResultBase<ScriptExecutionsData>;

export interface ScriptExecutionData {
  executionId: string; // Execution ID
  scriptId: string; // Script ID
  status: string; // Execution status
  output: any; // Script output
  duration: number; // Duration in milliseconds
  logs: string[]; // Execution logs
  error: string; // Error message (empty if no error)
  createdAt: string; // Execution timestamp (ISO 8601)
}

export type ScriptsGetExecutionResult = AdapterResultBase<ScriptExecutionData>;

export interface ScriptPublishData {
  scriptId: string; // Published script ID
  isPublished: boolean; // Publication status (true)
  status: string; // Script status
  publishedAt: string; // Publish timestamp (ISO 8601)
}

export type ScriptsPublishScriptResult = AdapterResultBase<ScriptPublishData>;

export interface ScriptUnpublishData {
  scriptId: string; // Unpublished script ID
  unpublished: boolean; // Whether unpublish succeeded
}

export type ScriptsUnpublishScriptResult = AdapterResultBase<ScriptUnpublishData>;

export interface ScriptMarketplaceListData {
  total: number; // Total number of matching scripts
  limit: number; // Page size limit
  offset: number; // Current offset
  scripts: ScriptSummary[]; // List of marketplace scripts
}

export type ScriptsListMarketplaceScriptsResult = AdapterResultBase<ScriptMarketplaceListData>;

export interface ScriptMetricsData {
  scriptId: string; // Script ID
  totalExecutions: number; // Total number of executions
  totalCost: number; // Total cost in USD
  avgDuration: number; // Average duration in ms
  successRate: number; // Success rate (0-1)
  errorRate: number; // Error rate (0-1)
  lastExecutedAt: string; // Last execution timestamp (ISO 8601) or empty
}

export type ScriptsGetMetricsResult = AdapterResultBase<ScriptMetricsData>;

export interface ScriptWebhookData {
  scriptId: string; // Script ID
  webhookUrl: string; // Webhook URL endpoint
  webhookSecret: string; // Webhook secret for verification
  name: string; // Webhook name
  enabled: boolean; // Whether webhook is enabled
}

export type ScriptsCreateWebhookResult = AdapterResultBase<ScriptWebhookData>;

export interface ScriptScheduleData {
  scheduleId: string; // Schedule ID
  scriptId: string; // Script ID
  name: string; // Schedule name
  cronExpression: string; // Cron expression
  enabled: boolean; // Whether schedule is enabled
}

export type ScriptsCreateScheduleResult = AdapterResultBase<ScriptScheduleData>;

export interface ScriptFlowGetData {
  code: string; // Script source code
  version: number; // Active version number
  scriptId: string; // Script ID
  scriptName: string; // Script name
  description: string; // Script description
  isOwned: boolean; // Whether user owns the script
}

export type ScriptsGetFlowScriptResult = AdapterResultBase<ScriptFlowGetData>;

export interface ScriptFlowModifyData {
  copied: boolean; // Whether a copy was created (user did not own original)
  scriptId: string; // Script ID (new if copied, original if owned)
  versionId: string; // New version ID
  version: number; // New version number
}

export type ScriptsModifyFlowScriptResult = AdapterResultBase<ScriptFlowModifyData>;

export interface LintIssue {
  severity: string; // Issue severity (error, warning)
  message: string; // Issue description
  line: number; // Line number where issue was found
  suggestion: string; // Suggested fix
}

export interface ScriptLintData {
  valid: boolean; // Whether script is valid
  issueCount: number; // Number of issues found
  issues: LintIssue[]; // List of lint issues
  callAdapterCallsCount: number; // Number of callAdapter calls found
  mirraSDKCallsCount: number; // Number of mirra SDK calls found
}

export type ScriptsLintScriptResult = AdapterResultBase<ScriptLintData>;

// Feedback Response Types
export interface FeedbackReportBugData {
  id: string; // Unique identifier for the feedback report
  createdAt: string; // ISO 8601 timestamp when created
  source: string; // Source of the report: user_submitted or llm_auto_report
  type: 'bug'; // Report type indicator
  title: string; // Brief bug description
  severity: string; // Bug severity: critical, high, medium, or low
}

export type FeedbackReportBugResult = AdapterResultBase<FeedbackReportBugData>;

export interface FeedbackReportToolFailureData {
  id: string; // Unique identifier for the feedback report
  createdAt: string; // ISO 8601 timestamp when created
  source: string; // Source of the report: user_submitted or llm_auto_report
  type: 'tool_failure'; // Report type indicator
  adapterType: string; // Adapter type that failed
  operation: string; // Operation that failed
  errorMessage: string; // Error message from the failure
}

export type FeedbackReportToolFailureResult = AdapterResultBase<FeedbackReportToolFailureData>;

export interface FeedbackReportMissingCapabilityData {
  id: string; // Unique identifier for the feedback report
  createdAt: string; // ISO 8601 timestamp when created
  source: string; // Source of the report: user_submitted or llm_auto_report
  type: 'missing_capability'; // Report type indicator
  userRequest: string; // What the user asked for
  reason: string; // Why it could not be fulfilled
}

export type FeedbackReportMissingCapabilityResult = AdapterResultBase<FeedbackReportMissingCapabilityData>;

export interface FeedbackSubmitFeedbackData {
  id: string; // Unique identifier for the feedback report
  createdAt: string; // ISO 8601 timestamp when created
  source: string; // Source of the report: user_submitted or llm_auto_report
  type: 'feedback'; // Report type indicator
  sentiment: string; // Feedback sentiment: positive, negative, or neutral
  category: string | null; // Feedback category: ux, performance, feature, or general
}

export type FeedbackSubmitFeedbackResult = AdapterResultBase<FeedbackSubmitFeedbackData>;

export interface FeedbackSubmitFeatureRequestData {
  id: string; // Unique identifier for the feedback report
  createdAt: string; // ISO 8601 timestamp when created
  source: string; // Source of the report: user_submitted or llm_auto_report
  type: 'feature_request'; // Report type indicator
  title: string; // Feature title
  priority: string | null; // Priority: high, medium, or low
}

export type FeedbackSubmitFeatureRequestResult = AdapterResultBase<FeedbackSubmitFeatureRequestData>;

// Mirra Messaging Response Types
export interface MirraMessagingSendMessageData {
  messageId: string; // Sent message ID
  chatInstanceId: string; // Chat instance ID
  groupId: string; // Group ID
  content: string; // Message content
  timestamp: string; // Sent timestamp (ISO 8601)
  automationSource: string | null; // Automation source identifier
  automationSessionId: string | null; // Automation session ID
  automationFlowId: string | null; // Automation flow ID
  linkUrl: string; // Deep link URL to chat
  linkLabel: string; // Display label for link
}

export type MirraMessagingSendMessageResult = AdapterResultBase<MirraMessagingSendMessageData>;

export interface MirraMessagingUpdateMessageData {
  messageId: string; // Updated message ID
  chatInstanceId: string; // Chat instance ID
  groupId: string; // Group ID
  content: string; // Updated message content
  editedAt: string; // Edit timestamp (ISO 8601)
  editCount: number; // Total edit count
}

export type MirraMessagingUpdateMessageResult = AdapterResultBase<MirraMessagingUpdateMessageData>;

export interface MirraMessagingContact {
  contactId: string; // Contact record ID
  userId: string; // User ID
  username: string; // Username
  profilePhoto: string | null; // Profile photo URL
  groupId: string | null; // Direct chat group ID
  isContact: boolean; // Whether user is a contact
}

export interface MirraMessagingGetContactsData {
  contacts: MirraMessagingContact[]; // List of contacts
  totalCount: number; // Total available contacts
  limit: number; // Items per page
  offset: number; // Current offset
  hasMore: boolean; // Whether more items exist
}

export type MirraMessagingGetContactsResult = AdapterResultBase<MirraMessagingGetContactsData>;

export interface MirraMessagingFindContactData {
  contacts: MirraMessagingContact[]; // Matching contacts
  users: MirraMessagingContact[]; // Matching non-contact users
  query: string; // Search query used
  contactCount: number; // Number of matching contacts
  userCount: number; // Number of matching users
}

export type MirraMessagingFindContactResult = AdapterResultBase<MirraMessagingFindContactData>;

export interface MirraMessagingChat {
  chatInstanceId: string; // Chat instance ID
  title: string; // Chat title
  scope: 'direct' | 'user' | 'group'; // Chat scope type
  lastMessageAt: string | null; // Last message timestamp (ISO 8601)
  lastMessagePreview: string | null; // Last message preview text
  messageCount: number; // Total message count
  peerUserId: string | null; // Peer user ID (for direct chats)
  peerUsername: string | null; // Peer username
  peerProfilePhoto: string | null; // Peer profile photo URL
  groupId: string | null; // Group ID (for group chats)
  groupName: string | null; // Group name
  groupProfileImage: string | null; // Group profile image URL
}

export interface MirraMessagingGetChatsData {
  chats: MirraMessagingChat[]; // List of chat instances
  count: number; // Number of chats returned
}

export type MirraMessagingGetChatsResult = AdapterResultBase<MirraMessagingGetChatsData>;

export interface MirraMessagingGroup {
  groupId: string; // Group ID
  name: string; // Group name
  description: string | null; // Group description
  profileImage: string | null; // Group profile image URL
  role: string; // User role in group
  joinedAt: string; // Join timestamp (ISO 8601)
}

export interface MirraMessagingGetGroupsData {
  groups: MirraMessagingGroup[]; // List of groups
  count: number; // Number of groups returned
}

export type MirraMessagingGetGroupsResult = AdapterResultBase<MirraMessagingGetGroupsData>;

export interface MirraMessagingCreateGroupData {
  groupId: string; // Created group ID
  chatInstanceId: string; // Chat instance ID
  name: string; // Group name
  description: string | null; // Group description
  category: string; // Group category
  createdBy: string; // Creator user ID
  memberCount: number; // Initial member count
  createdAt: string; // Creation timestamp (ISO 8601)
  linkUrl: string; // Deep link URL to group chat
  linkLabel: string; // Display label for link
}

export type MirraMessagingCreateGroupResult = AdapterResultBase<MirraMessagingCreateGroupData>;

export interface MirraMessagingSearchMessage {
  messageId: string; // Message ID
  chatInstanceId: string; // Chat instance ID
  groupId: string | null; // Group ID
  groupName: string | null; // Group name
  senderId: string; // Sender user ID
  senderUsername: string; // Sender username
  snippet: string; // Message snippet around matched keywords
  text: string | null; // Full message text (if includeFullText=true)
  timestamp: string; // Message timestamp (ISO 8601)
  scope: 'direct' | 'group'; // Message scope
  relevanceScore: number; // Search relevance score
  isFromMe: boolean; // Whether message is from authenticated user
  chatType: 'direct' | 'group'; // Chat type
  messageLength: number; // Full message length in characters
}

export interface MirraMessagingSearchMessagesData {
  messages: MirraMessagingSearchMessage[]; // Matching messages
  totalCount: number; // Total matching messages
  limit: number; // Items per page
  offset: number; // Current offset
  hasMore: boolean; // Whether more results exist
  query: string; // Search query used
  summaryMode: boolean; // Whether results are in summary mode
}

export type MirraMessagingSearchMessagesResult = AdapterResultBase<MirraMessagingSearchMessagesData>;

// Moltbook Response Types
export interface MoltbookRegisterAgentData {
  agentName: string; // Registered agent name
  claimUrl: string; // URL to claim the agent
  verificationCode: string; // Verification code for claiming
  instructions: string; // Instructions for completing registration
}

export type MoltbookRegisterAgentResult = AdapterResultBase<MoltbookRegisterAgentData>;

export interface MoltbookCreatePostData {
  id: string; // Created post ID
  title: string; // Post title
  content: string; // Post content
  type: string; // Post type (text/link)
  url: string; // URL for link posts
  authorName: string; // Author name
  authorKarma: number; // Author karma score
  submolt: string; // Community name
  upvotes: number; // Upvote count
  downvotes: number; // Downvote count
  commentCount: number; // Comment count
  createdAt: string; // Creation timestamp (ISO 8601)
  score: number; // Calculated score
  hasTitle: boolean; // Whether post has a title
}

export type MoltbookCreatePostResult = AdapterResultBase<MoltbookCreatePostData>;

export interface MoltbookPostSummary {
  id: string; // Post ID
  title: string; // Post title
  content: string; // Post content
  type: string; // Post type (text/link)
  authorName: string; // Author name
  submolt: string; // Community name
  upvotes: number; // Upvote count
  downvotes: number; // Downvote count
  commentCount: number; // Number of comments
  createdAt: string; // Creation timestamp (ISO 8601)
  score: number; // Calculated score (upvotes - downvotes)
}

export interface MoltbookGetPostsData {
  count: number; // Number of posts returned
  posts: MoltbookPostSummary[]; // List of posts
}

export type MoltbookGetPostsResult = AdapterResultBase<MoltbookGetPostsData>;

export interface MoltbookGetPostData {
  id: string; // Post ID
  title: string; // Post title
  content: string; // Post content
  type: string; // Post type (text/link)
  url: string; // URL for link posts
  authorName: string; // Author name
  authorKarma: number; // Author karma score
  submolt: string; // Community name
  upvotes: number; // Upvote count
  downvotes: number; // Downvote count
  commentCount: number; // Comment count
  createdAt: string; // Creation timestamp (ISO 8601)
  score: number; // Calculated score
  hasTitle: boolean; // Whether post has a title
}

export type MoltbookGetPostResult = AdapterResultBase<MoltbookGetPostData>;

export interface MoltbookDeletePostData {
  postId: string; // Deleted post ID
  deleted: boolean; // Whether deletion succeeded
}

export type MoltbookDeletePostResult = AdapterResultBase<MoltbookDeletePostData>;

export interface MoltbookCreateCommentData {
  id: string; // Comment ID
  content: string; // Comment content
  authorName: string; // Author name
  authorKarma: number; // Author karma score
  parentId: string; // Parent comment ID (empty if top-level)
  upvotes: number; // Upvote count
  createdAt: string; // Creation timestamp (ISO 8601)
  isReply: boolean; // Whether this is a reply to another comment
}

export type MoltbookCreateCommentResult = AdapterResultBase<MoltbookCreateCommentData>;

export interface MoltbookComment {
  id: string; // Comment ID
  content: string; // Comment content
  authorName: string; // Author name
  authorKarma: number; // Author karma score
  parentId: string; // Parent comment ID (empty if top-level)
  upvotes: number; // Upvote count
  createdAt: string; // Creation timestamp (ISO 8601)
  isReply: boolean; // Whether this is a reply to another comment
}

export interface MoltbookGetCommentsData {
  postId: string; // Post ID
  count: number; // Number of comments
  comments: MoltbookComment[]; // List of comments
}

export type MoltbookGetCommentsResult = AdapterResultBase<MoltbookGetCommentsData>;

export interface MoltbookUpvotePostData {
  postId: string; // Post ID
  upvoted: boolean; // Whether upvote succeeded
}

export type MoltbookUpvotePostResult = AdapterResultBase<MoltbookUpvotePostData>;

export interface MoltbookDownvotePostData {
  postId: string; // Post ID
  downvoted: boolean; // Whether downvote succeeded
}

export type MoltbookDownvotePostResult = AdapterResultBase<MoltbookDownvotePostData>;

export interface MoltbookUpvoteCommentData {
  commentId: string; // Comment ID
  upvoted: boolean; // Whether upvote succeeded
}

export type MoltbookUpvoteCommentResult = AdapterResultBase<MoltbookUpvoteCommentData>;

export interface MoltbookCreateSubmoltData {
  name: string; // Community name
  description: string; // Community description
  memberCount: number; // Number of members
  postCount: number; // Number of posts
  createdAt: string; // Creation timestamp (ISO 8601)
  isPopular: boolean; // Whether community is popular (100+ members)
}

export type MoltbookCreateSubmoltResult = AdapterResultBase<MoltbookCreateSubmoltData>;

export interface MoltbookSubmolt {
  name: string; // Community name
  description: string; // Community description
  memberCount: number; // Number of members
  postCount: number; // Number of posts
  createdAt: string; // Creation timestamp (ISO 8601)
  isPopular: boolean; // Whether community is popular (100+ members)
}

export interface MoltbookGetSubmoltsData {
  count: number; // Number of communities
  submolts: MoltbookSubmolt[]; // List of communities
}

export type MoltbookGetSubmoltsResult = AdapterResultBase<MoltbookGetSubmoltsData>;

export interface MoltbookGetSubmoltData {
  name: string; // Community name
  description: string; // Community description
  memberCount: number; // Number of members
  postCount: number; // Number of posts
  createdAt: string; // Creation timestamp (ISO 8601)
  isPopular: boolean; // Whether community is popular (100+ members)
}

export type MoltbookGetSubmoltResult = AdapterResultBase<MoltbookGetSubmoltData>;

export interface MoltbookSubscribeData {
  submolt: string; // Community name
  subscribed: boolean; // Whether subscription succeeded
}

export type MoltbookSubscribeResult = AdapterResultBase<MoltbookSubscribeData>;

export interface MoltbookUnsubscribeData {
  submolt: string; // Community name
  unsubscribed: boolean; // Whether unsubscription succeeded
}

export type MoltbookUnsubscribeResult = AdapterResultBase<MoltbookUnsubscribeData>;

export interface MoltbookFollowAgentData {
  agent: string; // Agent name
  following: boolean; // Whether follow succeeded
}

export type MoltbookFollowAgentResult = AdapterResultBase<MoltbookFollowAgentData>;

export interface MoltbookUnfollowAgentData {
  agent: string; // Agent name
  unfollowed: boolean; // Whether unfollow succeeded
}

export type MoltbookUnfollowAgentResult = AdapterResultBase<MoltbookUnfollowAgentData>;

export interface MoltbookGetProfileData {
  name: string; // Agent name
  description: string; // Agent description
  karma: number; // Karma score
  postCount: number; // Number of posts
  commentCount: number; // Number of comments
  createdAt: string; // Registration timestamp (ISO 8601)
  claimed: boolean; // Whether agent is claimed/verified
  avatarUrl: string; // Avatar URL
  isActive: boolean; // Whether agent is active
}

export type MoltbookGetProfileResult = AdapterResultBase<MoltbookGetProfileData>;

export interface MoltbookGetMyProfileData {
  name: string; // Agent name
  description: string; // Agent description
  karma: number; // Karma score
  postCount: number; // Number of posts
  commentCount: number; // Number of comments
  createdAt: string; // Registration timestamp (ISO 8601)
  claimed: boolean; // Whether agent is claimed/verified
  avatarUrl: string; // Avatar URL
  isActive: boolean; // Whether agent is active
}

export type MoltbookGetMyProfileResult = AdapterResultBase<MoltbookGetMyProfileData>;

export interface MoltbookUpdateProfileData {
  name: string; // Agent name
  description: string; // Agent description
  karma: number; // Karma score
  postCount: number; // Number of posts
  commentCount: number; // Number of comments
  createdAt: string; // Registration timestamp (ISO 8601)
  claimed: boolean; // Whether agent is claimed/verified
  avatarUrl: string; // Avatar URL
  isActive: boolean; // Whether agent is active
}

export type MoltbookUpdateProfileResult = AdapterResultBase<MoltbookUpdateProfileData>;

export interface MoltbookGetFeedData {
  count: number; // Number of posts
  posts: MoltbookPostSummary[]; // List of posts
}

export type MoltbookGetFeedResult = AdapterResultBase<MoltbookGetFeedData>;

export interface MoltbookAgent {
  name: string; // Agent name
  description: string; // Agent description
  karma: number; // Karma score
  postCount: number; // Number of posts
  commentCount: number; // Number of comments
  createdAt: string; // Registration timestamp (ISO 8601)
  claimed: boolean; // Whether agent is claimed/verified
  avatarUrl: string; // Avatar URL
  isActive: boolean; // Whether agent is active
}

export interface MoltbookSearchData {
  query: string; // Search query
  postCount: number; // Number of matching posts
  agentCount: number; // Number of matching agents
  submoltCount: number; // Number of matching communities
  posts: MoltbookPostSummary[]; // Matching posts
  agents: MoltbookAgent[]; // Matching agents
  submolts: MoltbookSubmolt[]; // Matching communities
}

export type MoltbookSearchResult = AdapterResultBase<MoltbookSearchData>;

export interface MoltbookGetStatusData {
  status: string; // Status string (claimed/unclaimed)
  message: string; // Status message
  agentName: string; // Agent name
  isClaimed: boolean; // Whether agent is claimed
}

export type MoltbookGetStatusResult = AdapterResultBase<MoltbookGetStatusData>;

// Hypertrade Response Types
export interface HypertradePlaceOrderData {
  type: 'pending_order'; // Response type
  asset: string; // Asset/coin symbol
  isBuy: boolean; // Whether buying/longing
  size: number; // Order size
  limitPrice: number; // Limit price (0 for market)
  orderType: string; // Order type (limit/market)
  triggerPrice: number; // Trigger price (0 if none)
  reduceOnly: boolean; // Whether reduce-only
  postOnly: boolean; // Whether post-only
  clientOrderId: string; // Client order ID (empty if none)
  signerWallet: string; // Wallet address that needs to sign
  expiresAt: string; // Expiration timestamp (ISO 8601)
}

export type HypertradePlaceOrderResult = AdapterResultBase<HypertradePlaceOrderData>;

export interface HypertradeCancelOrderData {
  type: 'pending_cancel'; // Response type
  asset: string; // Asset/coin symbol
  orderId: number; // Order ID to cancel (0 if using clientOrderId)
  clientOrderId: string; // Client order ID to cancel (empty if using orderId)
  cancelAll: boolean; // Whether cancelling all orders for the asset
  signerWallet: string; // Wallet address that needs to sign
  expiresAt: string; // Expiration timestamp (ISO 8601)
}

export type HypertradeCancelOrderResult = AdapterResultBase<HypertradeCancelOrderData>;

export interface HypertradePosition {
  asset: string; // Asset/coin symbol
  size: number; // Position size (absolute value)
  entryPrice: number; // Entry price
  markPrice: number; // Current mark price
  unrealizedPnl: number; // Unrealized PnL
  leverage: number; // Current leverage
  liquidationPrice: number; // Liquidation price
  marginUsed: number; // Margin used for this position
  positionValue: number; // Total position value
  returnOnEquity: number; // Return on equity
  side: string; // Position side: "long" or "short"
}

export interface HypertradeGetPositionsData {
  positions: HypertradePosition[]; // List of open positions
}

export type HypertradeGetPositionsResult = AdapterResultBase<HypertradeGetPositionsData>;

export interface HypertradeOpenOrder {
  asset: string; // Asset/coin symbol
  orderId: number; // Order ID
  side: string; // Order side (Buy/Sell)
  size: number; // Current order size
  originalSize: number; // Original order size
  price: number; // Limit price
  orderType: string; // Order type
  reduceOnly: boolean; // Whether reduce-only
  timestamp: number; // Order creation timestamp
  triggerCondition: string; // Trigger condition
  triggerPrice: number; // Trigger price (0 if not trigger)
  isTrigger: boolean; // Whether this is a trigger order
}

export interface HypertradeGetOpenOrdersData {
  orders: HypertradeOpenOrder[]; // List of open orders
}

export type HypertradeGetOpenOrdersResult = AdapterResultBase<HypertradeGetOpenOrdersData>;

export interface HypertradeSpotBalance {
  coin: string; // Coin/token symbol
  total: number; // Total balance
  hold: number; // Balance on hold (in orders)
  available: number; // Available balance
}

export interface HypertradeGetBalancesData {
  accountValue: number; // Total account value
  totalMarginUsed: number; // Total margin used
  withdrawable: number; // Withdrawable amount
  perpEquity: number; // Perpetual equity
  spotBalances: HypertradeSpotBalance[]; // List of spot token balances
}

export type HypertradeGetBalancesResult = AdapterResultBase<HypertradeGetBalancesData>;

export interface HypertradeMarketInfo {
  asset: string; // Asset/coin symbol
  markPrice: number; // Mark price
  midPrice: number; // Mid price
  oraclePrice: number; // Oracle price
  openInterest: number; // Open interest
  funding: number; // Current funding rate
  dayVolume: number; // 24h notional volume
  prevDayPrice: number; // Previous day price
  maxLeverage: number; // Maximum allowed leverage
  szDecimals: number; // Size decimals for this asset
}

export interface HypertradeGetMarketInfoData {
  markets: HypertradeMarketInfo[]; // List of market info entries
}

export type HypertradeGetMarketInfoResult = AdapterResultBase<HypertradeGetMarketInfoData>;

export interface HypertradeOrderbookLevel {
  price: number; // Price level
  size: number; // Total size at this level
  numOrders: number; // Number of orders at this level
}

export interface HypertradeGetOrderbookData {
  asset: string; // Asset/coin symbol
  bids: HypertradeOrderbookLevel[]; // Bid levels (best first)
  asks: HypertradeOrderbookLevel[]; // Ask levels (best first)
  spread: number; // Best ask - best bid
  midPrice: number; // Mid price ((best ask + best bid) / 2)
  timestamp: number; // Snapshot timestamp
}

export type HypertradeGetOrderbookResult = AdapterResultBase<HypertradeGetOrderbookData>;

export interface HypertradeCandle {
  timestamp: number; // Candle open time in milliseconds
  open: number; // Open price
  high: number; // High price
  low: number; // Low price
  close: number; // Close price
  volume: number; // Volume
  numTrades: number; // Number of trades
}

export interface HypertradeGetCandlesData {
  asset: string; // Asset/coin symbol
  interval: string; // Candle interval
  candles: HypertradeCandle[]; // List of candles
}

export type HypertradeGetCandlesResult = AdapterResultBase<HypertradeGetCandlesData>;

export interface HypertradeSetLeverageData {
  type: 'pending_leverage'; // Response type
  asset: string; // Asset/coin symbol
  leverage: number; // Leverage multiplier
  leverageMode: string; // Leverage mode (cross/isolated)
  isCrossMargin: boolean; // Whether cross margin
  signerWallet: string; // Wallet address that needs to sign
  expiresAt: string; // Expiration timestamp (ISO 8601)
}

export type HypertradeSetLeverageResult = AdapterResultBase<HypertradeSetLeverageData>;

export interface HypertradeTradeFill {
  asset: string; // Asset/coin symbol
  tradeId: number; // Trade ID
  orderId: number; // Order ID
  side: string; // Trade side
  price: number; // Fill price
  size: number; // Fill size
  fee: number; // Fee amount
  feeToken: string; // Fee token
  closedPnl: number; // Realized PnL from this trade
  timestamp: number; // Trade timestamp
  direction: string; // Trade direction
  crossed: boolean; // Whether this was a taker fill
  hash: string; // Transaction hash
}

export interface HypertradeGetTradeHistoryData {
  trades: HypertradeTradeFill[]; // List of trade fills
}

export type HypertradeGetTradeHistoryResult = AdapterResultBase<HypertradeGetTradeHistoryData>;

// Shopify Response Types
export interface ShopifyNormalizedProduct {
  id: string; // Product ID
  title: string; // Product title
  bodyHtml: string; // HTML description
  vendor: string; // Vendor name
  productType: string; // Product type
  status: string; // Status (active, archived, draft)
  handle: string; // URL handle
  tags: string; // Comma-separated tags
  createdAt: string; // Creation timestamp (ISO 8601)
  updatedAt: string; // Last update timestamp (ISO 8601)
  publishedAt?: string; // Published timestamp (ISO 8601)
  variants: ShopifyVariant[]; // Product variants
  images: ShopifyImage[]; // Product images
}

export interface ShopifyListProductsData {
  products: ShopifyNormalizedProduct[]; // List of products
  nextPageInfo?: string; // Cursor for next page
  previousPageInfo?: string; // Cursor for previous page
  totalRetrieved: number; // Number of products retrieved
}

export type ShopifyListProductsResult = AdapterResultBase<ShopifyListProductsData>;

export interface ShopifyVariant {
  id: string; // Variant ID
  title: string; // Variant title
  price: string; // Price
  compareAtPrice?: string; // Compare-at price
  sku: string; // SKU
  inventoryQuantity: number; // Inventory quantity
  weight: number; // Weight
  weightUnit: string; // Weight unit (g, kg, lb, oz)
  option1?: string; // Option 1 value
  option2?: string; // Option 2 value
  option3?: string; // Option 3 value
  barcode?: string; // Barcode
  requiresShipping: boolean; // Requires shipping
  taxable: boolean; // Is taxable
}

export interface ShopifyImage {
  id: string; // Image ID
  src: string; // Image URL
  alt?: string; // Alt text
  width: number; // Width in pixels
  height: number; // Height in pixels
  position: number; // Display position
}

export interface ShopifyProductData {
  id: string; // Product ID
  title: string; // Product title
  bodyHtml: string; // HTML description
  vendor: string; // Vendor name
  productType: string; // Product type
  status: string; // Status (active, archived, draft)
  handle: string; // URL handle
  tags: string; // Comma-separated tags
  createdAt: string; // Creation timestamp (ISO 8601)
  updatedAt: string; // Last update timestamp (ISO 8601)
  publishedAt?: string; // Published timestamp (ISO 8601)
  variants: ShopifyVariant[]; // Product variants
  images: ShopifyImage[]; // Product images
}

export type ShopifyGetProductResult = AdapterResultBase<ShopifyProductData>;

export interface ShopifyProductData {
  id: string; // Product ID
  title: string; // Product title
  bodyHtml: string; // HTML description
  vendor: string; // Vendor name
  productType: string; // Product type
  status: string; // Status (active, archived, draft)
  handle: string; // URL handle
  tags: string; // Comma-separated tags
  createdAt: string; // Creation timestamp (ISO 8601)
  updatedAt: string; // Last update timestamp (ISO 8601)
  publishedAt?: string; // Published timestamp (ISO 8601)
  variants: ShopifyVariant[]; // Product variants
  images: ShopifyImage[]; // Product images
}

export type ShopifyCreateProductResult = AdapterResultBase<ShopifyProductData>;

export interface ShopifyProductData {
  id: string; // Product ID
  title: string; // Product title
  bodyHtml: string; // HTML description
  vendor: string; // Vendor name
  productType: string; // Product type
  status: string; // Status (active, archived, draft)
  handle: string; // URL handle
  tags: string; // Comma-separated tags
  createdAt: string; // Creation timestamp (ISO 8601)
  updatedAt: string; // Last update timestamp (ISO 8601)
  publishedAt?: string; // Published timestamp (ISO 8601)
  variants: ShopifyVariant[]; // Product variants
  images: ShopifyImage[]; // Product images
}

export type ShopifyUpdateProductResult = AdapterResultBase<ShopifyProductData>;

export interface ShopifyDeleteProductData {
  deleted: boolean; // Whether deletion was successful
  productId: string; // Deleted product ID
}

export type ShopifyDeleteProductResult = AdapterResultBase<ShopifyDeleteProductData>;

export interface ShopifyNormalizedOrder {
  id: string; // Order ID
  orderNumber: number; // Human-readable order number
  name: string; // Order name (e.g., #1001)
  email: string; // Customer email
  totalPrice: string; // Total price
  subtotalPrice: string; // Subtotal price
  totalTax: string; // Total tax
  totalDiscounts: string; // Total discounts
  currency: string; // Currency code (e.g., USD)
  financialStatus: string; // Financial status (paid, pending, etc.)
  fulfillmentStatus?: string; // Fulfillment status
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  closedAt?: string; // Closed timestamp
  cancelledAt?: string; // Cancelled timestamp
  cancelReason?: string; // Cancellation reason
  note?: string; // Order note
  tags: string; // Comma-separated tags
  customerFirstName: string; // Customer first name
  customerLastName: string; // Customer last name
  customerEmail: string; // Customer email
  lineItems: ShopifyLineItem[]; // Order line items
  totalLineItemsQuantity: number; // Total quantity of all line items
  shippingAddressCity?: string; // Shipping city
  shippingAddressCountry?: string; // Shipping country
}

export interface ShopifyListOrdersData {
  orders: ShopifyNormalizedOrder[]; // List of orders
  nextPageInfo?: string; // Cursor for next page
  previousPageInfo?: string; // Cursor for previous page
  totalRetrieved: number; // Number of orders retrieved
}

export type ShopifyListOrdersResult = AdapterResultBase<ShopifyListOrdersData>;

export interface ShopifyLineItem {
  id: string; // Line item ID
  title: string; // Product title
  quantity: number; // Quantity ordered
  price: string; // Unit price
  sku: string; // SKU
  variantTitle?: string; // Variant title
  vendor?: string; // Vendor
  productId?: string; // Product ID
  variantId?: string; // Variant ID
  fulfillmentStatus?: string; // Fulfillment status
}

export interface ShopifyOrderData {
  id: string; // Order ID
  orderNumber: number; // Human-readable order number
  name: string; // Order name (e.g., #1001)
  email: string; // Customer email
  totalPrice: string; // Total price
  subtotalPrice: string; // Subtotal price
  totalTax: string; // Total tax
  totalDiscounts: string; // Total discounts
  currency: string; // Currency code (e.g., USD)
  financialStatus: string; // Financial status (paid, pending, etc.)
  fulfillmentStatus?: string; // Fulfillment status
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  closedAt?: string; // Closed timestamp
  cancelledAt?: string; // Cancelled timestamp
  cancelReason?: string; // Cancellation reason
  note?: string; // Order note
  tags: string; // Comma-separated tags
  customerFirstName: string; // Customer first name
  customerLastName: string; // Customer last name
  customerEmail: string; // Customer email
  lineItems: ShopifyLineItem[]; // Order line items
  totalLineItemsQuantity: number; // Total quantity of all line items
  shippingAddressCity?: string; // Shipping city
  shippingAddressCountry?: string; // Shipping country
}

export type ShopifyGetOrderResult = AdapterResultBase<ShopifyOrderData>;

export interface ShopifyOrderData {
  id: string; // Order ID
  orderNumber: number; // Human-readable order number
  name: string; // Order name (e.g., #1001)
  email: string; // Customer email
  totalPrice: string; // Total price
  subtotalPrice: string; // Subtotal price
  totalTax: string; // Total tax
  totalDiscounts: string; // Total discounts
  currency: string; // Currency code (e.g., USD)
  financialStatus: string; // Financial status (paid, pending, etc.)
  fulfillmentStatus?: string; // Fulfillment status
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  closedAt?: string; // Closed timestamp
  cancelledAt?: string; // Cancelled timestamp
  cancelReason?: string; // Cancellation reason
  note?: string; // Order note
  tags: string; // Comma-separated tags
  customerFirstName: string; // Customer first name
  customerLastName: string; // Customer last name
  customerEmail: string; // Customer email
  lineItems: ShopifyLineItem[]; // Order line items
  totalLineItemsQuantity: number; // Total quantity of all line items
  shippingAddressCity?: string; // Shipping city
  shippingAddressCountry?: string; // Shipping country
}

export type ShopifyCreateOrderResult = AdapterResultBase<ShopifyOrderData>;

export interface ShopifyOrderData {
  id: string; // Order ID
  orderNumber: number; // Human-readable order number
  name: string; // Order name (e.g., #1001)
  email: string; // Customer email
  totalPrice: string; // Total price
  subtotalPrice: string; // Subtotal price
  totalTax: string; // Total tax
  totalDiscounts: string; // Total discounts
  currency: string; // Currency code (e.g., USD)
  financialStatus: string; // Financial status (paid, pending, etc.)
  fulfillmentStatus?: string; // Fulfillment status
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  closedAt?: string; // Closed timestamp
  cancelledAt?: string; // Cancelled timestamp
  cancelReason?: string; // Cancellation reason
  note?: string; // Order note
  tags: string; // Comma-separated tags
  customerFirstName: string; // Customer first name
  customerLastName: string; // Customer last name
  customerEmail: string; // Customer email
  lineItems: ShopifyLineItem[]; // Order line items
  totalLineItemsQuantity: number; // Total quantity of all line items
  shippingAddressCity?: string; // Shipping city
  shippingAddressCountry?: string; // Shipping country
}

export type ShopifyCancelOrderResult = AdapterResultBase<ShopifyOrderData>;

export interface ShopifyOrderData {
  id: string; // Order ID
  orderNumber: number; // Human-readable order number
  name: string; // Order name (e.g., #1001)
  email: string; // Customer email
  totalPrice: string; // Total price
  subtotalPrice: string; // Subtotal price
  totalTax: string; // Total tax
  totalDiscounts: string; // Total discounts
  currency: string; // Currency code (e.g., USD)
  financialStatus: string; // Financial status (paid, pending, etc.)
  fulfillmentStatus?: string; // Fulfillment status
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  closedAt?: string; // Closed timestamp
  cancelledAt?: string; // Cancelled timestamp
  cancelReason?: string; // Cancellation reason
  note?: string; // Order note
  tags: string; // Comma-separated tags
  customerFirstName: string; // Customer first name
  customerLastName: string; // Customer last name
  customerEmail: string; // Customer email
  lineItems: ShopifyLineItem[]; // Order line items
  totalLineItemsQuantity: number; // Total quantity of all line items
  shippingAddressCity?: string; // Shipping city
  shippingAddressCountry?: string; // Shipping country
}

export type ShopifyCloseOrderResult = AdapterResultBase<ShopifyOrderData>;

export interface ShopifyNormalizedCustomer {
  id: string; // Customer ID
  firstName: string; // First name
  lastName: string; // Last name
  email: string; // Email address
  phone?: string; // Phone number
  ordersCount: number; // Number of orders
  totalSpent: string; // Total amount spent
  tags: string; // Comma-separated tags
  state: string; // Account state
  verifiedEmail: boolean; // Whether email is verified
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  note?: string; // Customer note
  defaultAddressCity?: string; // Default address city
  defaultAddressCountry?: string; // Default address country
}

export interface ShopifyListCustomersData {
  customers: ShopifyNormalizedCustomer[]; // List of customers
  nextPageInfo?: string; // Cursor for next page
  previousPageInfo?: string; // Cursor for previous page
  totalRetrieved: number; // Number of customers retrieved
}

export type ShopifyListCustomersResult = AdapterResultBase<ShopifyListCustomersData>;

export interface ShopifyCustomerData {
  id: string; // Customer ID
  firstName: string; // First name
  lastName: string; // Last name
  email: string; // Email address
  phone?: string; // Phone number
  ordersCount: number; // Number of orders
  totalSpent: string; // Total amount spent
  tags: string; // Comma-separated tags
  state: string; // Account state
  verifiedEmail: boolean; // Whether email is verified
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  note?: string; // Customer note
  defaultAddressCity?: string; // Default address city
  defaultAddressCountry?: string; // Default address country
}

export type ShopifyGetCustomerResult = AdapterResultBase<ShopifyCustomerData>;

export interface ShopifyCustomerData {
  id: string; // Customer ID
  firstName: string; // First name
  lastName: string; // Last name
  email: string; // Email address
  phone?: string; // Phone number
  ordersCount: number; // Number of orders
  totalSpent: string; // Total amount spent
  tags: string; // Comma-separated tags
  state: string; // Account state
  verifiedEmail: boolean; // Whether email is verified
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  note?: string; // Customer note
  defaultAddressCity?: string; // Default address city
  defaultAddressCountry?: string; // Default address country
}

export type ShopifyCreateCustomerResult = AdapterResultBase<ShopifyCustomerData>;

export interface ShopifyCustomerData {
  id: string; // Customer ID
  firstName: string; // First name
  lastName: string; // Last name
  email: string; // Email address
  phone?: string; // Phone number
  ordersCount: number; // Number of orders
  totalSpent: string; // Total amount spent
  tags: string; // Comma-separated tags
  state: string; // Account state
  verifiedEmail: boolean; // Whether email is verified
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  note?: string; // Customer note
  defaultAddressCity?: string; // Default address city
  defaultAddressCountry?: string; // Default address country
}

export type ShopifyUpdateCustomerResult = AdapterResultBase<ShopifyCustomerData>;

export interface ShopifySearchCustomersData {
  customers: ShopifyNormalizedCustomer[]; // Search results
  totalRetrieved: number; // Number of customers found
}

export type ShopifySearchCustomersResult = AdapterResultBase<ShopifySearchCustomersData>;

export interface ShopifyNormalizedInventoryLevel {
  inventoryItemId: string; // Inventory item ID
  locationId: string; // Location ID
  available?: number; // Available quantity
  updatedAt: string; // Last update timestamp
}

export interface ShopifyInventoryLevelsData {
  inventoryLevels: ShopifyNormalizedInventoryLevel[]; // Inventory levels
  totalRetrieved: number; // Number of levels retrieved
}

export type ShopifyGetInventoryLevelsResult = AdapterResultBase<ShopifyInventoryLevelsData>;

export interface ShopifyInventoryLevelData {
  inventoryItemId: string; // Inventory item ID
  locationId: string; // Location ID
  available?: number; // Available quantity
  updatedAt: string; // Last update timestamp
}

export type ShopifyAdjustInventoryResult = AdapterResultBase<ShopifyInventoryLevelData>;

export interface ShopifyNormalizedCollection {
  id: string; // Collection ID
  title: string; // Collection title
  bodyHtml: string; // HTML description
  handle: string; // URL handle
  sortOrder: string; // Sort order
  publishedAt?: string; // Published timestamp
  updatedAt: string; // Last update timestamp
  collectionType: string; // Type: "custom" or "smart"
  imageUrl?: string; // Collection image URL
  imageAlt?: string; // Image alt text
}

export interface ShopifyListCollectionsData {
  collections: ShopifyNormalizedCollection[]; // List of collections
  totalRetrieved: number; // Number of collections retrieved
}

export type ShopifyListCollectionsResult = AdapterResultBase<ShopifyListCollectionsData>;

export interface ShopifyNormalizedPage {
  id: string; // Page ID
  title: string; // Page title
  handle: string; // URL handle
  bodyHtml: string; // HTML content
  author: string; // Author name
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  publishedAt?: string; // Published timestamp
  templateSuffix?: string; // Template suffix
}

export interface ShopifyListPagesData {
  pages: ShopifyNormalizedPage[]; // List of pages
  nextPageInfo?: string; // Cursor for next page
  previousPageInfo?: string; // Cursor for previous page
  totalRetrieved: number; // Number of pages retrieved
}

export type ShopifyListPagesResult = AdapterResultBase<ShopifyListPagesData>;

export interface ShopifyPageData {
  id: string; // Page ID
  title: string; // Page title
  handle: string; // URL handle
  bodyHtml: string; // HTML content
  author: string; // Author name
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  publishedAt?: string; // Published timestamp
  templateSuffix?: string; // Template suffix
}

export type ShopifyGetPageResult = AdapterResultBase<ShopifyPageData>;

export interface ShopifyPageData {
  id: string; // Page ID
  title: string; // Page title
  handle: string; // URL handle
  bodyHtml: string; // HTML content
  author: string; // Author name
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  publishedAt?: string; // Published timestamp
  templateSuffix?: string; // Template suffix
}

export type ShopifyCreatePageResult = AdapterResultBase<ShopifyPageData>;

export interface ShopifyPageData {
  id: string; // Page ID
  title: string; // Page title
  handle: string; // URL handle
  bodyHtml: string; // HTML content
  author: string; // Author name
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  publishedAt?: string; // Published timestamp
  templateSuffix?: string; // Template suffix
}

export type ShopifyUpdatePageResult = AdapterResultBase<ShopifyPageData>;

export interface ShopifyDeletePageData {
  deleted: boolean; // Whether deletion was successful
  pageId: string; // Deleted page ID
}

export type ShopifyDeletePageResult = AdapterResultBase<ShopifyDeletePageData>;

export interface ShopifyNormalizedBlog {
  id: string; // Blog ID
  title: string; // Blog title
  handle: string; // URL handle
  commentable: string; // Comment policy
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  tags: string; // Comma-separated tags
}

export interface ShopifyListBlogsData {
  blogs: ShopifyNormalizedBlog[]; // List of blogs
  nextPageInfo?: string; // Cursor for next page
  previousPageInfo?: string; // Cursor for previous page
  totalRetrieved: number; // Number of blogs retrieved
}

export type ShopifyListBlogsResult = AdapterResultBase<ShopifyListBlogsData>;

export interface ShopifyBlogData {
  id: string; // Blog ID
  title: string; // Blog title
  handle: string; // URL handle
  commentable: string; // Comment policy
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  tags: string; // Comma-separated tags
}

export type ShopifyGetBlogResult = AdapterResultBase<ShopifyBlogData>;

export interface ShopifyBlogData {
  id: string; // Blog ID
  title: string; // Blog title
  handle: string; // URL handle
  commentable: string; // Comment policy
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  tags: string; // Comma-separated tags
}

export type ShopifyCreateBlogResult = AdapterResultBase<ShopifyBlogData>;

export interface ShopifyBlogData {
  id: string; // Blog ID
  title: string; // Blog title
  handle: string; // URL handle
  commentable: string; // Comment policy
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  tags: string; // Comma-separated tags
}

export type ShopifyUpdateBlogResult = AdapterResultBase<ShopifyBlogData>;

export interface ShopifyDeleteBlogData {
  deleted: boolean; // Whether deletion was successful
  blogId: string; // Deleted blog ID
}

export type ShopifyDeleteBlogResult = AdapterResultBase<ShopifyDeleteBlogData>;

export interface ShopifyNormalizedArticle {
  id: string; // Article ID
  blogId: string; // Parent blog ID
  title: string; // Article title
  author: string; // Author name
  handle: string; // URL handle
  bodyHtml: string; // HTML content
  summary: string; // Article summary
  tags: string; // Comma-separated tags
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  publishedAt?: string; // Published timestamp
  imageUrl?: string; // Image URL
  imageAlt?: string; // Image alt text
}

export interface ShopifyListArticlesData {
  articles: ShopifyNormalizedArticle[]; // List of articles
  nextPageInfo?: string; // Cursor for next page
  previousPageInfo?: string; // Cursor for previous page
  totalRetrieved: number; // Number of articles retrieved
}

export type ShopifyListArticlesResult = AdapterResultBase<ShopifyListArticlesData>;

export interface ShopifyArticleData {
  id: string; // Article ID
  blogId: string; // Parent blog ID
  title: string; // Article title
  author: string; // Author name
  handle: string; // URL handle
  bodyHtml: string; // HTML content
  summary: string; // Article summary
  tags: string; // Comma-separated tags
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  publishedAt?: string; // Published timestamp
  imageUrl?: string; // Image URL
  imageAlt?: string; // Image alt text
}

export type ShopifyGetArticleResult = AdapterResultBase<ShopifyArticleData>;

export interface ShopifyArticleData {
  id: string; // Article ID
  blogId: string; // Parent blog ID
  title: string; // Article title
  author: string; // Author name
  handle: string; // URL handle
  bodyHtml: string; // HTML content
  summary: string; // Article summary
  tags: string; // Comma-separated tags
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  publishedAt?: string; // Published timestamp
  imageUrl?: string; // Image URL
  imageAlt?: string; // Image alt text
}

export type ShopifyCreateArticleResult = AdapterResultBase<ShopifyArticleData>;

export interface ShopifyArticleData {
  id: string; // Article ID
  blogId: string; // Parent blog ID
  title: string; // Article title
  author: string; // Author name
  handle: string; // URL handle
  bodyHtml: string; // HTML content
  summary: string; // Article summary
  tags: string; // Comma-separated tags
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  publishedAt?: string; // Published timestamp
  imageUrl?: string; // Image URL
  imageAlt?: string; // Image alt text
}

export type ShopifyUpdateArticleResult = AdapterResultBase<ShopifyArticleData>;

export interface ShopifyDeleteArticleData {
  deleted: boolean; // Whether deletion was successful
  articleId: string; // Deleted article ID
}

export type ShopifyDeleteArticleResult = AdapterResultBase<ShopifyDeleteArticleData>;

export interface ShopifyNormalizedTheme {
  id: string; // Theme ID
  name: string; // Theme name
  role: string; // Theme role (main, unpublished, demo)
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  processing: boolean; // Whether theme is being processed
}

export interface ShopifyListThemesData {
  themes: ShopifyNormalizedTheme[]; // List of themes
  totalRetrieved: number; // Number of themes retrieved
}

export type ShopifyListThemesResult = AdapterResultBase<ShopifyListThemesData>;

export interface ShopifyThemeData {
  id: string; // Theme ID
  name: string; // Theme name
  role: string; // Theme role (main, unpublished, demo)
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  processing: boolean; // Whether theme is being processed
}

export type ShopifyGetThemeResult = AdapterResultBase<ShopifyThemeData>;

export interface ShopifyThemeData {
  id: string; // Theme ID
  name: string; // Theme name
  role: string; // Theme role (main, unpublished, demo)
  createdAt: string; // Creation timestamp
  updatedAt: string; // Last update timestamp
  processing: boolean; // Whether theme is being processed
}

export type ShopifyPublishThemeResult = AdapterResultBase<ShopifyThemeData>;

export interface ShopifyNormalizedThemeFile {
  filename: string; // File path
  contentType: string; // MIME type
  size: number; // File size in bytes
  checksumMd5?: string; // MD5 checksum
  body?: string; // File content
}

export interface ShopifyListThemeFilesData {
  files: ShopifyNormalizedThemeFile[]; // List of theme files
  totalRetrieved: number; // Number of files retrieved
}

export type ShopifyListThemeFilesResult = AdapterResultBase<ShopifyListThemeFilesData>;

export interface ShopifyThemeFileData {
  filename: string; // File path
  contentType: string; // MIME type
  size: number; // File size in bytes
  checksumMd5?: string; // MD5 checksum
  body?: string; // File content
}

export type ShopifyGetThemeFileResult = AdapterResultBase<ShopifyThemeFileData>;

export interface ShopifyUpsertThemeFilesData {
  upsertedFiles: string[]; // List of upserted file paths
  totalUpserted: number; // Number of files upserted
}

export type ShopifyUpsertThemeFilesResult = AdapterResultBase<ShopifyUpsertThemeFilesData>;

export interface ShopifyDeleteThemeFilesData {
  deletedFiles: string[]; // List of deleted file paths
  totalDeleted: number; // Number of files deleted
}

export type ShopifyDeleteThemeFilesResult = AdapterResultBase<ShopifyDeleteThemeFilesData>;

export interface ShopifyNormalizedMenu {
  id: string; // Menu ID
  title: string; // Menu title
  handle: string; // URL handle
}

export interface ShopifyListMenusData {
  menus: ShopifyNormalizedMenu[]; // List of menus
  nextPageInfo?: string; // Cursor for next page
  previousPageInfo?: string; // Cursor for previous page
  totalRetrieved: number; // Number of menus retrieved
}

export type ShopifyListMenusResult = AdapterResultBase<ShopifyListMenusData>;

export interface ShopifyMenuData {
  id: string; // Menu ID
  title: string; // Menu title
  handle: string; // URL handle
}

export type ShopifyGetMenuResult = AdapterResultBase<ShopifyMenuData>;

export interface ShopifyMenuData {
  id: string; // Menu ID
  title: string; // Menu title
  handle: string; // URL handle
}

export type ShopifyCreateMenuResult = AdapterResultBase<ShopifyMenuData>;

export interface ShopifyMenuData {
  id: string; // Menu ID
  title: string; // Menu title
  handle: string; // URL handle
}

export type ShopifyUpdateMenuResult = AdapterResultBase<ShopifyMenuData>;

export interface ShopifyDeleteMenuData {
  deleted: boolean; // Whether deletion was successful
  menuId: string; // Deleted menu ID
}

export type ShopifyDeleteMenuResult = AdapterResultBase<ShopifyDeleteMenuData>;

export interface ShopifyNormalizedRedirect {
  id: string; // Redirect ID
  path: string; // Source path
  target: string; // Target URL
}

export interface ShopifyListRedirectsData {
  redirects: ShopifyNormalizedRedirect[]; // List of redirects
  nextPageInfo?: string; // Cursor for next page
  previousPageInfo?: string; // Cursor for previous page
  totalRetrieved: number; // Number of redirects retrieved
}

export type ShopifyListRedirectsResult = AdapterResultBase<ShopifyListRedirectsData>;

export interface ShopifyRedirectData {
  id: string; // Redirect ID
  path: string; // Source path
  target: string; // Target URL
}

export type ShopifyCreateRedirectResult = AdapterResultBase<ShopifyRedirectData>;

export interface ShopifyRedirectData {
  id: string; // Redirect ID
  path: string; // Source path
  target: string; // Target URL
}

export type ShopifyUpdateRedirectResult = AdapterResultBase<ShopifyRedirectData>;

export interface ShopifyDeleteRedirectData {
  deleted: boolean; // Whether deletion was successful
  redirectId: string; // Deleted redirect ID
}

export type ShopifyDeleteRedirectResult = AdapterResultBase<ShopifyDeleteRedirectData>;


// ============================================================================
// Adapter Factory Functions
// ============================================================================

/**
 * Flows Adapter
 * Category: internal
 */
function createFlowsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a flow (event-triggered or time-scheduled). This is the unified, simplified interface for flow creation.

TRIGGER TYPE (provide exactly one):
- schedule: Cron expression for time-based flows (e.g., "0 9 * * *"). Times are automatically in the user's local timezone.
- eventType: Event type shorthand for event flows (e.g., "telegram.message")
- eventFilter: Full filter object for complex event conditions
- trigger: Legacy nested structure (still supported)

SCRIPT (provide exactly one):
- code: Inline script code - will auto-create, deploy, and link the script
- scriptId: ID of an existing deployed script

EXAMPLES:

Time flow with inline code:
{
  title: "Daily Report",
  schedule: "0 9 * * *",
  code: "export async function handler(event, context, mirra) { await mirra.telegram.sendMessage({...}); return { done: true }; }"
}

Event flow with eventType shorthand:
{
  title: "Handle Messages",
  eventType: "telegram.message",
  code: "export async function handler(event, context, mirra) { return { handled: true }; }"
}

Event flow with existing script:
{
  eventType: "gmail.email_received",
  scriptId: "existing-script-id"
}

HANDLER RETURN VALUES:
The handler's return object controls how the flow executor records the result:

Success — work was done:
  return { success: true, ...data }

No-Op — nothing to do (not an error):
  return { success: false, noOp: true, reason: "No transcript available" }
  Use when the handler correctly determines no action is needed (e.g., no input data,
  content already processed, empty trigger). No-ops are recorded as successful executions
  and do NOT count toward the 3-consecutive-failure auto-pause threshold.

Failure — something went wrong:
  return { success: false, reason: "What went wrong" }
  Use for actual errors. 3 consecutive failures will auto-pause the flow.
     * @param args.title - Flow title. Required if providing inline code. (optional)
     * @param args.description - Detailed description of what the flow does (optional)
     * @param args.code - Inline script code. If provided, auto-creates, deploys, and links the script. Cannot use with scriptId. (optional)
     * @param args.scriptId - ID of existing deployed script. Cannot use with code. (optional)
     * @param args.schedule - Cron expression for time-based flows. Times are automatically evaluated in the user's local timezone. Example: "0 9 * * *" runs at 9am in the user's timezone. (optional)
     * @param args.eventType - Event type shorthand (e.g., "telegram.message", "gmail.email_received"). Creates an eventFilter matching this type. (optional)
     * @param args.eventFilter - Full event filter with operator and conditions array for complex filtering. (optional)
     * @param args.trigger - Legacy nested trigger structure. Prefer eventType or eventFilter instead. (optional)
     * @param args.scriptInput - Static input data passed to the script. Fields are spread into event.data, so scriptInput: { apiKey: "sk-123" } is accessed as event.data.apiKey in handler code. The linter validates code against these fields. (optional)
     * @param args.scriptInputSchema - Schema describing scriptInput fields (auto-inferred from scriptInput values if not provided). Keys are field names, values are { type: "string"|"number"|"boolean"|"object"|"array", required?: boolean, description?: string }. When provided, the linter can catch typos in event.data.fieldName access as errors instead of warnings. (optional)
     * @param args.enabled - Whether the flow is enabled (default: true) (optional)
     * @returns Promise<FlowsCreateFlowResult> Typed response with IDE autocomplete
     */
    createFlow: async (args: FlowsCreateFlowArgs): Promise<FlowsCreateFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'createFlow',
        params: args || {}
      });
    },

    /**
     * Create a new time-based flow with cron schedule. NOTE: Consider using createFlow instead for a simpler interface with inline code support.
     * @param args.title - Flow title
     * @param args.description - Detailed description of what the flow does
     * @param args.schedule - Cron expression for scheduling (e.g., "0 9 * * *" for daily at 9am)
     * @param args.scriptId - ID of the script to execute when triggered
     * @param args.scriptInput - Static input data passed to the script. Fields are spread into event.data (e.g., scriptInput: { apiKey: "sk-123" } → event.data.apiKey in handler). (optional)
     * @param args.scriptInputSchema - Schema describing scriptInput fields (auto-inferred from scriptInput values if not provided). Keys are field names, values are { type, required?, description? }. (optional)
     * @returns Promise<FlowsCreateTimeFlowResult> Typed response with IDE autocomplete
     */
    createTimeFlow: async (args: FlowsCreateTimeFlowArgs): Promise<FlowsCreateTimeFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'createTimeFlow',
        params: args || {}
      });
    },

    /**
     * Create an event-based flow with pre-filtering conditions. NOTE: Consider using createFlow instead for a simpler interface with inline code support.

EFFICIENCY RULE: Always filter in eventFilter, not the script.
- eventFilter conditions: FREE (evaluated in-memory before script runs)
- Script filtering: EXPENSIVE (invokes Lambda for every event)

BAD: Trigger on "telegram.message" with no filter → script checks sender
GOOD: Trigger on "telegram.message" with eventFilter for sender

TRIGGER STRUCTURE:
{
  type: "event",
  config: {
    eventFilter: {
      operator: "and" | "or",
      conditions: [
        { operator: "equals", field: "type", value: "call.ended" },
        { operator: "contains", field: "content.text", value: "urgent" }
      ]
    }
  }
}

IMPORTANT: Use field: "type" (not "eventType") to filter by event type. This is required for testFlow to auto-generate test events.

VALID OPERATORS: equals, notEquals, contains, startsWith, endsWith, greaterThan, lessThan, exists, notExists, matchesRegex, and, or, not

COMMON EVENT TYPES (use with field: "type"): call.started, call.ended, call.action, telegram.message, gmail.email_received
     * @param args.title - Flow title
     * @param args.description - Detailed description of what the flow does
     * @param args.trigger - Event filter conditions that determine WHEN the script runs. Add ALL filtering logic here to minimize Lambda invocations. Must have type:"event" and config.eventFilter with operator and conditions array.
     * @param args.scriptId - ID of the script to execute when triggered
     * @param args.scriptInput - Static input data passed to the script. Fields are spread into event.data (e.g., scriptInput: { apiKey: "sk-123" } → event.data.apiKey in handler). (optional)
     * @param args.scriptInputSchema - Schema describing scriptInput fields (auto-inferred from scriptInput values if not provided). Keys are field names, values are { type, required?, description? }. (optional)
     * @returns Promise<FlowsCreateEventFlowResult> Typed response with IDE autocomplete
     */
    createEventFlow: async (args: FlowsCreateEventFlowArgs): Promise<FlowsCreateEventFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'createEventFlow',
        params: args || {}
      });
    },

    /**
     * List all flows for the user. Returns normalized flow summaries.
     * @param args.status - Filter by status: active, paused, completed, failed (optional)
     * @returns Promise<FlowsListFlowsResult> Typed response with IDE autocomplete
     */
    listFlows: async (args: FlowsListFlowsArgs): Promise<FlowsListFlowsResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'listFlows',
        params: args || {}
      });
    },

    /**
     * Get a specific flow by ID. Returns normalized flat structure.
     * @param args.id - Flow ID
     * @returns Promise<FlowsGetFlowResult> Typed response with IDE autocomplete
     */
    getFlow: async (args: FlowsGetFlowArgs): Promise<FlowsGetFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'getFlow',
        params: args || {}
      });
    },

    /**
     * Update an existing flow. Returns normalized flat structure.
     * @param args.id - Flow ID to update
     * @param args.title - New title (optional)
     * @param args.description - New description (optional)
     * @param args.trigger - New trigger configuration (optional)
     * @param args.scriptId - New script ID (optional)
     * @param args.scriptInput - New static input data for the script. Fields are spread into event.data in handler code. (optional)
     * @param args.scriptInputSchema - Schema describing scriptInput fields. Keys are field names, values are { type, required?, description? }. (optional)
     * @param args.status - New status: active, paused, completed, failed (optional)
     * @returns Promise<FlowsUpdateFlowResult> Typed response with IDE autocomplete
     */
    updateFlow: async (args: FlowsUpdateFlowArgs): Promise<FlowsUpdateFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'updateFlow',
        params: args || {}
      });
    },

    /**
     * Delete a flow
     * @param args.id - Flow ID to delete
     * @returns Promise<FlowsDeleteFlowResult> Typed response with IDE autocomplete
     */
    deleteFlow: async (args: FlowsDeleteFlowArgs): Promise<FlowsDeleteFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'deleteFlow',
        params: args || {}
      });
    },

    /**
     * Pause an active flow. Returns normalized flat structure.
     * @param args.id - Flow ID to pause
     * @returns Promise<FlowsPauseFlowResult> Typed response with IDE autocomplete
     */
    pauseFlow: async (args: FlowsPauseFlowArgs): Promise<FlowsPauseFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'pauseFlow',
        params: args || {}
      });
    },

    /**
     * Resume a paused flow. Returns normalized flat structure.
     * @param args.id - Flow ID to resume
     * @returns Promise<FlowsResumeFlowResult> Typed response with IDE autocomplete
     */
    resumeFlow: async (args: FlowsResumeFlowArgs): Promise<FlowsResumeFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'resumeFlow',
        params: args || {}
      });
    },

    /**
     * Search flows with filters. Returns normalized flow summaries.
     * @param args.status - Filter by status (or array of statuses) (optional)
     * @param args.triggerType - Filter by trigger type: time or event (optional)
     * @param args.limit - Maximum number of results (default: 100) (optional)
     * @param args.offset - Pagination offset (default: 0) (optional)
     * @returns Promise<FlowsSearchFlowsResult> Typed response with IDE autocomplete
     */
    searchFlows: async (args: FlowsSearchFlowsArgs): Promise<FlowsSearchFlowsResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'searchFlows',
        params: args || {}
      });
    },

    /**
     * Record execution result for a flow. Returns normalized flat structure.
     * @param args.id - Flow ID
     * @param args.success - Whether execution succeeded
     * @param args.result - Execution result data (optional)
     * @param args.error - Error message if execution failed (optional)
     * @returns Promise<FlowsRecordExecutionResult> Typed response with IDE autocomplete
     */
    recordExecution: async (args: FlowsRecordExecutionArgs): Promise<FlowsRecordExecutionResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'recordExecution',
        params: args || {}
      });
    },

    /**
     * List all available event types that can trigger automations. Returns normalized event types.

IMPORTANT: Use includeSchema: true when writing scripts to see available fields and correct access patterns.

Scripts receive an ExecutionRequest, NOT the raw IntegrationEvent. Correct access patterns:
- event.data.text (normalized text content)
- event.data.sender (normalized sender name)
- event.data.event (full IntegrationEvent object)
- event.trigger.event (also full IntegrationEvent)

Common WRONG patterns that don't work:
- event.summary (doesn't exist)
- event.content.text (wrong path)
- event.timestamp (wrong path)
     * @param args.includeTemplates - Include condition templates for each event type (optional)
     * @param args.includeSchema - Include field schema showing available paths for script access. RECOMMENDED when writing scripts to see correct field access patterns. (optional)
     * @returns Promise<FlowsListEventTypesResult> Typed response with IDE autocomplete
     */
    listEventTypes: async (args: FlowsListEventTypesArgs): Promise<FlowsListEventTypesResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'listEventTypes',
        params: args || {}
      });
    },

    /**
     * Test a flow by generating an event that matches the trigger conditions.

REQUIREMENT: The flow's trigger conditions MUST include a condition with field: "type" or field: "source" so the system knows what kind of test event to generate.

CORRECT condition: { operator: "equals", field: "type", value: "telegram.message" }
WRONG condition: { operator: "equals", field: "eventType", value: "telegram.message" }

If your flow lacks a "type" or "source" condition, use validateTrigger instead with a manually constructed event.

MODES:
- dryRun=true (DEFAULT): Validates trigger matching only. Safe, no side effects, no token consumption.
- dryRun=false: Executes the real script. WARNING: This causes real side effects (sends messages, makes API calls, consumes tokens).

Use dryRun=true first to verify trigger conditions work, then dryRun=false only when ready to test full execution.

WORKFLOW:
1. Generates a test event from the flow's trigger conditions (requires "type" or "source" field)
2. Validates the event matches the trigger (always)
3. If dryRun=false, executes the script with the test event

RESULT:
Returns detailed information about trigger matching, including which conditions passed/failed, and optionally full execution results.
     * @param args.flowId - ID of the flow to test
     * @param args.dryRun - If true (default), only validate trigger matching without executing script. If false, execute the script (causes side effects). (optional)
     * @param args.eventOverrides - Custom field values to merge into the generated test event (e.g., {"content.text": "custom message"}) (optional)
     * @returns Promise<FlowsTestFlowResult> Typed response with IDE autocomplete
     */
    testFlow: async (args: FlowsTestFlowArgs): Promise<FlowsTestFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'testFlow',
        params: args || {}
      });
    },

    /**
     * Check if a custom event would match a flow trigger without any execution. Useful for debugging trigger conditions or testing with real event data.
     * @param args.flowId - ID of the flow
     * @param args.event - Event object to test against the trigger (must match IntegrationEvent structure)
     * @returns Promise<FlowsValidateTriggerResult> Typed response with IDE autocomplete
     */
    validateTrigger: async (args: FlowsValidateTriggerArgs): Promise<FlowsValidateTriggerResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'validateTrigger',
        params: args || {}
      });
    },

    /**
     * Get all active flows that are triggered by a specific event type. Used by frontend to show flow selection for targeted execution (e.g., call.action flows).
     * @param args.eventType - Event type to filter by (e.g., "call.action", "call.ended", "telegram.message")
     * @returns Promise<FlowsGetFlowsByEventTypeResult> Typed response with IDE autocomplete
     */
    getFlowsByEventType: async (args: FlowsGetFlowsByEventTypeArgs): Promise<FlowsGetFlowsByEventTypeResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'getFlowsByEventType',
        params: args || {}
      });
    },

    /**
     * Create a self-managing flow that processes multiple adapter operations over time, respecting rate limits. The flow automatically cleans up when complete and notifies the user via feed item.
     * @param args.title - Human-readable title for this batch operation (e.g., "Leave 100 Telegram groups")
     * @param args.operations - Array of operations to execute. Each item must have adapter, operation, and args properties.
     * @param args.batchSize - Number of operations to process per execution (default: 5) (optional)
     * @param args.intervalSeconds - Seconds between batch executions (default: 60, minimum: 60) (optional)
     * @returns Promise<FlowsCreateBatchOperationResult> Typed response with IDE autocomplete
     */
    createBatchOperation: async (args: FlowsCreateBatchOperationArgs): Promise<FlowsCreateBatchOperationResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'createBatchOperation',
        params: args || {}
      });
    },

    /**
     * Publish a flow to the marketplace so other users can discover and install it. The flow must have a deployed script.
     * @param args.flowId - ID of the flow to publish
     * @param args.pricing - Pricing configuration. Defaults to { model: "free" }. Supported models: "free", "pay-per-execution". For paid models, include basePrice. (optional)
     * @param args.tags - Tags for marketplace discovery (e.g., ["telegram", "automation"]) (optional)
     * @param args.category - Marketplace category (e.g., "messaging", "productivity"). Defaults to "uncategorized". (optional)
     * @returns Promise<FlowsPublishFlowResult> Typed response with IDE autocomplete
     */
    publishFlow: async (args: FlowsPublishFlowArgs): Promise<FlowsPublishFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'publishFlow',
        params: args || {}
      });
    },

    /**
     * Remove a flow from the marketplace. Existing installations will continue to work.
     * @param args.flowId - ID of the flow to unpublish
     * @returns Promise<FlowsUnpublishFlowResult> Typed response with IDE autocomplete
     */
    unpublishFlow: async (args: FlowsUnpublishFlowArgs): Promise<FlowsUnpublishFlowResult> => {
      return sdk.resources.call({
        resourceId: 'flows',
        method: 'unpublishFlow',
        params: args || {}
      });
    }
  };
}

/**
 * User Adapter
 * Category: internal
 */
function createUserAdapter(sdk: MirraSDK) {
  return {
    /**
     * Get user profile information including username, email, timezone, phone, and usage stats
     */
    getProfile: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'getProfile',
        params: args || {}
      });
    },

    /**
     * Update user profile fields (username, email, timezone, phone)
     * @param args.username - New username (3-30 characters, alphanumeric with underscores/hyphens) (optional)
     * @param args.email - New email address (optional)
     * @param args.timezone - IANA timezone identifier (e.g., America/Los_Angeles) (optional)
     * @param args.phoneNumber - Phone number (7-15 digits with optional formatting) (optional)
     */
    updateProfile: async (args: UserUpdateProfileArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'updateProfile',
        params: args || {}
      });
    },

    /**
     * Update user preferences (notification settings, etc)
     * @param args.timezone - Preferred timezone for scheduling (optional)
     * @param args.socials - Social media links (twitter, discord) (optional)
     */
    updatePreferences: async (args: UserUpdatePreferencesArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'updatePreferences',
        params: args || {}
      });
    },

    /**
     * Get token usage statistics, quota, and billing information
     */
    getUsageStats: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'getUsageStats',
        params: args || {}
      });
    },

    /**
     * Get active sessions/devices (based on push token registrations)
     */
    getSessions: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'getSessions',
        params: args || {}
      });
    },

    /**
     * Soft delete user account (set inactive flag) - CAUTION: This marks the account for deletion
     * @param args.confirm - Must be true to confirm account deactivation
     */
    deactivateAccount: async (args: UserDeactivateAccountArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'user',
        method: 'deactivateAccount',
        params: args || {}
      });
    }
  };
}

/**
 * Contacts Adapter
 * Category: internal
 */
function createContactsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Get a list of all accepted contacts for the user with their profile information
     * @param args.limit - Maximum number of contacts to return (default: 100) (optional)
     * @param args.offset - Number of contacts to skip for pagination (default: 0) (optional)
     */
    listContacts: async (args: ContactsListContactsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'listContacts',
        params: args || {}
      });
    },

    /**
     * Get detailed information about a specific contact by their ID or username
     * @param args.contactId - The contact user ID (MongoDB ObjectId) (optional)
     * @param args.username - The contact username (optional)
     */
    getContact: async (args: ContactsGetContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'getContact',
        params: args || {}
      });
    },

    /**
     * Send a contact request to another user by their username
     * @param args.username - Username of the user to add as a contact
     */
    addContact: async (args: ContactsAddContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'addContact',
        params: args || {}
      });
    },

    /**
     * Remove a user from your contacts list (unfriend)
     * @param args.contactId - The contact user ID to remove (optional)
     * @param args.username - The contact username to remove (optional)
     */
    removeContact: async (args: ContactsRemoveContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'removeContact',
        params: args || {}
      });
    },

    /**
     * Search your contacts by username, email, phone, or wallet address
     * @param args.query - Search query - can be username, email, phone, or wallet address
     * @param args.searchType - Type of search to perform: all, username, email, phone, or wallet (default: all) (optional)
     * @param args.limit - Maximum number of results (default: 20) (optional)
     */
    searchContacts: async (args: ContactsSearchContactsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'searchContacts',
        params: args || {}
      });
    },

    /**
     * Block a user (prevents them from contacting you)
     * @param args.contactId - The user ID to block (optional)
     * @param args.username - The username to block (optional)
     */
    blockContact: async (args: ContactsBlockContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'blockContact',
        params: args || {}
      });
    },

    /**
     * Unblock a previously blocked user
     * @param args.contactId - The user ID to unblock (optional)
     * @param args.username - The username to unblock (optional)
     */
    unblockContact: async (args: ContactsUnblockContactArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'unblockContact',
        params: args || {}
      });
    },

    /**
     * Get a list of all users you have blocked
     * @param args.limit - Maximum number of results (default: 100) (optional)
     * @param args.offset - Number of items to skip for pagination (default: 0) (optional)
     */
    getBlockedContacts: async (args: ContactsGetBlockedContactsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'getBlockedContacts',
        params: args || {}
      });
    },

    /**
     * Get pending contact requests (sent by you or received from others)
     * @param args.type - Type of requests to retrieve: all, sent, or received (default: all) (optional)
     * @param args.status - Filter by request status: pending, accepted, or rejected (default: pending) (optional)
     */
    getContactRequests: async (args: ContactsGetContactRequestsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'contacts',
        method: 'getContactRequests',
        params: args || {}
      });
    }
  };
}

/**
 * Memory Adapter
 * Category: internal
 */
function createMemoryAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new memory entity in the knowledge graph. Use the type field to specify what kind of memory (note, idea, shopping_item, etc.). For tasks with assignment or timing features, use `createTask` instead. All memory types can be queried, updated, and deleted using the standard operations.
     * @param args.type - Memory subtype: "note" (general notes), "idea" (concepts/ideas), "shopping_item" (shopping list), "topic" (general knowledge), "document" (documents), "contact" (people), "event" (calendar items). For tasks with assignment, use createTask instead.
     * @param args.content - Main content/description of the memory
     * @param args.metadata - Additional metadata (e.g., priority, deadline, tags, etc.) (optional)
     * @param args.tags - Tags for organizing the memory. Shorthand for metadata.tags. (optional)
     * @param args.groupId - Group ID to scope the memory to a specific group. If omitted, memory is created in the user's personal graph. (optional)
     * @returns Promise<MemoryCreateResult> Typed response with IDE autocomplete
     */
    create: async (args: MemoryCreateArgs): Promise<MemoryCreateResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'create',
        params: args || {}
      });
    },

    /**
     * Create a task in the knowledge graph. Tasks are a specialized memory type with assignment, timing, priority, and status lifecycle. Use this instead of `create` when you need task-specific features like assigning to users. Tasks can be queried, updated, and deleted using the standard memory operations (`query`, `update`, `delete`) with type="task". For group contexts, the task is stored in the group's shared graph.
     * @param args.content - Task description/title - what needs to be done. IMPORTANT: Write task content from a neutral perspective without possessive pronouns (his/her/their). The assignee will see this exact text, so "fold dresses" is correct, NOT "fold her dresses". Avoid phrases like "remind him to", "help her with", etc.
     * @param args.assignedTo - Username of the person to assign this task to (group contexts only). System resolves username to user ID. (optional)
     * @param args.dueAt - Due date/time in ISO 8601 format (e.g., "2024-01-15T10:00:00Z") or natural language that will be parsed (optional)
     * @param args.priority - Task priority: "high", "medium", or "low" (optional)
     * @param args.tags - Tags/labels for categorization (e.g., ["work", "urgent"]) (optional)
     * @returns Promise<MemoryCreateTaskResult> Typed response with IDE autocomplete
     */
    createTask: async (args: MemoryCreateTaskArgs): Promise<MemoryCreateTaskResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'createTask',
        params: args || {}
      });
    },

    /**
     * Semantic search across memory entities with advanced filtering. IMPORTANT: Search results return TRUNCATED content (max 300 chars) to prevent huge payloads. To get the full untruncated text of a specific entity, use `findOne` with the entity ID after searching. Recommended workflow: (1) Use `search` to find matching entities, (2) Use `findOne` with { filters: { id: "entity_id" } } to retrieve full content for entities you need.
     * @param args.query - Search query text for semantic matching
     * @param args.types - Filter by entity types (e.g., ["TASK", "NOTE", "IDEA"]) (optional)
     * @param args.startTime - Filter entities created after this timestamp (Unix milliseconds) (optional)
     * @param args.endTime - Filter entities created before this timestamp (Unix milliseconds) (optional)
     * @param args.propertyFilters - Filter by entity properties: { status: ["completed"], tags: ["urgent"], priority: ["high"], roles: ["task"], contexts: ["work"] } (optional)
     * @param args.limit - Maximum number of results (default: 50, max: 100) (optional)
     * @returns Promise<MemorySearchResult> Typed response with IDE autocomplete
     */
    search: async (args: MemorySearchArgs): Promise<MemorySearchResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'search',
        params: args || {}
      });
    },

    /**
     * Query memory entities with filters. Returns lightweight summaries with TRUNCATED content (max 200 chars) to prevent large payloads. Use type="task" to list all tasks (including those created via createTask). To get full untruncated content for a specific entity, use `findOne` with the entity ID.
     * @param args.type - Semantic type filter (e.g., "task", "note", "idea", "reminder", "contact", "document"). Matches against meta_item_type, subType, or semantic_roles (optional)
     * @param args.filters - Additional filters (not yet implemented) (optional)
     * @param args.limit - Maximum results (default: 50, max: 100) (optional)
     * @param args.offset - Pagination offset for fetching more results (default: 0) (optional)
     * @returns Promise<MemoryQueryResult> Typed response with IDE autocomplete
     */
    query: async (args: MemoryQueryArgs): Promise<MemoryQueryResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'query',
        params: args || {}
      });
    },

    /**
     * Find a single entity by ID or name. Returns the FULL untruncated entity content. Use this after `search` or `query` to retrieve complete content for a specific entity (since those operations return truncated results to prevent large payloads).
     * @param args.filters - Filter criteria. Use { id: "entity_id" } to find by ID (recommended), or { name: "entity name" } to find by name.
     * @returns Promise<MemoryFindOneResult> Typed response with IDE autocomplete
     */
    findOne: async (args: MemoryFindOneArgs): Promise<MemoryFindOneResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'findOne',
        params: args || {}
      });
    },

    /**
     * Update an existing memory entity. Works with all memory types including tasks created via createTask. Use this to mark tasks complete, update content, or modify metadata.
     * @param args.id - Entity ID to update
     * @param args.type - Entity type (optional)
     * @param args.content - Updated content (optional)
     * @param args.metadata - Updated metadata (optional)
     * @returns Promise<MemoryUpdateResult> Typed response with IDE autocomplete
     */
    update: async (args: MemoryUpdateArgs): Promise<MemoryUpdateResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'update',
        params: args || {}
      });
    },

    /**
     * Delete a memory entity. Works with all memory types including tasks, notes, ideas, etc.
     * @param args.id - Entity ID to delete
     * @returns Promise<MemoryDeleteResult> Typed response with IDE autocomplete
     */
    delete: async (args: MemoryDeleteArgs): Promise<MemoryDeleteResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'delete',
        params: args || {}
      });
    },

    /**
     * Share a memory entity with another graph (group or contact). Only the creator can share memories. Recipients can view and complete tasks but cannot edit or delete.
     * @param args.entityId - Entity ID to share
     * @param args.targetGraphId - Target graph ID to share with (group ID or user contact graph ID)
     * @param args.shareReason - Optional reason for sharing (optional)
     * @returns Promise<MemoryShareResult> Typed response with IDE autocomplete
     */
    share: async (args: MemoryShareArgs): Promise<MemoryShareResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'share',
        params: args || {}
      });
    },

    /**
     * Remove sharing of a memory entity from a graph. Only the creator can unshare. Cannot unshare from the primary graph (where it was created).
     * @param args.entityId - Entity ID to unshare
     * @param args.graphId - Graph ID to remove sharing from
     * @returns Promise<MemoryUnshareResult> Typed response with IDE autocomplete
     */
    unshare: async (args: MemoryUnshareArgs): Promise<MemoryUnshareResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'unshare',
        params: args || {}
      });
    },

    /**
     * List all graphs a memory entity is shared with, including share history and metadata.
     * @param args.entityId - Entity ID to list graphs for
     * @returns Promise<MemoryListGraphsResult> Typed response with IDE autocomplete
     */
    listGraphs: async (args: MemoryListGraphsArgs): Promise<MemoryListGraphsResult> => {
      return sdk.resources.call({
        resourceId: 'memory',
        method: 'listGraphs',
        params: args || {}
      });
    }
  };
}

/**
 * AI Services Adapter
 * Category: internal
 */
function createAiAdapter(sdk: MirraSDK) {
  return {
    /**
     * Have a conversation with an AI assistant. Supports multi-turn conversations with system prompts, user messages, and assistant responses.

PROVIDER: Uses Anthropic (Claude) as the AI provider.

BEST PRACTICES:
- Use system messages to set AI behavior and constraints
- Keep conversations focused - avoid unnecessary context

MESSAGE STRUCTURE:
Each message has:
- role: "system" | "user" | "assistant"
- content: string (the message text)

TYPICAL PATTERNS:
1. Simple query: [{ role: "user", content: "question" }]
2. With system prompt: [{ role: "system", content: "instructions" }, { role: "user", content: "question" }]
3. Multi-turn: [system, user, assistant, user, assistant, ...]
     * @param args.message - Simple string shorthand for single-turn queries. Auto-wrapped into messages array. Use "messages" for multi-turn conversations. (optional)
     * @param args.messages - Array of message objects with role ("system" | "user" | "assistant") and content (string). System messages set AI behavior, user messages are queries, assistant messages are previous AI responses. (optional)
     * @param args.model - Specific model to use. Default: "claude-3-haiku-20240307". Use Anthropic Claude model names. (optional)
     * @param args.temperature - Creativity level 0.0-1.0. Lower=factual/consistent, Higher=creative/varied. Default: 0.7 (optional)
     * @param args.maxTokens - Maximum tokens in response. Default: 1000. Increase for longer responses (costs more tokens). (optional)
     * @returns Promise<AiChatResult> Typed response with IDE autocomplete
     */
    chat: async (args: AiChatArgs): Promise<AiChatResult> => {
      return sdk.resources.call({
        resourceId: 'ai',
        method: 'chat',
        params: args || {}
      });
    },

    /**
     * Use AI to make a decision from a list of options. The AI analyzes your prompt, considers the context, and selects the most appropriate option with reasoning.

USE CASES:
- Route messages to correct handlers
- Classify user intents
- Select appropriate tools or actions
- Prioritize tasks
- Choose templates or responses
- Determine sentiment or category

HOW IT WORKS:
1. Provide a prompt (the decision context)
2. List available options (each with id and label)
3. Optionally add extra context
4. AI returns selected option ID and reasoning

BEST PRACTICES:
- Make option labels clear and descriptive
- Use unique IDs for options
- Add context when decision needs background info
- Keep prompt focused on the decision criteria
- Use metadata field for additional option data
     * @param args.prompt - The decision prompt - what needs to be decided and why
     * @param args.options - Array of options to choose from. Each option must have: id (unique identifier), label (descriptive name), and optional metadata (additional data)
     * @param args.context - Additional context to help the AI make a better decision (optional)
     * @param args.model - Specific model to use. Defaults to system default. (optional)
     * @returns Promise<AiDecideResult> Typed response with IDE autocomplete
     */
    decide: async (args: AiDecideArgs): Promise<AiDecideResult> => {
      return sdk.resources.call({
        resourceId: 'ai',
        method: 'decide',
        params: args || {}
      });
    }
  };
}

/**
 * Documents Adapter
 * Category: storage
 */
function createDocumentAdapter(sdk: MirraSDK) {
  return {
    /**
     * Upload and process a document (PDF, DOCX, TXT, MD). Returns normalized flat structure.
     * @param args.file - Base64 encoded file content
     * @param args.filename - Original filename with extension
     * @param args.mimeType - MIME type (application/pdf, text/plain, etc.)
     * @param args.graphId - Target graph ID (defaults to user's personal graph) (optional)
     * @param args.title - Custom document title (optional)
     * @param args.productTags - Array of product tags for categorization (optional)
     * @returns Promise<DocumentUploadResult> Typed response with IDE autocomplete
     */
    upload: async (args: DocumentUploadArgs): Promise<DocumentUploadResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'upload',
        params: args || {}
      });
    },

    /**
     * Get document metadata and content. Returns normalized flat structure.
     * @param args.documentId - Document ID to retrieve
     * @returns Promise<DocumentGetResult> Typed response with IDE autocomplete
     */
    get: async (args: DocumentGetArgs): Promise<DocumentGetResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'get',
        params: args || {}
      });
    },

    /**
     * Get document processing status. Returns normalized flat structure.
     * @param args.documentId - Document ID to check
     * @returns Promise<DocumentGetStatusResult> Typed response with IDE autocomplete
     */
    getStatus: async (args: DocumentGetStatusArgs): Promise<DocumentGetStatusResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'getStatus',
        params: args || {}
      });
    },

    /**
     * Get all chunks for a document. Returns normalized flat chunk structures.
     * @param args.documentId - Document ID
     * @returns Promise<DocumentGetChunksResult> Typed response with IDE autocomplete
     */
    getChunks: async (args: DocumentGetChunksArgs): Promise<DocumentGetChunksResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'getChunks',
        params: args || {}
      });
    },

    /**
     * Delete a document and all its chunks. Returns normalized flat structure.
     * @param args.documentId - Document ID to delete
     * @returns Promise<DocumentDeleteResult> Typed response with IDE autocomplete
     */
    delete: async (args: DocumentDeleteArgs): Promise<DocumentDeleteResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'delete',
        params: args || {}
      });
    },

    /**
     * Share a document to another graph (group or user-contact). Returns normalized flat structure.
     * @param args.documentId - Document ID to share
     * @param args.targetGraphId - Target graph ID to share to
     * @param args.shareReason - Optional reason for sharing (optional)
     * @returns Promise<DocumentShareResult> Typed response with IDE autocomplete
     */
    share: async (args: DocumentShareArgs): Promise<DocumentShareResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'share',
        params: args || {}
      });
    },

    /**
     * Remove document access from a graph. Returns normalized flat structure.
     * @param args.documentId - Document ID
     * @param args.graphId - Graph ID to remove access from
     * @returns Promise<DocumentUnshareResult> Typed response with IDE autocomplete
     */
    unshare: async (args: DocumentUnshareArgs): Promise<DocumentUnshareResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'unshare',
        params: args || {}
      });
    },

    /**
     * List all graphs a document is shared in. Returns normalized flat graph structures.
     * @param args.documentId - Document ID
     * @returns Promise<DocumentListGraphsResult> Typed response with IDE autocomplete
     */
    listGraphs: async (args: DocumentListGraphsArgs): Promise<DocumentListGraphsResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'listGraphs',
        params: args || {}
      });
    },

    /**
     * Semantic search across document chunks. Returns normalized flat chunk structures.
     * @param args.query - Search query
     * @param args.graphId - Graph ID to search in (defaults to user's graph) (optional)
     * @param args.limit - Maximum results (default: 10) (optional)
     * @param args.threshold - Similarity threshold 0-1 (default: 0.7) (optional)
     * @returns Promise<DocumentSearchResult> Typed response with IDE autocomplete
     */
    search: async (args: DocumentSearchArgs): Promise<DocumentSearchResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'search',
        params: args || {}
      });
    },

    /**
     * List documents in a graph. Returns normalized flat document structures.
     * @param args.graphId - Graph ID to list documents from (defaults to user's graph) (optional)
     * @param args.limit - Maximum results (default: 50) (optional)
     * @param args.offset - Pagination offset (default: 0) (optional)
     * @returns Promise<DocumentListResult> Typed response with IDE autocomplete
     */
    list: async (args: DocumentListArgs): Promise<DocumentListResult> => {
      return sdk.resources.call({
        resourceId: 'document',
        method: 'list',
        params: args || {}
      });
    }
  };
}

/**
 * Feed Items Adapter
 * Category: internal
 */
function createFeedItemsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a feed item with flexible content blocks. Use this to show action results, notifications, or updates to users.
     * @param args.title - Main title of the feed item (shown prominently)
     * @param args.subtitle - Optional subtitle (shown below title in muted color) (optional)
     * @param args.blocks - Array of content blocks to display (text, key_value, list, timestamp, user_mention, divider, image, progress)
     * @param args.itemType - Type: informative (FYI), actionable (needs response), or error
     * @param args.actions - Optional action buttons for the feed item (optional)
     * @param args.avatar - Optional avatar to show (user profile, icon, or custom image) (optional)
     * @param args.metadata - Additional metadata (searchable, not displayed) (optional)
     * @returns Promise<FeedItemsCreateFeedItemResult> Typed response with IDE autocomplete
     */
    createFeedItem: async (args: FeedItemsCreateFeedItemArgs): Promise<FeedItemsCreateFeedItemResult> => {
      return sdk.resources.call({
        resourceId: 'feed-items',
        method: 'create_feed_item',
        params: args || {}
      });
    }
  };
}

/**
 * Telegram Adapter
 * Category: social
 */
function createTelegramAdapter(sdk: MirraSDK) {
  return {
    /**
     * Send a text message to a Telegram chat or user. Supports both chat IDs and usernames.
     * @param args.chatId - Chat ID (numeric) or username (e.g., @username) to send the message to. Chat IDs can be obtained from searchChats operation.
     * @param args.text - The text content of the message to send
     * @returns Promise<TelegramSendMessageResult> Typed response with IDE autocomplete
     */
    sendMessage: async (args: TelegramSendMessageArgs): Promise<TelegramSendMessageResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'sendMessage',
        params: args || {}
      });
    },

    /**
     * Powerful unified chat search with filtering, sorting, and activity tracking. Replaces getChats, findChatByName, and getRecentContacts. Use with no filters to list all chats.
     * @param args.query - Text to search in chat names/usernames. Supports fuzzy matching with relevance scoring. (optional)
     * @param args.type - Filter by chat type: "private", "group", "channel", or "all" (default: "all") (optional)
     * @param args.inactiveSince - Find chats with no activity since date. Accepts ISO date or relative like "30 days ago", "1 week ago" (optional)
     * @param args.activeSince - Find chats with activity since date. Accepts ISO date or relative like "7 days ago" (optional)
     * @param args.hasUnread - Filter by unread status: true = only unread, false = only read (optional)
     * @param args.archived - Filter by archived status (optional)
     * @param args.pinned - Filter by pinned status (optional)
     * @param args.sortBy - Sort results: "relevance" (default with query), "lastActivity" (default without query), "unreadCount", "name" (optional)
     * @param args.limit - Max results (default: 50, max: 100) (optional)
     * @param args.offset - Pagination offset (default: 0) (optional)
     * @param args.forceRefresh - Bypass cache and fetch fresh data (optional)
     * @returns Promise<TelegramSearchChatsResult> Typed response with IDE autocomplete
     */
    searchChats: async (args: TelegramSearchChatsArgs): Promise<TelegramSearchChatsResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'searchChats',
        params: args || {}
      });
    },

    /**
     * Search for messages across Telegram chats. When chatIds is omitted, performs global search across all chats (replaces globalSearch operation).
     * @param args.query - Text query to search for in messages
     * @param args.chatIds - Array of chat IDs to search within. Omit for global search across all chats. (optional)
     * @param args.chatType - Filter by chat type (for global search): "private", "group", or "channel" (optional)
     * @param args.fromDate - ISO date string for start of date range (optional)
     * @param args.toDate - ISO date string for end of date range (optional)
     * @param args.limit - Maximum number of messages to return (default: 100, max: 100) (optional)
     * @param args.senderId - Filter messages by sender ID (optional)
     * @returns Promise<TelegramSearchMessagesResult> Typed response with IDE autocomplete
     */
    searchMessages: async (args: TelegramSearchMessagesArgs): Promise<TelegramSearchMessagesResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'searchMessages',
        params: args || {}
      });
    },

    /**
     * Get message history from a specific Telegram chat with pagination and date filtering.
     * @param args.chatId - Chat ID to retrieve messages from
     * @param args.limit - Maximum number of messages to return (default: 50, max: 100) (optional)
     * @param args.offsetId - Message ID to use as pagination offset (optional)
     * @param args.minDate - ISO date string for minimum message date (optional)
     * @param args.maxDate - ISO date string for maximum message date (optional)
     * @returns Promise<TelegramGetChatMessagesResult> Typed response with IDE autocomplete
     */
    getChatMessages: async (args: TelegramGetChatMessagesArgs): Promise<TelegramGetChatMessagesResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'getChatMessages',
        params: args || {}
      });
    },

    /**
     * Get summary of unread messages across Telegram chats, including mentions and flattened last message info.
     * @param args.chatIds - Array of chat IDs to filter by. If not provided, checks all chats. (optional)
     * @param args.priorityOnly - If true, only return chats with unread messages (optional)
     * @param args.groupBy - Group results by "chat" or "sender" (optional)
     * @returns Promise<TelegramGetUnreadSummaryResult> Typed response with IDE autocomplete
     */
    getUnreadSummary: async (args: TelegramGetUnreadSummaryArgs): Promise<TelegramGetUnreadSummaryResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'getUnreadSummary',
        params: args || {}
      });
    },

    /**
     * Mark messages as read in a Telegram chat up to a specific message ID.
     * @param args.chatId - Chat ID to mark messages as read in
     * @param args.maxMessageId - Maximum message ID to mark as read. If not provided, marks all messages as read. (optional)
     * @returns Promise<TelegramMarkAsReadResult> Typed response with IDE autocomplete
     */
    markAsRead: async (args: TelegramMarkAsReadArgs): Promise<TelegramMarkAsReadResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'markAsRead',
        params: args || {}
      });
    },

    /**
     * Get messages where the user is mentioned in Telegram chats.
     * @param args.chatIds - Array of chat IDs to filter mentions by (optional)
     * @param args.sinceDate - ISO date string - only return mentions since this date (optional)
     * @param args.onlyUnread - If true, only return unread mentions (optional)
     * @returns Promise<TelegramGetMentionsResult> Typed response with IDE autocomplete
     */
    getMentions: async (args: TelegramGetMentionsArgs): Promise<TelegramGetMentionsResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'getMentions',
        params: args || {}
      });
    },

    /**
     * Leave a Telegram group, supergroup, or channel. Removes the user from the group and clears it from the local cache.
     * @param args.chatId - The ID of the group, supergroup, or channel to leave. Can be obtained from searchChats operation.
     * @returns Promise<TelegramLeaveGroupResult> Typed response with IDE autocomplete
     */
    leaveGroup: async (args: TelegramLeaveGroupArgs): Promise<TelegramLeaveGroupResult> => {
      return sdk.resources.call({
        resourceId: 'telegram',
        method: 'leaveGroup',
        params: args || {}
      });
    }
  };
}

/**
 * Gmail Adapter
 * Category: communication
 */
function createGoogleGmailAdapter(sdk: MirraSDK) {
  return {
    /**
     * Send an email via Gmail
     * @param args.to - Valid email address
     * @param args.subject - Email subject line
     * @param args.body - Email body content
     * @param args.cc - CC recipients (comma-separated email addresses) (optional)
     * @param args.bcc - BCC recipients (comma-separated email addresses) (optional)
     * @param args.isHtml - Whether body is HTML format (optional)
     * @returns Promise<GoogleGmailSendEmailResult> Typed response with IDE autocomplete
     */
    sendEmail: async (args: GoogleGmailSendEmailArgs): Promise<GoogleGmailSendEmailResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'sendEmail',
        params: args || {}
      });
    },

    /**
     * Search emails with Gmail query syntax. Returns normalized email summaries.
     * @param args.query - Gmail search query (e.g., "from:user@example.com is:unread")
     * @param args.maxResults - Maximum number of results to return (default: 50, max: 100) (optional)
     * @returns Promise<GoogleGmailSearchEmailsResult> Typed response with IDE autocomplete
     */
    searchEmails: async (args: GoogleGmailSearchEmailsArgs): Promise<GoogleGmailSearchEmailsResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'searchEmails',
        params: args || {}
      });
    },

    /**
     * List recent emails from inbox. Returns normalized email summaries.
     * @param args.maxResults - Maximum number of results to return (default: 50, max: 100) (optional)
     * @returns Promise<GoogleGmailListEmailsResult> Typed response with IDE autocomplete
     */
    listEmails: async (args: GoogleGmailListEmailsArgs): Promise<GoogleGmailListEmailsResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'listEmails',
        params: args || {}
      });
    },

    /**
     * Get full details of a specific email by ID. Returns normalized flat structure.
     * @param args.messageId - Gmail message ID
     * @param args.includeHtml - Include HTML body content (default: false) (optional)
     * @param args.includeAttachments - Include attachment metadata (default: false) (optional)
     * @returns Promise<GoogleGmailGetEmailResult> Typed response with IDE autocomplete
     */
    getEmail: async (args: GoogleGmailGetEmailArgs): Promise<GoogleGmailGetEmailResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'getEmail',
        params: args || {}
      });
    },

    /**
     * Create a draft email in Gmail
     * @param args.to - Valid email address
     * @param args.subject - Email subject line
     * @param args.body - Email body content
     * @param args.cc - CC recipients (comma-separated email addresses) (optional)
     * @param args.bcc - BCC recipients (comma-separated email addresses) (optional)
     * @param args.isHtml - Whether body is HTML format (optional)
     * @returns Promise<GoogleGmailCreateDraftResult> Typed response with IDE autocomplete
     */
    createDraft: async (args: GoogleGmailCreateDraftArgs): Promise<GoogleGmailCreateDraftResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'createDraft',
        params: args || {}
      });
    },

    /**
     * Update an existing draft email
     * @param args.draftId - Gmail draft ID to update
     * @param args.to - Updated recipient email address(es) (optional)
     * @param args.subject - Updated email subject line (optional)
     * @param args.body - Updated email body content (optional)
     * @param args.cc - Updated CC recipients (optional)
     * @param args.bcc - Updated BCC recipients (optional)
     * @param args.isHtml - Whether body is HTML format (optional)
     * @returns Promise<GoogleGmailUpdateDraftResult> Typed response with IDE autocomplete
     */
    updateDraft: async (args: GoogleGmailUpdateDraftArgs): Promise<GoogleGmailUpdateDraftResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'updateDraft',
        params: args || {}
      });
    },

    /**
     * Delete a draft email
     * @param args.draftId - Gmail draft ID to delete
     * @returns Promise<GoogleGmailDeleteDraftResult> Typed response with IDE autocomplete
     */
    deleteDraft: async (args: GoogleGmailDeleteDraftArgs): Promise<GoogleGmailDeleteDraftResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'deleteDraft',
        params: args || {}
      });
    },

    /**
     * List all draft emails. Returns normalized draft summaries.
     * @param args.maxResults - Maximum number of drafts to return (default: 10) (optional)
     * @returns Promise<GoogleGmailListDraftsResult> Typed response with IDE autocomplete
     */
    listDrafts: async (args: GoogleGmailListDraftsArgs): Promise<GoogleGmailListDraftsResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'listDrafts',
        params: args || {}
      });
    },

    /**
     * Delete an email
     * @param args.messageId - Gmail message ID to delete
     * @returns Promise<GoogleGmailDeleteEmailResult> Typed response with IDE autocomplete
     */
    deleteEmail: async (args: GoogleGmailDeleteEmailArgs): Promise<GoogleGmailDeleteEmailResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'deleteEmail',
        params: args || {}
      });
    },

    /**
     * Delete multiple emails at once. Uses Gmail batchDelete API for efficiency.
     * @param args.messageIds - Array of Gmail message IDs to delete (max 1000 per request)
     * @param args.permanently - If true, permanently delete. If false (default), move to trash. (optional)
     * @returns Promise<GoogleGmailBulkDeleteEmailsResult> Typed response with IDE autocomplete
     */
    bulkDeleteEmails: async (args: GoogleGmailBulkDeleteEmailsArgs): Promise<GoogleGmailBulkDeleteEmailsResult> => {
      return sdk.resources.call({
        resourceId: 'google-gmail',
        method: 'bulkDeleteEmails',
        params: args || {}
      });
    }
  };
}

/**
 * Google Calendar Adapter
 * Category: productivity
 */
function createGoogleCalendarAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new calendar event
     * @param args.summary - Event title/summary
     * @param args.start - Start time object with dateTime and optional timeZone
     * @param args.end - End time object with dateTime and optional timeZone
     * @param args.description - Event description (optional)
     * @param args.location - Event location (optional)
     * @param args.attendees - Array of attendee email addresses (optional)
     * @returns Promise<GoogleCalendarCreateEventResult> Typed response with IDE autocomplete
     */
    createEvent: async (args: GoogleCalendarCreateEventArgs): Promise<GoogleCalendarCreateEventResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'createEvent',
        params: args || {}
      });
    },

    /**
     * List calendar events
     * @param args.timeMin - Start time for events to list (ISO 8601) (optional)
     * @param args.timeMax - End time for events to list (ISO 8601) (optional)
     * @param args.maxResults - Maximum number of events to return (default: 50, max: 100) (optional)
     * @param args.query - Search query to filter events (optional)
     * @returns Promise<GoogleCalendarListEventsResult> Typed response with IDE autocomplete
     */
    listEvents: async (args: GoogleCalendarListEventsArgs): Promise<GoogleCalendarListEventsResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'listEvents',
        params: args || {}
      });
    },

    /**
     * Get calendar events (alias for listEvents)
     * @param args.timeMin - Start time for events to list (ISO 8601) (optional)
     * @param args.timeMax - End time for events to list (ISO 8601) (optional)
     * @param args.maxResults - Maximum number of events to return (default: 50, max: 100) (optional)
     * @param args.query - Search query to filter events (optional)
     * @returns Promise<GoogleCalendarGetEventsResult> Typed response with IDE autocomplete
     */
    getEvents: async (args: GoogleCalendarGetEventsArgs): Promise<GoogleCalendarGetEventsResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'getEvents',
        params: args || {}
      });
    },

    /**
     * Get a specific calendar event by ID
     * @param args.eventId - Calendar event ID
     * @returns Promise<GoogleCalendarGetEventResult> Typed response with IDE autocomplete
     */
    getEvent: async (args: GoogleCalendarGetEventArgs): Promise<GoogleCalendarGetEventResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'getEvent',
        params: args || {}
      });
    },

    /**
     * Update an existing calendar event
     * @param args.eventId - Calendar event ID to update
     * @param args.summary - Updated event title/summary (optional)
     * @param args.description - Updated event description (optional)
     * @param args.location - Updated event location (optional)
     * @param args.start - Updated start time object with dateTime and optional timeZone (optional)
     * @param args.end - Updated end time object with dateTime and optional timeZone (optional)
     * @returns Promise<GoogleCalendarUpdateEventResult> Typed response with IDE autocomplete
     */
    updateEvent: async (args: GoogleCalendarUpdateEventArgs): Promise<GoogleCalendarUpdateEventResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'updateEvent',
        params: args || {}
      });
    },

    /**
     * Delete a calendar event
     * @param args.eventId - Calendar event ID to delete
     * @returns Promise<GoogleCalendarDeleteEventResult> Typed response with IDE autocomplete
     */
    deleteEvent: async (args: GoogleCalendarDeleteEventArgs): Promise<GoogleCalendarDeleteEventResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'deleteEvent',
        params: args || {}
      });
    },

    /**
     * Search calendar events by text query
     * @param args.query - Search query to filter events
     * @param args.timeMin - Start time for events to search (ISO 8601) (optional)
     * @param args.timeMax - End time for events to search (ISO 8601) (optional)
     * @param args.maxResults - Maximum number of events to return (default: 50, max: 100) (optional)
     * @returns Promise<GoogleCalendarSearchEventsResult> Typed response with IDE autocomplete
     */
    searchEvents: async (args: GoogleCalendarSearchEventsArgs): Promise<GoogleCalendarSearchEventsResult> => {
      return sdk.resources.call({
        resourceId: 'google-calendar',
        method: 'searchEvents',
        params: args || {}
      });
    }
  };
}

/**
 * Google Drive Adapter
 * Category: storage
 */
function createGoogleDriveAdapter(sdk: MirraSDK) {
  return {
    /**
     * List files in Google Drive
     * @param args.query - Search query (Google Drive query syntax) (optional)
     * @param args.pageSize - Maximum number of files to return (default: 20) (optional)
     * @returns Promise<GoogleDriveListFilesResult> Typed response with IDE autocomplete
     */
    listFiles: async (args: GoogleDriveListFilesArgs): Promise<GoogleDriveListFilesResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'listFiles',
        params: args || {}
      });
    },

    /**
     * Create a new file in Google Drive
     * @param args.name - Name of the file
     * @param args.mimeType - MIME type of the file
     * @param args.folderId - Parent folder ID (optional) (optional)
     * @returns Promise<GoogleDriveCreateFileResult> Typed response with IDE autocomplete
     */
    createFile: async (args: GoogleDriveCreateFileArgs): Promise<GoogleDriveCreateFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'createFile',
        params: args || {}
      });
    },

    /**
     * Create a new folder in Google Drive
     * @param args.name - Name of the folder
     * @param args.parentFolderId - Parent folder ID (optional) (optional)
     * @returns Promise<GoogleDriveCreateFolderResult> Typed response with IDE autocomplete
     */
    createFolder: async (args: GoogleDriveCreateFolderArgs): Promise<GoogleDriveCreateFolderResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'createFolder',
        params: args || {}
      });
    },

    /**
     * Get information about a file
     * @param args.fileId - ID of the file
     * @returns Promise<GoogleDriveGetFileInfoResult> Typed response with IDE autocomplete
     */
    getFileInfo: async (args: GoogleDriveGetFileInfoArgs): Promise<GoogleDriveGetFileInfoResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'getFileInfo',
        params: args || {}
      });
    },

    /**
     * Share a file with others
     * @param args.fileId - ID of the file to share
     * @param args.email - Email address to share with (optional) (optional)
     * @param args.role - Permission role: reader, writer, commenter (default: reader) (optional)
     * @returns Promise<GoogleDriveShareFileResult> Typed response with IDE autocomplete
     */
    shareFile: async (args: GoogleDriveShareFileArgs): Promise<GoogleDriveShareFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'shareFile',
        params: args || {}
      });
    },

    /**
     * Download a file from Google Drive. For Google Docs/Sheets, exports as PDF/XLSX. Returns base64-encoded data.
     * @param args.fileId - ID of the file to download
     * @returns Promise<GoogleDriveDownloadFileResult> Typed response with IDE autocomplete
     */
    downloadFile: async (args: GoogleDriveDownloadFileArgs): Promise<GoogleDriveDownloadFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'downloadFile',
        params: args || {}
      });
    },

    /**
     * Move a file to a different folder
     * @param args.fileId - ID of the file to move
     * @param args.folderId - ID of the destination folder
     * @returns Promise<GoogleDriveMoveFileResult> Typed response with IDE autocomplete
     */
    moveFile: async (args: GoogleDriveMoveFileArgs): Promise<GoogleDriveMoveFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'moveFile',
        params: args || {}
      });
    },

    /**
     * Delete a file or folder. By default moves to trash; set permanently=true to delete forever.
     * @param args.fileId - ID of the file or folder to delete
     * @param args.permanently - If true, permanently delete instead of moving to trash (default: false) (optional)
     * @returns Promise<GoogleDriveDeleteFileResult> Typed response with IDE autocomplete
     */
    deleteFile: async (args: GoogleDriveDeleteFileArgs): Promise<GoogleDriveDeleteFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'deleteFile',
        params: args || {}
      });
    },

    /**
     * Search for files using Google Drive query syntax
     * @param args.query - Search query using Drive syntax (e.g., "name contains 'report'", "mimeType='application/pdf'")
     * @param args.pageSize - Maximum number of files to return (default: 20) (optional)
     * @returns Promise<GoogleDriveSearchFilesResult> Typed response with IDE autocomplete
     */
    searchFiles: async (args: GoogleDriveSearchFilesArgs): Promise<GoogleDriveSearchFilesResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'searchFiles',
        params: args || {}
      });
    },

    /**
     * Update file metadata (name, description)
     * @param args.fileId - ID of the file to update
     * @param args.name - New name for the file (optional)
     * @param args.description - New description for the file (optional)
     * @returns Promise<GoogleDriveUpdateFileResult> Typed response with IDE autocomplete
     */
    updateFile: async (args: GoogleDriveUpdateFileArgs): Promise<GoogleDriveUpdateFileResult> => {
      return sdk.resources.call({
        resourceId: 'google-drive',
        method: 'updateFile',
        params: args || {}
      });
    }
  };
}

/**
 * Google Sheets Adapter
 * Category: productivity
 */
function createGoogleSheetsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new Google Sheets spreadsheet
     * @param args.title - Title of the spreadsheet
     * @returns Promise<GoogleSheetsCreateSpreadsheetResult> Typed response with IDE autocomplete
     */
    createSpreadsheet: async (args: GoogleSheetsCreateSpreadsheetArgs): Promise<GoogleSheetsCreateSpreadsheetResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'createSpreadsheet',
        params: args || {}
      });
    },

    /**
     * Read data from a range in a spreadsheet
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.range - Cell range (e.g., "Sheet1!A1:B10")
     * @returns Promise<GoogleSheetsReadRangeResult> Typed response with IDE autocomplete
     */
    readRange: async (args: GoogleSheetsReadRangeArgs): Promise<GoogleSheetsReadRangeResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'readRange',
        params: args || {}
      });
    },

    /**
     * Write data to a range in a spreadsheet
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.range - Cell range (e.g., "Sheet1!A1:B10")
     * @param args.values - Data to write (2D array)
     * @returns Promise<GoogleSheetsWriteRangeResult> Typed response with IDE autocomplete
     */
    writeRange: async (args: GoogleSheetsWriteRangeArgs): Promise<GoogleSheetsWriteRangeResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'writeRange',
        params: args || {}
      });
    },

    /**
     * Append a row to a spreadsheet
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetName - Name of the sheet
     * @param args.values - Row values to append
     * @returns Promise<GoogleSheetsAppendRowResult> Typed response with IDE autocomplete
     */
    appendRow: async (args: GoogleSheetsAppendRowArgs): Promise<GoogleSheetsAppendRowResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'appendRow',
        params: args || {}
      });
    },

    /**
     * Get spreadsheet metadata and properties
     * @param args.spreadsheetId - ID of the spreadsheet
     * @returns Promise<GoogleSheetsGetSpreadsheetResult> Typed response with IDE autocomplete
     */
    getSpreadsheet: async (args: GoogleSheetsGetSpreadsheetArgs): Promise<GoogleSheetsGetSpreadsheetResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'getSpreadsheet',
        params: args || {}
      });
    },

    /**
     * Insert a value at a specific cell with optional formatting
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.cell - Cell reference in format SheetName!A1
     * @param args.value - Value to insert
     * @param args.bold - Make text bold (optional)
     * @param args.italic - Make text italic (optional)
     * @param args.foregroundColor - Text color (hex or named color) (optional)
     * @param args.backgroundColor - Cell background color (hex or named color) (optional)
     * @returns Promise<GoogleSheetsInsertAtCellResult> Typed response with IDE autocomplete
     */
    insertAtCell: async (args: GoogleSheetsInsertAtCellArgs): Promise<GoogleSheetsInsertAtCellResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertAtCell',
        params: args || {}
      });
    },

    /**
     * Insert a formula at a specific cell
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.cell - Cell reference in format SheetName!A1
     * @param args.formula - Formula to insert (with or without leading =)
     * @param args.note - Optional note to add to the cell (optional)
     * @returns Promise<GoogleSheetsInsertFormulaResult> Typed response with IDE autocomplete
     */
    insertFormula: async (args: GoogleSheetsInsertFormulaArgs): Promise<GoogleSheetsInsertFormulaResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertFormula',
        params: args || {}
      });
    },

    /**
     * Apply formatting to a range of cells
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.range - Range in format SheetName!A1:B10
     * @param args.bold - Make text bold (optional)
     * @param args.italic - Make text italic (optional)
     * @param args.foregroundColor - Text color (hex or named color) (optional)
     * @param args.backgroundColor - Cell background color (hex or named color) (optional)
     * @param args.borders - Add borders to cells (optional)
     * @returns Promise<GoogleSheetsFormatRangeResult> Typed response with IDE autocomplete
     */
    formatRange: async (args: GoogleSheetsFormatRangeArgs): Promise<GoogleSheetsFormatRangeResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'formatRange',
        params: args || {}
      });
    },

    /**
     * Create a chart from spreadsheet data
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - ID of the sheet containing data
     * @param args.dataRange - Data range for the chart (e.g., A1:B10)
     * @param args.chartType - Chart type: BAR, LINE, AREA, PIE, or SCATTER
     * @param args.title - Chart title
     * @param args.position - Chart position with row, column, rowCount, columnCount
     * @returns Promise<GoogleSheetsCreateChartResult> Typed response with IDE autocomplete
     */
    createChart: async (args: GoogleSheetsCreateChartArgs): Promise<GoogleSheetsCreateChartResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'createChart',
        params: args || {}
      });
    },

    /**
     * Find and replace text in a spreadsheet
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.findText - Text to find
     * @param args.replaceText - Text to replace with
     * @param args.sheetName - Limit search to specific sheet (optional)
     * @param args.matchCase - Case-sensitive search (optional)
     * @param args.matchEntireCell - Match entire cell content only (optional)
     * @returns Promise<GoogleSheetsFindAndReplaceResult> Typed response with IDE autocomplete
     */
    findAndReplace: async (args: GoogleSheetsFindAndReplaceArgs): Promise<GoogleSheetsFindAndReplaceResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'findAndReplace',
        params: args || {}
      });
    },

    /**
     * Insert multiple rows of data at once
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetName - Name of the sheet
     * @param args.rowsData - 2D array of row data to insert
     * @param args.startingRow - Row number to start insertion (1-indexed). If not provided, appends to end (optional)
     * @param args.formattingOptions - Optional formatting to apply (bold, italic, foregroundColor, backgroundColor, borders) (optional)
     * @returns Promise<GoogleSheetsInsertMultipleRowsResult> Typed response with IDE autocomplete
     */
    insertMultipleRows: async (args: GoogleSheetsInsertMultipleRowsArgs): Promise<GoogleSheetsInsertMultipleRowsResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertMultipleRows',
        params: args || {}
      });
    },

    /**
     * Clear content from a range of cells
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetName - Name of the sheet
     * @param args.range - Range to clear (e.g., A1:B10)
     * @returns Promise<GoogleSheetsClearRangeResult> Typed response with IDE autocomplete
     */
    clearRange: async (args: GoogleSheetsClearRangeArgs): Promise<GoogleSheetsClearRangeResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'clearRange',
        params: args || {}
      });
    },

    /**
     * Insert empty rows at a specific position in a sheet. IMPORTANT: Requires numeric sheetId (get from getSpreadsheet), not sheet name. Row indices are 0-indexed (row 1 in UI = index 0).
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
     * @param args.startRowIndex - Row index to start inserting at (0-indexed). To insert before row 5 in the UI, use index 4.
     * @param args.numRows - Number of rows to insert
     * @returns Promise<GoogleSheetsInsertRowsResult> Typed response with IDE autocomplete
     */
    insertRows: async (args: GoogleSheetsInsertRowsArgs): Promise<GoogleSheetsInsertRowsResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertRows',
        params: args || {}
      });
    },

    /**
     * Delete rows from a sheet. IMPORTANT: Requires numeric sheetId (get from getSpreadsheet), not sheet name. Row indices are 0-indexed (row 1 in UI = index 0).
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
     * @param args.startRowIndex - Row index to start deleting from (0-indexed). To delete row 5 in the UI, use index 4.
     * @param args.numRows - Number of rows to delete
     * @returns Promise<GoogleSheetsDeleteRowsResult> Typed response with IDE autocomplete
     */
    deleteRows: async (args: GoogleSheetsDeleteRowsArgs): Promise<GoogleSheetsDeleteRowsResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'deleteRows',
        params: args || {}
      });
    },

    /**
     * Insert empty columns at a specific position in a sheet. IMPORTANT: Requires numeric sheetId (get from getSpreadsheet), not sheet name. Column indices are 0-indexed (A=0, B=1, C=2, etc.).
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
     * @param args.startColumnIndex - Column index to start inserting at (0-indexed: A=0, B=1, C=2, D=3, etc.). To insert before column D, use index 3.
     * @param args.numColumns - Number of columns to insert
     * @returns Promise<GoogleSheetsInsertColumnsResult> Typed response with IDE autocomplete
     */
    insertColumns: async (args: GoogleSheetsInsertColumnsArgs): Promise<GoogleSheetsInsertColumnsResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'insertColumns',
        params: args || {}
      });
    },

    /**
     * Delete columns from a sheet. IMPORTANT: Requires numeric sheetId (get from getSpreadsheet), not sheet name. Column indices are 0-indexed (A=0, B=1, C=2, etc.).
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sheetId - Numeric sheet ID (get from getSpreadsheet response: sheets[0].properties.sheetId). This is NOT the sheet name.
     * @param args.startColumnIndex - Column index to start deleting from (0-indexed: A=0, B=1, C=2, D=3, etc.). To delete column D, use index 3.
     * @param args.numColumns - Number of columns to delete
     * @returns Promise<GoogleSheetsDeleteColumnsResult> Typed response with IDE autocomplete
     */
    deleteColumns: async (args: GoogleSheetsDeleteColumnsArgs): Promise<GoogleSheetsDeleteColumnsResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'deleteColumns',
        params: args || {}
      });
    },

    /**
     * Copy data from one range to another location within the same spreadsheet. IMPORTANT: Requires numeric sheetIds (get from getSpreadsheet), not sheet names. Can copy within same sheet or across sheets.
     * @param args.spreadsheetId - ID of the spreadsheet
     * @param args.sourceSheetId - Numeric sheet ID of the source sheet (get from getSpreadsheet response: sheets[n].properties.sheetId)
     * @param args.sourceRange - Source range in A1 notation WITHOUT sheet name (e.g., "A1:C5", not "Sheet1!A1:C5")
     * @param args.targetSheetId - Numeric sheet ID of the target sheet (can be same as sourceSheetId to copy within same sheet)
     * @param args.targetStartCell - Target start cell in A1 notation (e.g., "E1"). The copied data will fill cells starting from this position.
     * @returns Promise<GoogleSheetsCopyRangeResult> Typed response with IDE autocomplete
     */
    copyRange: async (args: GoogleSheetsCopyRangeArgs): Promise<GoogleSheetsCopyRangeResult> => {
      return sdk.resources.call({
        resourceId: 'google-sheets',
        method: 'copyRange',
        params: args || {}
      });
    }
  };
}

/**
 * Google Docs Adapter
 * Category: productivity
 */
function createGoogleDocsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new Google Doc
     * @param args.title - Title of the document
     * @returns Promise<GoogleDocsCreateDocumentResult> Typed response with IDE autocomplete
     */
    createDocument: async (args: GoogleDocsCreateDocumentArgs): Promise<GoogleDocsCreateDocumentResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'createDocument',
        params: args || {}
      });
    },

    /**
     * Get a Google Doc by ID. Returns normalized flat structure with extracted fields.
     * @param args.documentId - ID of the document
     * @returns Promise<GoogleDocsGetDocumentResult> Typed response with IDE autocomplete
     */
    getDocument: async (args: GoogleDocsGetDocumentArgs): Promise<GoogleDocsGetDocumentResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'getDocument',
        params: args || {}
      });
    },

    /**
     * Append text to the end of a document
     * @param args.documentId - ID of the document
     * @param args.text - Text to append
     * @returns Promise<GoogleDocsAppendTextResult> Typed response with IDE autocomplete
     */
    appendText: async (args: GoogleDocsAppendTextArgs): Promise<GoogleDocsAppendTextResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'appendText',
        params: args || {}
      });
    },

    /**
     * Replace text in a document
     * @param args.documentId - ID of the document
     * @param args.searchText - Text to search for
     * @param args.replaceText - Text to replace with
     * @returns Promise<GoogleDocsReplaceTextResult> Typed response with IDE autocomplete
     */
    replaceText: async (args: GoogleDocsReplaceTextArgs): Promise<GoogleDocsReplaceTextResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'replaceText',
        params: args || {}
      });
    },

    /**
     * Get the text content of a Google Doc
     * @param args.documentId - ID of the document
     * @returns Promise<GoogleDocsGetDocumentContentResult> Typed response with IDE autocomplete
     */
    getDocumentContent: async (args: GoogleDocsGetDocumentContentArgs): Promise<GoogleDocsGetDocumentContentResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'getDocumentContent',
        params: args || {}
      });
    },

    /**
     * Insert text at a specific position in the document
     * @param args.documentId - ID of the document
     * @param args.text - Text to insert
     * @param args.position - Character position to insert at (1-indexed)
     * @returns Promise<GoogleDocsInsertTextAtPositionResult> Typed response with IDE autocomplete
     */
    insertTextAtPosition: async (args: GoogleDocsInsertTextAtPositionArgs): Promise<GoogleDocsInsertTextAtPositionResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertTextAtPosition',
        params: args || {}
      });
    },

    /**
     * Insert text after a search string in the document
     * @param args.documentId - ID of the document
     * @param args.searchText - Text to search for
     * @param args.textToInsert - Text to insert after the search text
     * @param args.occurrence - Which occurrence to insert after (default: 1) (optional)
     * @returns Promise<GoogleDocsInsertTextAfterResult> Typed response with IDE autocomplete
     */
    insertTextAfter: async (args: GoogleDocsInsertTextAfterArgs): Promise<GoogleDocsInsertTextAfterResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertTextAfter',
        params: args || {}
      });
    },

    /**
     * Insert a heading into the document
     * @param args.documentId - ID of the document
     * @param args.text - Heading text
     * @param args.level - Heading level (1-6)
     * @param args.position - Character position to insert at (optional)
     * @param args.insertAfterText - Insert after this text instead of at position (optional)
     * @returns Promise<GoogleDocsInsertHeadingResult> Typed response with IDE autocomplete
     */
    insertHeading: async (args: GoogleDocsInsertHeadingArgs): Promise<GoogleDocsInsertHeadingResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertHeading',
        params: args || {}
      });
    },

    /**
     * Insert a bulleted or numbered list into the document
     * @param args.documentId - ID of the document
     * @param args.items - Array of list items
     * @param args.listType - Type of list: "bulleted" or "numbered"
     * @param args.position - Character position to insert at (optional)
     * @param args.insertAfterText - Insert after this text instead of at position (optional)
     * @returns Promise<GoogleDocsInsertListResult> Typed response with IDE autocomplete
     */
    insertList: async (args: GoogleDocsInsertListArgs): Promise<GoogleDocsInsertListResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertList',
        params: args || {}
      });
    },

    /**
     * Insert a table into the document
     * @param args.documentId - ID of the document
     * @param args.data - 2D array of table data (rows x columns)
     * @param args.hasHeader - Whether the first row is a header (default: true) (optional)
     * @param args.position - Character position to insert at (optional)
     * @param args.insertAfterText - Insert after this text instead of at position (optional)
     * @returns Promise<GoogleDocsInsertTableResult> Typed response with IDE autocomplete
     */
    insertTable: async (args: GoogleDocsInsertTableArgs): Promise<GoogleDocsInsertTableResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'insertTable',
        params: args || {}
      });
    },

    /**
     * Replace the entire content of a document
     * @param args.documentId - ID of the document
     * @param args.newContent - New content to replace existing content
     * @returns Promise<GoogleDocsUpdateDocumentContentResult> Typed response with IDE autocomplete
     */
    updateDocumentContent: async (args: GoogleDocsUpdateDocumentContentArgs): Promise<GoogleDocsUpdateDocumentContentResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'updateDocumentContent',
        params: args || {}
      });
    },

    /**
     * Create a new section with a heading and content. Returns normalized result with insertion details.
     * @param args.documentId - ID of the document
     * @param args.heading - Section heading text
     * @param args.content - Section content text
     * @returns Promise<GoogleDocsCreateSectionResult> Typed response with IDE autocomplete
     */
    createSection: async (args: GoogleDocsCreateSectionArgs): Promise<GoogleDocsCreateSectionResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'createSection',
        params: args || {}
      });
    },

    /**
     * Find the character position for insertion based on position or search text. Returns normalized result with position and context.
     * @param args.documentId - ID of the document
     * @param args.position - Position to find (1 for start, -1 for end)
     * @param args.searchText - Text to search for (returns position after this text) (optional)
     * @returns Promise<GoogleDocsFindInsertionPointResult> Typed response with IDE autocomplete
     */
    findInsertionPoint: async (args: GoogleDocsFindInsertionPointArgs): Promise<GoogleDocsFindInsertionPointResult> => {
      return sdk.resources.call({
        resourceId: 'google-docs',
        method: 'findInsertionPoint',
        params: args || {}
      });
    }
  };
}

/**
 * Jira Adapter
 * Category: project
 */
function createJiraAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new Jira issue
     * @param args.projectKey - Jira project key (e.g., "PROJ")
     * @param args.summary - Issue summary/title
     * @param args.description - Issue description (optional)
     * @param args.issueType - Issue type (Task, Bug, Story, etc.) (optional)
     * @returns Promise<JiraCreateIssueResult> Typed response with IDE autocomplete
     */
    createIssue: async (args: JiraCreateIssueArgs): Promise<JiraCreateIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'createIssue',
        params: args || {}
      });
    },

    /**
     * Search Jira issues using JQL. Returns normalized flat issue summaries.
     * @param args.jql - JQL query string
     * @param args.maxResults - Maximum number of results (default: 50, max: 100) (optional)
     * @returns Promise<JiraSearchIssuesResult> Typed response with IDE autocomplete
     */
    searchIssues: async (args: JiraSearchIssuesArgs): Promise<JiraSearchIssuesResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'searchIssues',
        params: args || {}
      });
    },

    /**
     * Get a specific Jira issue by key or ID. Returns normalized flat structure.
     * @param args.issueKey - Issue key (e.g., "PROJ-123") or ID
     * @returns Promise<JiraGetIssueResult> Typed response with IDE autocomplete
     */
    getIssue: async (args: JiraGetIssueArgs): Promise<JiraGetIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getIssue',
        params: args || {}
      });
    },

    /**
     * Update an existing Jira issue
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @param args.summary - New issue summary/title (optional)
     * @param args.description - New issue description (optional)
     * @returns Promise<JiraUpdateIssueResult> Typed response with IDE autocomplete
     */
    updateIssue: async (args: JiraUpdateIssueArgs): Promise<JiraUpdateIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'updateIssue',
        params: args || {}
      });
    },

    /**
     * Delete a Jira issue
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @returns Promise<JiraDeleteIssueResult> Typed response with IDE autocomplete
     */
    deleteIssue: async (args: JiraDeleteIssueArgs): Promise<JiraDeleteIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'deleteIssue',
        params: args || {}
      });
    },

    /**
     * Add a comment to a Jira issue
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @param args.comment - Comment text
     * @returns Promise<JiraAddCommentResult> Typed response with IDE autocomplete
     */
    addComment: async (args: JiraAddCommentArgs): Promise<JiraAddCommentResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'addComment',
        params: args || {}
      });
    },

    /**
     * Transition a Jira issue to a different status
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @param args.transitionId - ID of the transition to perform
     * @returns Promise<JiraTransitionIssueResult> Typed response with IDE autocomplete
     */
    transitionIssue: async (args: JiraTransitionIssueArgs): Promise<JiraTransitionIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'transitionIssue',
        params: args || {}
      });
    },

    /**
     * Assign a Jira issue to a user
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @param args.accountId - Atlassian account ID of the assignee
     * @returns Promise<JiraAssignIssueResult> Typed response with IDE autocomplete
     */
    assignIssue: async (args: JiraAssignIssueArgs): Promise<JiraAssignIssueResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'assignIssue',
        params: args || {}
      });
    },

    /**
     * Get all accessible Jira projects. Returns normalized flat project structures.
     * @returns Promise<JiraGetProjectsResult> Typed response with IDE autocomplete
     */
    getProjects: async (args?: {}): Promise<JiraGetProjectsResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getProjects',
        params: args || {}
      });
    },

    /**
     * List all accessible Jira projects (alias for getProjects). Returns normalized flat structures.
     * @returns Promise<JiraListProjectsResult> Typed response with IDE autocomplete
     */
    listProjects: async (args?: {}): Promise<JiraListProjectsResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'listProjects',
        params: args || {}
      });
    },

    /**
     * Get metadata for a specific Jira project. Returns normalized flat structures.
     * @param args.projectKey - Project key (e.g., "PROJ")
     * @returns Promise<JiraGetProjectMetadataResult> Typed response with IDE autocomplete
     */
    getProjectMetadata: async (args: JiraGetProjectMetadataArgs): Promise<JiraGetProjectMetadataResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getProjectMetadata',
        params: args || {}
      });
    },

    /**
     * Get available transitions for a Jira issue. Returns normalized flat structures.
     * @param args.issueKey - Issue key (e.g., "PROJ-123")
     * @returns Promise<JiraGetTransitionsResult> Typed response with IDE autocomplete
     */
    getTransitions: async (args: JiraGetTransitionsArgs): Promise<JiraGetTransitionsResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getTransitions',
        params: args || {}
      });
    },

    /**
     * List users that can be assigned to issues in a project
     * @param args.projectKey - Project key (e.g., "PROJ")
     * @returns Promise<JiraListAssignableUsersResult> Typed response with IDE autocomplete
     */
    listAssignableUsers: async (args: JiraListAssignableUsersArgs): Promise<JiraListAssignableUsersResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'listAssignableUsers',
        params: args || {}
      });
    },

    /**
     * Get available issue types for a project. Returns normalized flat structures.
     * @param args.projectKey - Project key (e.g., "PROJ")
     * @returns Promise<JiraGetIssueTypesResult> Typed response with IDE autocomplete
     */
    getIssueTypes: async (args: JiraGetIssueTypesArgs): Promise<JiraGetIssueTypesResult> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'getIssueTypes',
        params: args || {}
      });
    },

    /**
     * Search Jira API for available operations beyond core tools
     * @param args.query - Describe what you want to do (e.g., "add label to card")
     * @param args.limit - Max results to return (default 5) (optional)
     */
    discoverExtended: async (args: JiraDiscoverExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'discoverExtended',
        params: args || {}
      });
    },

    /**
     * Execute a Jira API operation by operationId
     * @param args.operationId - The operationId from discoverExtended results
     * @param args.pathParams - Path parameters, e.g., { id: "abc123" } (optional)
     * @param args.queryParams - Query string parameters (optional)
     * @param args.body - Request body for POST/PUT/PATCH operations (optional)
     */
    executeExtended: async (args: JiraExecuteExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'jira',
        method: 'executeExtended',
        params: args || {}
      });
    }
  };
}

/**
 * Twitter Adapter
 * Category: social
 */
function createTwitterAdapter(sdk: MirraSDK) {
  return {
    /**
     * Post a tweet
     * @param args.text - Tweet text (max 280 characters)
     * @returns Promise<TwitterPostTweetResult> Typed response with IDE autocomplete
     */
    postTweet: async (args: TwitterPostTweetArgs): Promise<TwitterPostTweetResult> => {
      return sdk.resources.call({
        resourceId: 'twitter',
        method: 'postTweet',
        params: args || {}
      });
    },

    /**
     * Retrieve tweets from a Twitter user. Must provide either userId OR userName (not both). NOTE: This operation ONLY accepts the 4 parameters listed below. There is NO maxResults, limit, count, or similar parameters - the API returns ~20 tweets per page, use cursor for pagination.
     * @param args.userId - Twitter user ID (recommended for stability and speed). Provide userId OR userName, not both. (optional)
     * @param args.userName - Twitter username/handle without @ symbol (e.g., "elonmusk"). Provide userName OR userId, not both. (optional)
     * @param args.cursor - Pagination cursor from previous response's nextCursor field. Do not fabricate cursor values. (optional)
     * @param args.includeReplies - Whether to include replies in results. Defaults to false (only original tweets). (optional)
     * @returns Promise<TwitterGetUserTweetsResult> Typed response with IDE autocomplete
     */
    getUserTweets: async (args: TwitterGetUserTweetsArgs): Promise<TwitterGetUserTweetsResult> => {
      return sdk.resources.call({
        resourceId: 'twitter',
        method: 'getUserTweets',
        params: args || {}
      });
    },

    /**
     * Search tweets using advanced Twitter search syntax. Supports operators like from:username, since:date, until:date, lang:en, and boolean operators (AND, OR). NOTE: This operation ONLY accepts the 3 parameters listed below (query, queryType, cursor). There is NO minFollowers, maxResults, limit, or other filtering parameters - filter results client-side after fetching.
     * @param args.query - Search query with advanced syntax. Examples: "from:elonmusk", "bitcoin since:2024-01-01", "AI OR \"machine learning\"". Supported operators: from:user, to:user, since:YYYY-MM-DD, until:YYYY-MM-DD, lang:xx, filter:media, filter:links, -filter:retweets, AND, OR, -keyword, "exact phrase".
     * @param args.queryType - Type of search results: "Latest" (most recent) or "Top" (most relevant). Defaults to "Latest". Only these two values are valid. (optional)
     * @param args.cursor - Pagination cursor from previous response's nextCursor field. Do not fabricate cursor values. (optional)
     * @returns Promise<TwitterAdvancedSearchResult> Typed response with IDE autocomplete
     */
    advancedSearch: async (args: TwitterAdvancedSearchArgs): Promise<TwitterAdvancedSearchResult> => {
      return sdk.resources.call({
        resourceId: 'twitter',
        method: 'advancedSearch',
        params: args || {}
      });
    }
  };
}

/**
 * Trello Adapter
 * Category: productivity
 */
function createTrelloAdapter(sdk: MirraSDK) {
  return {
    /**
     * Get all boards for the authenticated user
     * @returns Promise<TrelloGetBoardsResult> Typed response with IDE autocomplete
     */
    getBoards: async (args?: {}): Promise<TrelloGetBoardsResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'getBoards',
        params: args || {}
      });
    },

    /**
     * Get a specific board by ID including its lists
     * @param args.boardId - The ID of the board to retrieve
     * @returns Promise<TrelloGetBoardResult> Typed response with IDE autocomplete
     */
    getBoard: async (args: TrelloGetBoardArgs): Promise<TrelloGetBoardResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'getBoard',
        params: args || {}
      });
    },

    /**
     * Create a new card in a Trello list
     * @param args.name - Card name/title
     * @param args.idList - ID of the list to add the card to
     * @param args.desc - Card description (supports markdown) (optional)
     * @param args.description - Card description (alias for "desc", supports markdown) (optional)
     * @returns Promise<TrelloCreateCardResult> Typed response with IDE autocomplete
     */
    createCard: async (args: TrelloCreateCardArgs): Promise<TrelloCreateCardResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'createCard',
        params: args || {}
      });
    },

    /**
     * Get a specific card by ID
     * @param args.cardId - The ID of the card to retrieve
     * @returns Promise<TrelloGetCardResult> Typed response with IDE autocomplete
     */
    getCard: async (args: TrelloGetCardArgs): Promise<TrelloGetCardResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'getCard',
        params: args || {}
      });
    },

    /**
     * Update an existing card
     * @param args.cardId - The ID of the card to update
     * @param args.name - New card name (optional)
     * @param args.desc - New card description (optional)
     * @param args.description - New card description (alias for "desc", supports markdown) (optional)
     * @param args.idList - Move card to a different list (optional)
     * @param args.closed - Archive the card (optional)
     * @returns Promise<TrelloUpdateCardResult> Typed response with IDE autocomplete
     */
    updateCard: async (args: TrelloUpdateCardArgs): Promise<TrelloUpdateCardResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'updateCard',
        params: args || {}
      });
    },

    /**
     * Delete a card permanently
     * @param args.cardId - The ID of the card to delete
     * @returns Promise<TrelloDeleteCardResult> Typed response with IDE autocomplete
     */
    deleteCard: async (args: TrelloDeleteCardArgs): Promise<TrelloDeleteCardResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'deleteCard',
        params: args || {}
      });
    },

    /**
     * Create a new checklist on a card
     * @param args.cardId - The ID of the card to add the checklist to
     * @param args.name - Checklist name
     * @returns Promise<TrelloCreateChecklistResult> Typed response with IDE autocomplete
     */
    createChecklist: async (args: TrelloCreateChecklistArgs): Promise<TrelloCreateChecklistResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'createChecklist',
        params: args || {}
      });
    },

    /**
     * Get a specific checklist by ID
     * @param args.checklistId - The ID of the checklist to retrieve
     * @returns Promise<TrelloGetChecklistResult> Typed response with IDE autocomplete
     */
    getChecklist: async (args: TrelloGetChecklistArgs): Promise<TrelloGetChecklistResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'getChecklist',
        params: args || {}
      });
    },

    /**
     * Update a checklist name
     * @param args.checklistId - The ID of the checklist to update
     * @param args.name - New checklist name
     * @returns Promise<TrelloUpdateChecklistResult> Typed response with IDE autocomplete
     */
    updateChecklist: async (args: TrelloUpdateChecklistArgs): Promise<TrelloUpdateChecklistResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'updateChecklist',
        params: args || {}
      });
    },

    /**
     * Delete a checklist from a card
     * @param args.checklistId - The ID of the checklist to delete
     * @returns Promise<TrelloDeleteChecklistResult> Typed response with IDE autocomplete
     */
    deleteChecklist: async (args: TrelloDeleteChecklistArgs): Promise<TrelloDeleteChecklistResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'deleteChecklist',
        params: args || {}
      });
    },

    /**
     * Add a check item to a checklist
     * @param args.checklistId - The ID of the checklist to add the item to
     * @param args.name - Check item text
     * @returns Promise<TrelloAddCheckItemResult> Typed response with IDE autocomplete
     */
    addCheckItem: async (args: TrelloAddCheckItemArgs): Promise<TrelloAddCheckItemResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'addCheckItem',
        params: args || {}
      });
    },

    /**
     * Update a check item (name or completion state)
     * @param args.cardId - The ID of the card containing the check item
     * @param args.checkItemId - The ID of the check item to update
     * @param args.name - New check item text (optional)
     * @param args.state - Check state: "complete" or "incomplete" (optional)
     * @returns Promise<TrelloUpdateCheckItemResult> Typed response with IDE autocomplete
     */
    updateCheckItem: async (args: TrelloUpdateCheckItemArgs): Promise<TrelloUpdateCheckItemResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'updateCheckItem',
        params: args || {}
      });
    },

    /**
     * Delete a check item from a checklist
     * @param args.checklistId - The ID of the checklist containing the item
     * @param args.checkItemId - The ID of the check item to delete
     * @returns Promise<TrelloDeleteCheckItemResult> Typed response with IDE autocomplete
     */
    deleteCheckItem: async (args: TrelloDeleteCheckItemArgs): Promise<TrelloDeleteCheckItemResult> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'deleteCheckItem',
        params: args || {}
      });
    },

    /**
     * Search Trello API for available operations beyond core tools
     * @param args.query - Describe what you want to do (e.g., "add label to card")
     * @param args.limit - Max results to return (default 5) (optional)
     */
    discoverExtended: async (args: TrelloDiscoverExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'discoverExtended',
        params: args || {}
      });
    },

    /**
     * Execute a Trello API operation by operationId
     * @param args.operationId - The operationId from discoverExtended results
     * @param args.pathParams - Path parameters, e.g., { id: "abc123" } (optional)
     * @param args.queryParams - Query string parameters (optional)
     * @param args.body - Request body for POST/PUT/PATCH operations (optional)
     */
    executeExtended: async (args: TrelloExecuteExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'trello',
        method: 'executeExtended',
        params: args || {}
      });
    }
  };
}

/**
 * Jupiter Adapter
 * Category: crypto
 */
function createJupiterAdapter(sdk: MirraSDK) {
  return {
    /**
     * Execute a token swap on Jupiter DEX. Returns normalized FLAT structure with transaction, signerWallet, inputMint, outputMint, inputAmount, expectedOutputAmount, priceImpact, slippageBps. No nested objects.
     * @param args.inputMint - Input token mint address
     * @param args.outputMint - Output token mint address
     * @param args.amount - Amount to swap (in smallest unit)
     * @param args.inputDecimals - Number of decimals for input token. Auto-resolved from Jupiter token registry if not provided. (optional)
     * @param args.slippageBps - Slippage tolerance in basis points (default: 50) (optional)
     * @returns Promise<JupiterSwapResult> Typed response with IDE autocomplete
     */
    swap: async (args: JupiterSwapArgs): Promise<JupiterSwapResult> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'swap',
        params: args || {}
      });
    },

    /**
     * Get token holdings for a wallet. Returns normalized FLAT structure with owner, solBalance, totalValueUsd, tokenCount, and tokens array.
     * @param args.walletAddress - Wallet address to check (uses actor wallet if not provided) (optional)
     * @returns Promise<JupiterGetHoldingsResult> Typed response with IDE autocomplete
     */
    getHoldings: async (args: JupiterGetHoldingsArgs): Promise<JupiterGetHoldingsResult> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'getHoldings',
        params: args || {}
      });
    },

    /**
     * Get token security information using Jupiter Shield. Returns normalized FLAT structure with riskLevel, warningCount, and security flags.
     * @param args.tokenMint - Token mint address to check security for
     * @returns Promise<JupiterGetTokenSecurityResult> Typed response with IDE autocomplete
     */
    getTokenSecurity: async (args: JupiterGetTokenSecurityArgs): Promise<JupiterGetTokenSecurityResult> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'getTokenSecurity',
        params: args || {}
      });
    },

    /**
     * Search for tokens by symbol, name, or mint address. Returns normalized FLAT token results with all fields flattened.
     * @param args.query - Search query (symbol, name, or mint address)
     * @returns Promise<JupiterSearchTokensResult> Typed response with IDE autocomplete
     */
    searchTokens: async (args: JupiterSearchTokensArgs): Promise<JupiterSearchTokensResult> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'searchTokens',
        params: args || {}
      });
    },

    /**
     * Refresh an expired swap with new quote and transaction. Returns normalized FLAT structure.
     * @param args.feedItemId - Feed item ID containing the swap to refresh
     * @param args.swapId - Original swap ID
     * @param args.inputMint - Input token mint address
     * @param args.outputMint - Output token mint address
     * @param args.amount - Amount to swap (in UI units)
     * @param args.inputDecimals - Input token decimals
     * @param args.slippageBps - Slippage tolerance in basis points (optional)
     * @returns Promise<JupiterRefreshSwapResult> Typed response with IDE autocomplete
     */
    refreshSwap: async (args: JupiterRefreshSwapArgs): Promise<JupiterRefreshSwapResult> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'refreshSwap',
        params: args || {}
      });
    },

    /**
     * Launch a new token on Solana via Jupiter Studio. Creates a DBC (Dynamic Bonding Curve) pool. The user must have uploaded a token image in this conversation — pass the image URL provided in the chat. Returns a pending_transaction for the user to sign. FLAT structure.
     * @param args.tokenName - Name of the token
     * @param args.tokenSymbol - Token ticker symbol
     * @param args.tokenDescription - Description for the token metadata (optional)
     * @param args.tokenImageUrl - URL of the uploaded token image (from user message)
     * @param args.quoteMint - Quote token mint address. Defaults to USDC (EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v). Can also use SOL or JUP mint. (optional)
     * @param args.initialMarketCap - Initial market cap in quote token units (default: 16000 for meme preset) (optional)
     * @param args.migrationMarketCap - Market cap threshold for graduation/migration (default: 69000 for meme preset) (optional)
     * @param args.antiSniping - Enable anti-sniping protection (default: false) (optional)
     * @param args.feeBps - Creator trading fee in basis points: 100 (1%) or 200 (2%). Default: 100 (optional)
     * @param args.isLpLocked - Lock LP tokens (default: true) (optional)
     * @param args.website - Project website URL for token metadata (optional)
     * @param args.twitter - Twitter/X URL for token metadata (optional)
     * @param args.telegram - Telegram URL for token metadata (optional)
     * @returns Promise<JupiterLaunchTokenResult> Typed response with IDE autocomplete
     */
    launchToken: async (args: JupiterLaunchTokenArgs): Promise<JupiterLaunchTokenResult> => {
      return sdk.resources.call({
        resourceId: 'jupiter',
        method: 'launchToken',
        params: args || {}
      });
    }
  };
}

/**
 * Crypto Adapter
 * Category: crypto
 */
function createCryptoAdapter(sdk: MirraSDK) {
  return {
    /**
     * Get the current price of a crypto asset. Returns normalized flat structure.
     * @param args.tokenAddress - Token contract address (EVM: 0x..., SVM: base58)
     * @param args.chainName - Specific chain name (auto-detected if not provided) (optional)
     * @returns Promise<CryptoGetPriceResult> Typed response with IDE autocomplete
     */
    getPrice: async (args: CryptoGetPriceArgs): Promise<CryptoGetPriceResult> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'getPrice',
        params: args || {}
      });
    },

    /**
     * Send cryptocurrency or tokens (creates pending transaction for signing). Returns normalized flat structure.
     * @param args.recipient - Contact username, user ID, or Solana wallet address
     * @param args.token - Token symbol (SOL, USDC), name, or mint address
     * @param args.amount - Amount to send (in UI units)
     * @returns Promise<CryptoSendTokenResult> Typed response with IDE autocomplete
     */
    sendToken: async (args: CryptoSendTokenArgs): Promise<CryptoSendTokenResult> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'sendToken',
        params: args || {}
      });
    },

    /**
     * Set up automated price monitoring with progressive alerts. Returns normalized flat structure.
     * @param args.tokenAddress - Token contract address to monitor
     * @param args.direction - Alert direction: "above" or "below"
     * @param args.targetPrice - Target price in USD to trigger alert
     * @param args.scriptId - ID of the script to execute when price target is reached
     * @param args.chainName - Chain name (auto-detected if not provided) (optional)
     * @param args.percentStep - Progressive alert step percentage (default: 0.1 = 10%) (optional)
     * @returns Promise<CryptoMonitorPriceResult> Typed response with IDE autocomplete
     */
    monitorPrice: async (args: CryptoMonitorPriceArgs): Promise<CryptoMonitorPriceResult> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'monitorPrice',
        params: args || {}
      });
    },

    /**
     * List all active crypto price monitoring assignments. Returns normalized flat structures.
     * @returns Promise<CryptoListSubscriptionsResult> Typed response with IDE autocomplete
     */
    listSubscriptions: async (args?: {}): Promise<CryptoListSubscriptionsResult> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'listSubscriptions',
        params: args || {}
      });
    },

    /**
     * Stop monitoring a crypto asset. Returns normalized flat structure.
     * @param args.tokenAddress - Token address to stop monitoring
     * @returns Promise<CryptoUnsubscribeAssetResult> Typed response with IDE autocomplete
     */
    unsubscribeAsset: async (args: CryptoUnsubscribeAssetArgs): Promise<CryptoUnsubscribeAssetResult> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'unsubscribeAsset',
        params: args || {}
      });
    },

    /**
     * Refresh an expired transaction with new blockhash and updated details. Returns normalized flat structure.
     * @param args.feedItemId - Feed item ID containing the transaction to refresh
     * @param args.transferId - Original transfer ID
     * @param args.recipient - Recipient address
     * @param args.token - Token symbol or mint address
     * @param args.amount - Amount to send
     * @param args.tokenMint - Token mint address (optional, will resolve if not provided) (optional)
     * @param args.tokenDecimals - Token decimals (optional) (optional)
     * @returns Promise<CryptoRefreshTransactionResult> Typed response with IDE autocomplete
     */
    refreshTransaction: async (args: CryptoRefreshTransactionArgs): Promise<CryptoRefreshTransactionResult> => {
      return sdk.resources.call({
        resourceId: 'crypto',
        method: 'refreshTransaction',
        params: args || {}
      });
    }
  };
}

/**
 * Scripts Adapter
 * Category: productivity
 */
function createScriptsAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new script with initial version and API key. Returns flat structure with id field for subsequent operations.

HANDLER RETURN VALUES (when script is used in a flow):
The handler's return object controls how the flow executor records the result:
- Success: return { success: true, ...data }
- No-Op (nothing to do, not an error): return { success: false, noOp: true, reason: "No input data" }
  No-ops are recorded as successful executions and do NOT count toward the auto-pause threshold.
- Failure: return { success: false, reason: "What went wrong" }
  3 consecutive failures will auto-pause the flow.
     * @param args.name - Name of the script
     * @param args.description - Description of what the script does (optional)
     * @param args.runtime - Lambda runtime (default: nodejs18) (optional)
     * @param args.config - Script configuration (timeout, memory, maxCostPerExecution, etc.) (optional)
     * @param args.code - Initial JavaScript/TypeScript code for the script
     * @returns Promise<ScriptsCreateScriptResult> Typed response with IDE autocomplete
     */
    createScript: async (args: ScriptsCreateScriptArgs): Promise<ScriptsCreateScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'createScript',
        params: args || {}
      });
    },

    /**
     * Delete a script and all its versions. Returns flat deletion confirmation.
     * @param args.scriptId - ID of the script to delete
     * @returns Promise<ScriptsDeleteScriptResult> Typed response with IDE autocomplete
     */
    deleteScript: async (args: ScriptsDeleteScriptArgs): Promise<ScriptsDeleteScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'deleteScript',
        params: args || {}
      });
    },

    /**
     * Create a new version of an existing script. Returns flat version details.
     * @param args.scriptId - ID of the script
     * @param args.code - Updated code for the new version
     * @param args.commitMessage - Description of changes in this version (optional)
     * @returns Promise<ScriptsCreateVersionResult> Typed response with IDE autocomplete
     */
    createVersion: async (args: ScriptsCreateVersionArgs): Promise<ScriptsCreateVersionResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'createVersion',
        params: args || {}
      });
    },

    /**
     * List all versions of a script. Returns flat version structures.
     * @param args.scriptId - ID of the script
     * @returns Promise<ScriptsListVersionsResult> Typed response with IDE autocomplete
     */
    listVersions: async (args: ScriptsListVersionsArgs): Promise<ScriptsListVersionsResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'listVersions',
        params: args || {}
      });
    },

    /**
     * Deploy a script version to AWS Lambda. Must be called after createScript to make the script executable.
     * @param args.scriptId - ID of the script to deploy (from createScript response at data._id)
     * @param args.version - Version number to deploy (default: latest) (optional)
     * @returns Promise<ScriptsDeployScriptResult> Typed response with IDE autocomplete
     */
    deployScript: async (args: ScriptsDeployScriptArgs): Promise<ScriptsDeployScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'deployScript',
        params: args || {}
      });
    },

    /**
     * Execute a deployed script with custom data. Script must be deployed first via deployScript. Returns flat execution result.
     * @param args.scriptId - ID of the script to execute (from createScript response at data.id)
     * @param args.data - Input data to pass to the script (optional)
     * @param args.trigger - Trigger information (type, source, event) (optional)
     * @returns Promise<ScriptsExecuteScriptResult> Typed response with IDE autocomplete
     */
    executeScript: async (args: ScriptsExecuteScriptArgs): Promise<ScriptsExecuteScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'executeScript',
        params: args || {}
      });
    },

    /**
     * Get details of a specific script. Returns flat normalized structure.
     * @param args.scriptId - ID of the script
     * @returns Promise<ScriptsGetScriptResult> Typed response with IDE autocomplete
     */
    getScript: async (args: ScriptsGetScriptArgs): Promise<ScriptsGetScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getScript',
        params: args || {}
      });
    },

    /**
     * List all scripts owned by the user. Returns flat script summaries.
     * @returns Promise<ScriptsListScriptsResult> Typed response with IDE autocomplete
     */
    listScripts: async (args?: {}): Promise<ScriptsListScriptsResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'listScripts',
        params: args || {}
      });
    },

    /**
     * Get execution history for a script. Returns flat execution summaries.
     * @param args.scriptId - ID of the script
     * @param args.status - Filter by status (completed, failed, running) (optional)
     * @param args.limit - Maximum number of executions to return (default: 100) (optional)
     * @returns Promise<ScriptsGetExecutionsResult> Typed response with IDE autocomplete
     */
    getExecutions: async (args: ScriptsGetExecutionsArgs): Promise<ScriptsGetExecutionsResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getExecutions',
        params: args || {}
      });
    },

    /**
     * Get details of a specific execution. Returns flat execution structure.
     * @param args.executionId - ID of the execution
     * @returns Promise<ScriptsGetExecutionResult> Typed response with IDE autocomplete
     */
    getExecution: async (args: ScriptsGetExecutionArgs): Promise<ScriptsGetExecutionResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getExecution',
        params: args || {}
      });
    },

    /**
     * Publish a script to the marketplace. Returns flat publish confirmation.
     * @param args.scriptId - ID of the script to publish
     * @param args.pricing - Pricing configuration for the marketplace (optional)
     * @returns Promise<ScriptsPublishScriptResult> Typed response with IDE autocomplete
     */
    publishScript: async (args: ScriptsPublishScriptArgs): Promise<ScriptsPublishScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'publishScript',
        params: args || {}
      });
    },

    /**
     * Remove a script from the marketplace. Returns flat unpublish confirmation.
     * @param args.scriptId - ID of the script to unpublish
     * @returns Promise<ScriptsUnpublishScriptResult> Typed response with IDE autocomplete
     */
    unpublishScript: async (args: ScriptsUnpublishScriptArgs): Promise<ScriptsUnpublishScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'unpublishScript',
        params: args || {}
      });
    },

    /**
     * Search and list published scripts in the marketplace. Returns flat script summaries with pagination.
     * @param args.name - Exact match on script name (optional)
     * @param args.system - Filter by system scripts (scope="system") when true, user scripts when false (optional)
     * @param args.search - Text search on name and description (optional)
     * @param args.tags - Filter by tags (matches scripts with any of the specified tags) (optional)
     * @param args.category - Filter by UI category (notification, data_sync, automation, utility, reporting) (optional)
     * @param args.pricingModel - Filter by pricing model (free, pay-per-execution, subscription) (optional)
     * @param args.staffPick - Filter to only staff-picked scripts when true (optional)
     * @param args.minRating - Minimum rating threshold (0-5) (optional)
     * @param args.requiredIntegrations - Filter by required integrations (e.g., ["telegram", "gmail"]) (optional)
     * @param args.sortBy - Sort field: rating, installCount, trendingScore, publishedAt, name (default: rating) (optional)
     * @param args.sortOrder - Sort order: asc or desc (default: desc) (optional)
     * @param args.limit - Maximum number of results to return (default: 50, max: 100) (optional)
     * @param args.offset - Number of results to skip for pagination (default: 0) (optional)
     * @returns Promise<ScriptsListMarketplaceScriptsResult> Typed response with IDE autocomplete
     */
    listMarketplaceScripts: async (args: ScriptsListMarketplaceScriptsArgs): Promise<ScriptsListMarketplaceScriptsResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'listMarketplaceScripts',
        params: args || {}
      });
    },

    /**
     * Get execution metrics for a script. Returns flat metrics structure.
     * @param args.scriptId - ID of the script
     * @returns Promise<ScriptsGetMetricsResult> Typed response with IDE autocomplete
     */
    getMetrics: async (args: ScriptsGetMetricsArgs): Promise<ScriptsGetMetricsResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getMetrics',
        params: args || {}
      });
    },

    /**
     * Create a webhook endpoint for the script. Returns flat webhook details.
     * @param args.scriptId - ID of the script
     * @param args.name - Name of the webhook
     * @param args.enabled - Whether webhook is enabled (default: true) (optional)
     * @returns Promise<ScriptsCreateWebhookResult> Typed response with IDE autocomplete
     */
    createWebhook: async (args: ScriptsCreateWebhookArgs): Promise<ScriptsCreateWebhookResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'createWebhook',
        params: args || {}
      });
    },

    /**
     * Create a cron schedule for the script. Returns flat schedule details.
     * @param args.scriptId - ID of the script
     * @param args.name - Name of the schedule
     * @param args.cronExpression - Cron expression (e.g., "0 9 * * *" for daily at 9am)
     * @param args.enabled - Whether schedule is enabled (default: true) (optional)
     * @param args.data - Data to pass to the script on scheduled execution (optional)
     * @returns Promise<ScriptsCreateScheduleResult> Typed response with IDE autocomplete
     */
    createSchedule: async (args: ScriptsCreateScheduleArgs): Promise<ScriptsCreateScheduleResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'createSchedule',
        params: args || {}
      });
    },

    /**
     * Get the script code for a specific flow. Returns flat flow script structure.
     * @param args.flowId - ID of the flow to get script code for
     * @returns Promise<ScriptsGetFlowScriptResult> Typed response with IDE autocomplete
     */
    getFlowScript: async (args: ScriptsGetFlowScriptArgs): Promise<ScriptsGetFlowScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'getFlowScript',
        params: args || {}
      });
    },

    /**
     * Modify the script code for a flow. Automatically creates a copy if user does not own the original, deploys to Lambda, and updates the flow. Returns flat modification result.
     * @param args.flowId - ID of the flow to modify
     * @param args.newCode - New code to deploy
     * @param args.commitMessage - Description of changes (optional)
     * @returns Promise<ScriptsModifyFlowScriptResult> Typed response with IDE autocomplete
     */
    modifyFlowScript: async (args: ScriptsModifyFlowScriptArgs): Promise<ScriptsModifyFlowScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'modifyFlowScript',
        params: args || {}
      });
    },

    /**
     * Validate script code BEFORE creating or deploying. Checks for: 1) Missing async handler wrapper (top-level await errors), 2) Invalid adapter operations, 3) Invalid event.data field access (when eventType provided). Returns flat validation results with suggestions for fixes. ALWAYS use this before createScript/modifyFlowScript.
     * @param args.code - The script code to validate
     * @param args.eventType - Event type for event.data field validation (e.g., "telegram.message", "call.ended"). When provided, validates that event.data.fieldName accesses match the event type schema. (optional)
     * @param args.scriptInputSchema - Schema of scriptInput fields that will be on event.data at runtime. Keys are field names, values are { type: "string"|"number"|"boolean"|"object"|"array" }. When provided, event.data field errors are reported as errors instead of warnings. (optional)
     * @returns Promise<ScriptsLintScriptResult> Typed response with IDE autocomplete
     */
    lintScript: async (args: ScriptsLintScriptArgs): Promise<ScriptsLintScriptResult> => {
      return sdk.resources.call({
        resourceId: 'scripts',
        method: 'lintScript',
        params: args || {}
      });
    }
  };
}

/**
 * Feedback Adapter
 * Category: internal
 */
function createFeedbackAdapter(sdk: MirraSDK) {
  return {
    /**
     * Report a bug with detailed context and reproduction steps
     * @param args.title - Brief bug description
     * @param args.description - Detailed description of the bug
     * @param args.severity - Bug severity: critical, high, medium, or low
     * @param args.stepsToReproduce - Steps to reproduce the bug (optional)
     * @param args.expectedBehavior - What should happen (optional)
     * @param args.actualBehavior - What actually happens (optional)
     * @param args.errorDetails - Error details: { message, stack, code } (optional)
     * @param args.context - Additional context: { conversationId, recentMessages, platform, appVersion } (optional)
     * @param args.llmAnalysis - LLM analysis of the issue (optional)
     * @returns Promise<FeedbackReportBugResult> Typed response with IDE autocomplete
     */
    reportBug: async (args: FeedbackReportBugArgs): Promise<FeedbackReportBugResult> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'reportBug',
        params: args || {}
      });
    },

    /**
     * Auto-report tool or adapter failures for debugging
     * @param args.adapterType - Adapter type (e.g., jupiter, crypto)
     * @param args.operation - Operation that failed (e.g., swap, sendToken)
     * @param args.errorMessage - Error message from the failure
     * @param args.errorCode - Error code if available (optional)
     * @param args.errorStack - Error stack trace (optional)
     * @param args.args - Sanitized arguments that caused the failure (optional)
     * @param args.llmAnalysis - LLM analysis of why it failed (optional)
     * @param args.suggestedFix - LLM suggested fix (optional)
     * @param args.context - Additional context: { conversationId, userId, timestamp } (optional)
     * @returns Promise<FeedbackReportToolFailureResult> Typed response with IDE autocomplete
     */
    reportToolFailure: async (args: FeedbackReportToolFailureArgs): Promise<FeedbackReportToolFailureResult> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'reportToolFailure',
        params: args || {}
      });
    },

    /**
     * Report when LLM cannot fulfill a user request
     * @param args.userRequest - What the user asked for
     * @param args.reason - Why it could not be fulfilled
     * @param args.suggestedCapability - What capability would enable this (optional)
     * @param args.relatedAdapters - Adapters that might be relevant (optional)
     * @param args.context - Additional context: { conversationId } (optional)
     * @returns Promise<FeedbackReportMissingCapabilityResult> Typed response with IDE autocomplete
     */
    reportMissingCapability: async (args: FeedbackReportMissingCapabilityArgs): Promise<FeedbackReportMissingCapabilityResult> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'reportMissingCapability',
        params: args || {}
      });
    },

    /**
     * Submit general user feedback
     * @param args.sentiment - Sentiment: positive, negative, or neutral
     * @param args.feedback - Feedback content
     * @param args.category - Category: ux, performance, feature, or general (optional)
     * @param args.context - Additional context: { feature, screen } (optional)
     * @returns Promise<FeedbackSubmitFeedbackResult> Typed response with IDE autocomplete
     */
    submitFeedback: async (args: FeedbackSubmitFeedbackArgs): Promise<FeedbackSubmitFeedbackResult> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'submitFeedback',
        params: args || {}
      });
    },

    /**
     * Submit a feature request
     * @param args.title - Feature title
     * @param args.description - Feature description
     * @param args.useCase - Why the user needs this feature (optional)
     * @param args.priority - Priority: high, medium, or low (optional)
     * @returns Promise<FeedbackSubmitFeatureRequestResult> Typed response with IDE autocomplete
     */
    submitFeatureRequest: async (args: FeedbackSubmitFeatureRequestArgs): Promise<FeedbackSubmitFeatureRequestResult> => {
      return sdk.resources.call({
        resourceId: 'feedback',
        method: 'submitFeatureRequest',
        params: args || {}
      });
    }
  };
}

/**
 * Mirra Messaging Adapter
 * Category: communication
 */
function createMirraMessagingAdapter(sdk: MirraSDK) {
  return {
    /**
     * Send a message to a group (including direct chats). The message is sent as the authenticated user with optional automation metadata. Returns normalized flat structure.
     * @param args.groupId - Group ID to send the message to (use getContacts or getGroups to get the groupId)
     * @param args.content - Message text content
     * @param args.replyToMessageId - ID of the message to reply to (creates a threaded reply) (optional)
     * @param args.automation - Automation metadata: { source: string, flowId?: string, flowTitle?: string, sessionId?: string, isAutomated?: boolean }. Use sessionId to group related messages and enable Flow-based reply routing. (optional)
     * @param args.structuredData - Structured data for rich UI rendering: [{ displayType, templateId, data, metadata?, interactions? }] (optional)
     * @returns Promise<MirraMessagingSendMessageResult> Typed response with IDE autocomplete
     */
    sendMessage: async (args: MirraMessagingSendMessageArgs): Promise<MirraMessagingSendMessageResult> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'sendMessage',
        params: args || {}
      });
    },

    /**
     * Update an existing message sent by the authenticated user. Returns normalized flat structure.
     * @param args.messageId - ID of the message to update
     * @param args.content - New message text content
     * @param args.structuredData - Updated structured data for rich UI rendering (optional)
     * @returns Promise<MirraMessagingUpdateMessageResult> Typed response with IDE autocomplete
     */
    updateMessage: async (args: MirraMessagingUpdateMessageArgs): Promise<MirraMessagingUpdateMessageResult> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'updateMessage',
        params: args || {}
      });
    },

    /**
     * Get list of accepted contacts for the user. Returns normalized flat structures.
     * @param args.limit - Maximum number of contacts to return (default 50) (optional)
     * @param args.offset - Offset for pagination (default 0) (optional)
     * @returns Promise<MirraMessagingGetContactsResult> Typed response with IDE autocomplete
     */
    getContacts: async (args: MirraMessagingGetContactsArgs): Promise<MirraMessagingGetContactsResult> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'getContacts',
        params: args || {}
      });
    },

    /**
     * Find a contact by username or partial name match. Returns normalized flat structures.
     * @param args.query - Username or name to search for
     * @returns Promise<MirraMessagingFindContactResult> Typed response with IDE autocomplete
     */
    findContact: async (args: MirraMessagingFindContactArgs): Promise<MirraMessagingFindContactResult> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'findContact',
        params: args || {}
      });
    },

    /**
     * Get list of chat instances for the user. Returns normalized flat structures.
     * @param args.scope - Filter by scope: direct, user, group, or all (default all) (optional)
     * @param args.limit - Maximum number of chats to return (default 50) (optional)
     * @returns Promise<MirraMessagingGetChatsResult> Typed response with IDE autocomplete
     */
    getChats: async (args: MirraMessagingGetChatsArgs): Promise<MirraMessagingGetChatsResult> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'getChats',
        params: args || {}
      });
    },

    /**
     * Get list of groups the user is a member of. Returns normalized flat structures.
     * @param args.limit - Maximum number of groups to return (default 50) (optional)
     * @returns Promise<MirraMessagingGetGroupsResult> Typed response with IDE autocomplete
     */
    getGroups: async (args: MirraMessagingGetGroupsArgs): Promise<MirraMessagingGetGroupsResult> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'getGroups',
        params: args || {}
      });
    },

    /**
     * Create a new group. The authenticated user becomes the group owner. Returns normalized flat structure.
     * @param args.name - Group name (max 100 characters)
     * @param args.description - Group description (max 500 characters) (optional)
     * @param args.category - Category for organization: "family", "friends", "work", or "other" (default: "other") (optional)
     * @param args.memberIds - Array of user IDs to add as initial members (optional)
     * @returns Promise<MirraMessagingCreateGroupResult> Typed response with IDE autocomplete
     */
    createGroup: async (args: MirraMessagingCreateGroupArgs): Promise<MirraMessagingCreateGroupResult> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'createGroup',
        params: args || {}
      });
    },

    /**
     * Search chat messages by keywords. Returns summaries by default to avoid overwhelming context. Use includeFullText for complete messages.
     * @param args.query - Keywords to search for
     * @param args.contactName - Contact name to filter by sender (resolved to userId) (optional)
     * @param args.groupName - Group name to limit search (resolved to groupId) (optional)
     * @param args.groupId - Group ID to limit search (use groupName for name-based lookup) (optional)
     * @param args.scope - "direct", "group", or "all" (default) (optional)
     * @param args.startDate - ISO date for time range start (optional)
     * @param args.endDate - ISO date for time range end (optional)
     * @param args.includeFullText - Include full message text (default: false, returns snippets) (optional)
     * @param args.snippetLength - Max chars for snippet (default: 200) (optional)
     * @param args.limit - Max results (default 20, max 50) (optional)
     * @param args.offset - Pagination offset (optional)
     * @returns Promise<MirraMessagingSearchMessagesResult> Typed response with IDE autocomplete
     */
    searchMessages: async (args: MirraMessagingSearchMessagesArgs): Promise<MirraMessagingSearchMessagesResult> => {
      return sdk.resources.call({
        resourceId: 'mirra-messaging',
        method: 'searchMessages',
        params: args || {}
      });
    }
  };
}

/**
 * Moltbook Adapter
 * Category: social
 */
function createMoltbookAdapter(sdk: MirraSDK) {
  return {
    /**
     * Register a new agent on Moltbook. Returns API key and claim URL for verification.
     * @param args.agentName - Unique name for your agent (alphanumeric, underscores allowed)
     * @returns Promise<MoltbookRegisterAgentResult> Typed response with IDE autocomplete
     */
    registerAgent: async (args: MoltbookRegisterAgentArgs): Promise<MoltbookRegisterAgentResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'registerAgent',
        params: args || {}
      });
    },

    /**
     * Create a new post on Moltbook (rate limited: 1 post per 30 minutes)
     * @param args.content - Post content/body text
     * @param args.title - Post title (optional) (optional)
     * @param args.type - Post type: "text" or "link" (default: text) (optional)
     * @param args.url - URL for link posts (optional)
     * @param args.submolt - Community name to post in (optional) (optional)
     * @returns Promise<MoltbookCreatePostResult> Typed response with IDE autocomplete
     */
    createPost: async (args: MoltbookCreatePostArgs): Promise<MoltbookCreatePostResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'createPost',
        params: args || {}
      });
    },

    /**
     * Get posts from Moltbook feed. Returns normalized flat post summaries.
     * @param args.sort - Sort order: "hot", "new", "top", "rising" (default: hot) (optional)
     * @param args.limit - Max posts to return (default: 25, max: 100) (optional)
     * @param args.submolt - Filter by community name (optional)
     * @returns Promise<MoltbookGetPostsResult> Typed response with IDE autocomplete
     */
    getPosts: async (args: MoltbookGetPostsArgs): Promise<MoltbookGetPostsResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getPosts',
        params: args || {}
      });
    },

    /**
     * Get a single post by ID. Returns normalized flat structure.
     * @param args.postId - Post ID
     * @returns Promise<MoltbookGetPostResult> Typed response with IDE autocomplete
     */
    getPost: async (args: MoltbookGetPostArgs): Promise<MoltbookGetPostResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getPost',
        params: args || {}
      });
    },

    /**
     * Delete your own post
     * @param args.postId - Post ID to delete
     * @returns Promise<MoltbookDeletePostResult> Typed response with IDE autocomplete
     */
    deletePost: async (args: MoltbookDeletePostArgs): Promise<MoltbookDeletePostResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'deletePost',
        params: args || {}
      });
    },

    /**
     * Add a comment to a post (rate limited: 50 comments per hour)
     * @param args.postId - Post ID to comment on
     * @param args.content - Comment content
     * @param args.parentId - Parent comment ID for replies (optional)
     * @returns Promise<MoltbookCreateCommentResult> Typed response with IDE autocomplete
     */
    createComment: async (args: MoltbookCreateCommentArgs): Promise<MoltbookCreateCommentResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'createComment',
        params: args || {}
      });
    },

    /**
     * Get comments on a post. Returns normalized flat comment structures.
     * @param args.postId - Post ID
     * @param args.sort - Sort: "top", "new", "controversial" (default: top) (optional)
     * @returns Promise<MoltbookGetCommentsResult> Typed response with IDE autocomplete
     */
    getComments: async (args: MoltbookGetCommentsArgs): Promise<MoltbookGetCommentsResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getComments',
        params: args || {}
      });
    },

    /**
     * Upvote a post
     * @param args.postId - Post ID to upvote
     * @returns Promise<MoltbookUpvotePostResult> Typed response with IDE autocomplete
     */
    upvotePost: async (args: MoltbookUpvotePostArgs): Promise<MoltbookUpvotePostResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'upvotePost',
        params: args || {}
      });
    },

    /**
     * Downvote a post
     * @param args.postId - Post ID to downvote
     * @returns Promise<MoltbookDownvotePostResult> Typed response with IDE autocomplete
     */
    downvotePost: async (args: MoltbookDownvotePostArgs): Promise<MoltbookDownvotePostResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'downvotePost',
        params: args || {}
      });
    },

    /**
     * Upvote a comment
     * @param args.commentId - Comment ID to upvote
     * @returns Promise<MoltbookUpvoteCommentResult> Typed response with IDE autocomplete
     */
    upvoteComment: async (args: MoltbookUpvoteCommentArgs): Promise<MoltbookUpvoteCommentResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'upvoteComment',
        params: args || {}
      });
    },

    /**
     * Create a new community (submolt)
     * @param args.name - Community name (alphanumeric, underscores)
     * @param args.description - Community description
     * @returns Promise<MoltbookCreateSubmoltResult> Typed response with IDE autocomplete
     */
    createSubmolt: async (args: MoltbookCreateSubmoltArgs): Promise<MoltbookCreateSubmoltResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'createSubmolt',
        params: args || {}
      });
    },

    /**
     * List all communities. Returns normalized flat structures.
     * @returns Promise<MoltbookGetSubmoltsResult> Typed response with IDE autocomplete
     */
    getSubmolts: async (args?: {}): Promise<MoltbookGetSubmoltsResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getSubmolts',
        params: args || {}
      });
    },

    /**
     * Get community details. Returns normalized flat structure.
     * @param args.name - Community name
     * @returns Promise<MoltbookGetSubmoltResult> Typed response with IDE autocomplete
     */
    getSubmolt: async (args: MoltbookGetSubmoltArgs): Promise<MoltbookGetSubmoltResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getSubmolt',
        params: args || {}
      });
    },

    /**
     * Subscribe to a community
     * @param args.name - Community name to subscribe to
     * @returns Promise<MoltbookSubscribeResult> Typed response with IDE autocomplete
     */
    subscribe: async (args: MoltbookSubscribeArgs): Promise<MoltbookSubscribeResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'subscribe',
        params: args || {}
      });
    },

    /**
     * Unsubscribe from a community
     * @param args.name - Community name to unsubscribe from
     * @returns Promise<MoltbookUnsubscribeResult> Typed response with IDE autocomplete
     */
    unsubscribe: async (args: MoltbookUnsubscribeArgs): Promise<MoltbookUnsubscribeResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'unsubscribe',
        params: args || {}
      });
    },

    /**
     * Follow another agent
     * @param args.agentName - Agent name to follow
     * @returns Promise<MoltbookFollowAgentResult> Typed response with IDE autocomplete
     */
    followAgent: async (args: MoltbookFollowAgentArgs): Promise<MoltbookFollowAgentResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'followAgent',
        params: args || {}
      });
    },

    /**
     * Unfollow an agent
     * @param args.agentName - Agent name to unfollow
     * @returns Promise<MoltbookUnfollowAgentResult> Typed response with IDE autocomplete
     */
    unfollowAgent: async (args: MoltbookUnfollowAgentArgs): Promise<MoltbookUnfollowAgentResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'unfollowAgent',
        params: args || {}
      });
    },

    /**
     * Get an agent's profile. Returns normalized flat structure.
     * @param args.agentName - Agent name
     * @returns Promise<MoltbookGetProfileResult> Typed response with IDE autocomplete
     */
    getProfile: async (args: MoltbookGetProfileArgs): Promise<MoltbookGetProfileResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getProfile',
        params: args || {}
      });
    },

    /**
     * Get your own agent profile. Returns normalized flat structure.
     * @returns Promise<MoltbookGetMyProfileResult> Typed response with IDE autocomplete
     */
    getMyProfile: async (args?: {}): Promise<MoltbookGetMyProfileResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getMyProfile',
        params: args || {}
      });
    },

    /**
     * Update your agent profile. Returns normalized flat structure.
     * @param args.description - New profile description (optional)
     * @param args.metadata - Additional metadata (optional)
     * @returns Promise<MoltbookUpdateProfileResult> Typed response with IDE autocomplete
     */
    updateProfile: async (args: MoltbookUpdateProfileArgs): Promise<MoltbookUpdateProfileResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'updateProfile',
        params: args || {}
      });
    },

    /**
     * Get personalized feed (subscriptions + follows). Returns normalized flat post summaries.
     * @param args.limit - Max posts to return (default: 25, max: 100) (optional)
     * @returns Promise<MoltbookGetFeedResult> Typed response with IDE autocomplete
     */
    getFeed: async (args: MoltbookGetFeedArgs): Promise<MoltbookGetFeedResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getFeed',
        params: args || {}
      });
    },

    /**
     * Search posts, agents, and communities. Returns normalized flat structures.
     * @param args.query - Search query
     * @returns Promise<MoltbookSearchResult> Typed response with IDE autocomplete
     */
    search: async (args: MoltbookSearchArgs): Promise<MoltbookSearchResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'search',
        params: args || {}
      });
    },

    /**
     * Check agent claim/verification status
     * @returns Promise<MoltbookGetStatusResult> Typed response with IDE autocomplete
     */
    getStatus: async (args?: {}): Promise<MoltbookGetStatusResult> => {
      return sdk.resources.call({
        resourceId: 'moltbook',
        method: 'getStatus',
        params: args || {}
      });
    }
  };
}

/**
 * Tunnel Adapter
 * Category: internal
 */
function createTunnelAdapter(sdk: MirraSDK) {
  return {
    /**
     * Make an HTTP request through a tunnel to a local service
     * @param args.tunnel - Tunnel name to use (defaults to 'default') (optional)
     * @param args.method - HTTP method (defaults to GET) (optional)
     * @param args.path - Request path (e.g., /api/query)
     * @param args.headers - Request headers (optional)
     * @param args.body - Request body (for POST/PUT/PATCH) (optional)
     */
    call: async (args: TunnelCallArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'tunnel',
        method: 'call',
        params: args || {}
      });
    },

    /**
     * Check if a specific tunnel is connected
     * @param args.tunnel - Tunnel name to check (defaults to 'default') (optional)
     */
    status: async (args: TunnelStatusArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'tunnel',
        method: 'status',
        params: args || {}
      });
    },

    /**
     * List all connected tunnels for the user
     */
    list: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'tunnel',
        method: 'list',
        params: args || {}
      });
    }
  };
}

/**
 * Polymarket Adapter
 * Category: crypto
 */
function createPolymarketAdapter(sdk: MirraSDK) {
  return {
    /**
     * Search and list Polymarket prediction markets. Returns active and resolved markets with current pricing, volume, and outcome data from the Gamma API. Use the query parameter to search by question text, or filter by category tag, active/closed status. Results are paginated.
     * @param args.query - Search query to filter markets by question text (matched against slug) (optional)
     * @param args.tag - Filter by category tag (e.g., "politics", "crypto", "sports", "science") (optional)
     * @param args.limit - Maximum number of markets to return (default: 25, max: 100) (optional)
     * @param args.offset - Offset for pagination (default: 0) (optional)
     * @param args.active - If true, return only active/open markets (optional)
     * @param args.closed - If true, return only closed/resolved markets (optional)
     */
    getMarkets: async (args: PolymarketGetMarketsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getMarkets',
        params: args || {}
      });
    },

    /**
     * Get detailed information for a specific Polymarket prediction market. Lookup by conditionId (the unique market identifier on the CTF contract) or by slug (the URL-friendly market name). Returns full market details including current pricing, volume, liquidity, and outcome probabilities.
     * @param args.conditionId - The condition ID of the market (hex string, e.g., "0xabc123...") (optional)
     * @param args.slug - The market slug (URL-friendly name, alternative to conditionId) (optional)
     */
    getMarket: async (args: PolymarketGetMarketArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getMarket',
        params: args || {}
      });
    },

    /**
     * List Polymarket events, which are groups of related prediction markets. For example, a "2024 US Election" event may contain multiple markets for different races. Events include aggregated volume/liquidity and a list of child markets with their individual outcome prices.
     * @param args.tag - Filter by category tag (e.g., "politics", "crypto", "sports") (optional)
     * @param args.limit - Maximum number of events to return (default: 25, max: 100) (optional)
     * @param args.offset - Offset for pagination (default: 0) (optional)
     * @param args.active - If true, return only active events (optional)
     * @param args.closed - If true, return only closed/resolved events (optional)
     */
    getEvents: async (args: PolymarketGetEventsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getEvents',
        params: args || {}
      });
    },

    /**
     * Get the current price for a specific market outcome token on the Polymarket CLOB. The tokenId is the unique identifier for one side of a binary market outcome (e.g., the "Yes" token or "No" token). Prices range from 0.00 to 1.00, representing the implied probability. Use side to get the BUY or SELL price.
     * @param args.tokenId - The token ID of the outcome to price (available from market.outcomes or market data)
     * @param args.side - Price side: "BUY" or "SELL". Defaults to "BUY". (optional)
     */
    getPrice: async (args: PolymarketGetPriceArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getPrice',
        params: args || {}
      });
    },

    /**
     * Get the current orderbook depth for a market outcome token on the Polymarket CLOB. Returns sorted bid and ask arrays with price/size at each level, plus computed midpoint and spread. Useful for assessing liquidity and slippage before placing orders.
     * @param args.tokenId - The token ID of the outcome (available from market data)
     */
    getOrderbook: async (args: PolymarketGetOrderbookArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getOrderbook',
        params: args || {}
      });
    },

    /**
     * Creates an action proposal for user approval. Validates that CLOB credentials exist, fetches live market price/spread for context, and saves an ActionProposal to the database. Server signs and submits the order on approval. Returns status "pending" with requiresAction: true.
     * @param args.tokenId - The token ID of the outcome to trade (from market data)
     * @param args.price - Order price between 0.01 and 0.99 (implied probability)
     * @param args.size - Order size in number of shares (denominated in USDC)
     * @param args.side - Order side: "BUY" to buy outcome shares, "SELL" to sell held shares
     * @param args.type - Order type: "GTC" (Good Til Cancelled, default), "GTD" (Good Til Date), "FOK" (Fill Or Kill), "FAK" (Fill And Kill) (optional)
     * @param args.expiration - Unix timestamp expiration for GTD orders only (optional)
     * @param args.marketQuestion - Human-readable market question (e.g. "Will Bitcoin reach $100k?"). Pass this from getMarkets results so the order card shows the market name instead of a numeric token ID. (optional)
     */
    placeOrder: async (args: PolymarketPlaceOrderArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'placeOrder',
        params: args || {}
      });
    },

    /**
     * Executes a previously approved order using server-stored CLOB credentials. Called automatically when user approves a placeOrder proposal. Signs the order server-side with HMAC-SHA256 and submits to the Polymarket CLOB API with optional Builder attribution headers.
     * @param args.orderPayload - The order payload from placeOrder: { tokenId, price, size, side, type, expiration }
     */
    executeOrder: async (args: PolymarketExecuteOrderArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'executeOrder',
        params: args || {}
      });
    },

    /**
     * Creates an action proposal to cancel an existing order. Validates that CLOB credentials exist and saves an ActionProposal to the database. Server signs and submits the cancellation on approval. Returns status "pending" with requiresAction: true.
     * @param args.orderId - The ID of the order to cancel (from getOrders or placeOrder result)
     */
    cancelOrder: async (args: PolymarketCancelOrderArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'cancelOrder',
        params: args || {}
      });
    },

    /**
     * Executes a previously approved cancel using server-stored CLOB credentials. Called automatically when user approves a cancelOrder proposal. Signs the cancel request server-side and submits to the Polymarket CLOB API.
     * @param args.orderId - The ID of the order to cancel
     */
    executeCancelOrder: async (args: PolymarketExecuteCancelOrderArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'executeCancelOrder',
        params: args || {}
      });
    },

    /**
     * Rebuild an expired order proposal with fresh market data. Use this when a pending order from placeOrder has expired and the user still wants to place the trade. Creates a new ActionProposal with updated currentPrice and a new expiration. Same parameters as placeOrder.
     * @param args.tokenId - The token ID of the outcome to trade
     * @param args.price - Order price between 0.01 and 0.99
     * @param args.size - Order size in number of shares
     * @param args.side - Order side: "BUY" or "SELL"
     * @param args.type - Order type: "GTC" (default), "GTD", "FOK", "FAK" (optional)
     * @param args.expiration - Unix timestamp expiration for GTD orders (optional)
     */
    refreshOrder: async (args: PolymarketRefreshOrderArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'refreshOrder',
        params: args || {}
      });
    },

    /**
     * Get active orders for the authenticated user on the Polymarket CLOB. Returns open/pending orders with current fill status. Requires server-side CLOB credentials (read-only). Can be filtered by market condition ID.
     * @param args.market - Filter by market condition ID to see orders for a specific market (optional)
     * @param args.limit - Maximum number of orders to return (default: 25, max: 100) (optional)
     * @param args.offset - Offset for pagination (default: 0) (optional)
     */
    getOrders: async (args: PolymarketGetOrdersArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getOrders',
        params: args || {}
      });
    },

    /**
     * Get current prediction market positions for the authenticated user. Shows all held outcome token positions with average entry price, current price, and computed P&L. Requires the user's wallet address and CLOB credentials.
     */
    getPositions: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getPositions',
        params: args || {}
      });
    },

    /**
     * Get trade history for the authenticated user. Returns completed trades with execution prices, sizes, fees, and on-chain transaction hashes. Can be filtered by market.
     * @param args.market - Filter by market condition ID (optional)
     * @param args.limit - Maximum number of trades to return (default: 25, max: 100) (optional)
     * @param args.offset - Offset for pagination (default: 0) (optional)
     */
    getTrades: async (args: PolymarketGetTradesArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getTrades',
        params: args || {}
      });
    },

    /**
     * Get the Polymarket Builder program leaderboard rankings. Shows top builders by volume and trade count for a given period. Requires Builder API credentials configured on the server.
     * @param args.period - Time period for rankings: "daily", "weekly", "monthly", or omit for all-time (optional)
     * @param args.limit - Maximum number of entries to return (default: 25, max: 100) (optional)
     */
    getBuilderLeaderboard: async (args: PolymarketGetBuilderLeaderboardArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getBuilderLeaderboard',
        params: args || {}
      });
    },

    /**
     * Get volume time-series data for the Builder program. Shows daily volume and trade count attributed to the builder. Requires Builder API credentials.
     * @param args.startDate - Start date in ISO 8601 format (e.g., "2024-06-01") (optional)
     * @param args.endDate - End date in ISO 8601 format (e.g., "2024-06-30") (optional)
     */
    getBuilderVolume: async (args: PolymarketGetBuilderVolumeArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'getBuilderVolume',
        params: args || {}
      });
    },

    /**
     * Search Polymarket API for available operations beyond core tools
     * @param args.query - Describe what you want to do (e.g., "add label to card")
     * @param args.limit - Max results to return (default 5) (optional)
     */
    discoverExtended: async (args: PolymarketDiscoverExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'discoverExtended',
        params: args || {}
      });
    },

    /**
     * Execute a Polymarket API operation by operationId
     * @param args.operationId - The operationId from discoverExtended results
     * @param args.pathParams - Path parameters, e.g., { id: "abc123" } (optional)
     * @param args.queryParams - Query string parameters (optional)
     * @param args.body - Request body for POST/PUT/PATCH operations (optional)
     */
    executeExtended: async (args: PolymarketExecuteExtendedArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'polymarket',
        method: 'executeExtended',
        params: args || {}
      });
    }
  };
}

/**
 * Hypertrade Adapter
 * Category: crypto
 */
function createHypertradeAdapter(sdk: MirraSDK) {
  return {
    /**
     * Place an order on Hyperliquid DEX. Returns a pending order for the user to sign in delegated mode, or submits directly in standard mode. FLAT response.
     * @param args.asset - Asset/coin symbol (e.g. "ETH", "BTC")
     * @param args.isBuy - True for long/buy, false for short/sell
     * @param args.size - Order size in asset units
     * @param args.limitPrice - Limit price (required for limit orders) (optional)
     * @param args.orderType - Order type: "limit" or "market" (default: "market") (optional)
     * @param args.triggerPrice - Trigger price for stop/take-profit orders (optional)
     * @param args.reduceOnly - Whether order can only reduce position (default: false) (optional)
     * @param args.postOnly - Whether order should only be maker (default: false) (optional)
     * @param args.clientOrderId - Custom client order ID for tracking (optional)
     * @returns Promise<HypertradePlaceOrderResult> Typed response with IDE autocomplete
     */
    placeOrder: async (args: HypertradePlaceOrderArgs): Promise<HypertradePlaceOrderResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'placeOrder',
        params: args || {}
      });
    },

    /**
     * Cancel an open order on Hyperliquid DEX. Can cancel by orderId, clientOrderId, or cancel all orders for an asset.
     * @param args.asset - Asset/coin symbol (e.g. "ETH", "BTC")
     * @param args.orderId - Order ID to cancel (optional)
     * @param args.clientOrderId - Client order ID to cancel (optional)
     * @param args.cancelAll - Cancel all orders for this asset (default: false) (optional)
     * @returns Promise<HypertradeCancelOrderResult> Typed response with IDE autocomplete
     */
    cancelOrder: async (args: HypertradeCancelOrderArgs): Promise<HypertradeCancelOrderResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'cancelOrder',
        params: args || {}
      });
    },

    /**
     * Get current perpetual positions for a wallet. Returns normalized FLAT array of positions with asset, size, entryPrice, markPrice, unrealizedPnl, leverage, liquidationPrice, marginUsed, positionValue, returnOnEquity, side.
     * @param args.walletAddress - EVM wallet address (uses context wallet if not provided) (optional)
     * @returns Promise<HypertradeGetPositionsResult> Typed response with IDE autocomplete
     */
    getPositions: async (args: HypertradeGetPositionsArgs): Promise<HypertradeGetPositionsResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'getPositions',
        params: args || {}
      });
    },

    /**
     * Get open orders for a wallet. Returns normalized FLAT array of orders.
     * @param args.walletAddress - EVM wallet address (uses context wallet if not provided) (optional)
     * @param args.asset - Filter by asset/coin symbol (optional)
     * @returns Promise<HypertradeGetOpenOrdersResult> Typed response with IDE autocomplete
     */
    getOpenOrders: async (args: HypertradeGetOpenOrdersArgs): Promise<HypertradeGetOpenOrdersResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'getOpenOrders',
        params: args || {}
      });
    },

    /**
     * Get account balances including perp margin and spot balances. Returns normalized FLAT structure.
     * @param args.walletAddress - EVM wallet address (uses context wallet if not provided) (optional)
     * @returns Promise<HypertradeGetBalancesResult> Typed response with IDE autocomplete
     */
    getBalances: async (args: HypertradeGetBalancesArgs): Promise<HypertradeGetBalancesResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'getBalances',
        params: args || {}
      });
    },

    /**
     * Get market information for perpetual assets. Returns normalized FLAT array of market info. If asset is provided, returns only that asset.
     * @param args.asset - Specific asset/coin symbol to get info for (returns all if omitted) (optional)
     * @returns Promise<HypertradeGetMarketInfoResult> Typed response with IDE autocomplete
     */
    getMarketInfo: async (args: HypertradeGetMarketInfoArgs): Promise<HypertradeGetMarketInfoResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'getMarketInfo',
        params: args || {}
      });
    },

    /**
     * Get the L2 orderbook for an asset. Returns normalized FLAT structure with bids and asks arrays.
     * @param args.asset - Asset/coin symbol (e.g. "ETH", "BTC")
     * @param args.depth - Number of levels to return (default: all) (optional)
     * @returns Promise<HypertradeGetOrderbookResult> Typed response with IDE autocomplete
     */
    getOrderbook: async (args: HypertradeGetOrderbookArgs): Promise<HypertradeGetOrderbookResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'getOrderbook',
        params: args || {}
      });
    },

    /**
     * Get candlestick/OHLCV data for an asset. Returns normalized FLAT array of candles.
     * @param args.asset - Asset/coin symbol (e.g. "ETH", "BTC")
     * @param args.interval - Candle interval (e.g. "1m", "5m", "1h", "1d"). Default: "1h" (optional)
     * @param args.startTime - Start time in milliseconds (default: 24h ago) (optional)
     * @param args.endTime - End time in milliseconds (default: now) (optional)
     * @param args.limit - Max number of candles to return (optional)
     * @returns Promise<HypertradeGetCandlesResult> Typed response with IDE autocomplete
     */
    getCandles: async (args: HypertradeGetCandlesArgs): Promise<HypertradeGetCandlesResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'getCandles',
        params: args || {}
      });
    },

    /**
     * Set leverage for an asset on Hyperliquid. Returns a pending action for the user to sign.
     * @param args.asset - Asset/coin symbol (e.g. "ETH", "BTC")
     * @param args.leverage - Leverage multiplier (e.g. 5 for 5x)
     * @param args.isCrossMargin - Use cross margin (default: true). False for isolated margin. (optional)
     * @returns Promise<HypertradeSetLeverageResult> Typed response with IDE autocomplete
     */
    setLeverage: async (args: HypertradeSetLeverageArgs): Promise<HypertradeSetLeverageResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'setLeverage',
        params: args || {}
      });
    },

    /**
     * Get trade fill history for a wallet. Returns normalized FLAT array of trades.
     * @param args.walletAddress - EVM wallet address (uses context wallet if not provided) (optional)
     * @param args.asset - Filter by asset/coin symbol (optional)
     * @param args.limit - Max number of trades to return (optional)
     * @returns Promise<HypertradeGetTradeHistoryResult> Typed response with IDE autocomplete
     */
    getTradeHistory: async (args: HypertradeGetTradeHistoryArgs): Promise<HypertradeGetTradeHistoryResult> => {
      return sdk.resources.call({
        resourceId: 'hypertrade',
        method: 'getTradeHistory',
        params: args || {}
      });
    }
  };
}

/**
 * Desktop Adapter
 * Category: internal
 */
function createDesktopAdapter(sdk: MirraSDK) {
  return {
    /**
     * Run a shell command on the user's desktop and return stdout, stderr, and exit code. The command runs via /bin/sh -c. Output is truncated to 1 MB.
     * @param args.command - Shell command to execute (e.g., "ls -la ~/Documents")
     * @param args.cwd - Working directory for the command (defaults to user home) (optional)
     * @param args.timeoutMs - Timeout in milliseconds (defaults to 120000) (optional)
     */
    executeCommand: async (args: DesktopExecuteCommandArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'desktop',
        method: 'executeCommand',
        params: args || {}
      });
    },

    /**
     * Read the text contents of a file on the user's desktop. Maximum file size is 1 MB.
     * @param args.path - Absolute path to the file to read
     * @param args.maxBytes - Maximum bytes to read (defaults to 1048576 = 1 MB) (optional)
     */
    readFile: async (args: DesktopReadFileArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'desktop',
        method: 'readFile',
        params: args || {}
      });
    },

    /**
     * Write or create a file on the user's desktop. Parent directories are created automatically. Requires user consent.
     * @param args.path - Absolute path to the file to write
     * @param args.content - Text content to write to the file
     * @param args.append - If true, append to existing file instead of overwriting (defaults to false) (optional)
     */
    writeFile: async (args: DesktopWriteFileArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'desktop',
        method: 'writeFile',
        params: args || {}
      });
    },

    /**
     * List files and directories at a given path on the user's desktop. Returns name, type, size, and modification time for each entry.
     * @param args.path - Absolute path to the directory to list
     * @param args.recursive - If true, list recursively (max depth 3). Defaults to false. (optional)
     * @param args.includeHidden - If true, include hidden files (starting with .). Defaults to false. (optional)
     */
    listDirectory: async (args: DesktopListDirectoryArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'desktop',
        method: 'listDirectory',
        params: args || {}
      });
    },

    /**
     * Get system information from the user's desktop: hostname, OS, CPU, memory, home directory.
     */
    getSystemInfo: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'desktop',
        method: 'getSystemInfo',
        params: args || {}
      });
    },

    /**
     * Spawn a long-running background process on the user's desktop. The process runs detached with no stdin/stdout (all communication via --sdk-url). Returns a process ID for later management. Requires user consent. A desktop:process_exited event is emitted when the process terminates.
     * @param args.command - Path to the executable to run (e.g., "node", "python3", "/usr/local/bin/my-app")
     * @param args.args - Command-line arguments to pass to the process (optional)
     * @param args.env - Additional environment variables to set for the process (optional)
     * @param args.cwd - Working directory for the process (defaults to system default) (optional)
     */
    spawnProcess: async (args: DesktopSpawnProcessArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'desktop',
        method: 'spawnProcess',
        params: args || {}
      });
    },

    /**
     * Kill a previously spawned background process by its process ID.
     * @param args.processId - The process ID returned by spawnProcess
     */
    killProcess: async (args: DesktopKillProcessArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'desktop',
        method: 'killProcess',
        params: args || {}
      });
    }
  };
}

/**
 * Shopify Adapter
 * Category: marketplace
 */
function createShopifyAdapter(sdk: MirraSDK) {
  return {
    /**
     * List products in the Shopify store with optional filtering and pagination. Returns up to 50 products per page. Use the nextPageInfo cursor from the response to fetch subsequent pages.
     * @param args.limit - Number of products to return per page (1-250). Defaults to 50. (optional)
     * @param args.pageInfo - Cursor for pagination. Use the nextPageInfo value from a previous response to get the next page. (optional)
     * @param args.status - Filter by product status: "active", "archived", or "draft". (optional)
     * @param args.vendor - Filter by product vendor name. (optional)
     * @param args.productType - Filter by product type. (optional)
     * @param args.collectionId - Filter by collection ID to list products in a specific collection. (optional)
     * @returns Promise<ShopifyListProductsResult> Typed response with IDE autocomplete
     */
    listProducts: async (args: ShopifyListProductsArgs): Promise<ShopifyListProductsResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listProducts',
        params: args || {}
      });
    },

    /**
     * Get a single product by its Shopify product ID. Returns full product details including all variants, images, and options.
     * @param args.productId - The Shopify product ID.
     * @returns Promise<ShopifyGetProductResult> Typed response with IDE autocomplete
     */
    getProduct: async (args: ShopifyGetProductArgs): Promise<ShopifyGetProductResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getProduct',
        params: args || {}
      });
    },

    /**
     * Create a new product in the Shopify store. At minimum, a title is required. Variants, images, and options can be added in the same request.
     * @param args.title - The product title.
     * @param args.bodyHtml - HTML description of the product. (optional)
     * @param args.vendor - The product vendor. (optional)
     * @param args.productType - The product type for categorization. (optional)
     * @param args.tags - Comma-separated list of tags. (optional)
     * @param args.status - Product status: "active", "archived", or "draft". Defaults to "active". (optional)
     * @param args.variants - Array of variant objects with price, sku, option1/option2/option3, inventory_quantity, weight, weight_unit, barcode, requires_shipping, taxable. (optional)
     * @param args.images - Array of image objects with src (URL) and optional alt text. (optional)
     * @returns Promise<ShopifyCreateProductResult> Typed response with IDE autocomplete
     */
    createProduct: async (args: ShopifyCreateProductArgs): Promise<ShopifyCreateProductResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'createProduct',
        params: args || {}
      });
    },

    /**
     * Update an existing product. Only the fields you provide will be updated; omitted fields remain unchanged.
     * @param args.productId - The Shopify product ID to update.
     * @param args.title - New product title. (optional)
     * @param args.bodyHtml - New HTML description. (optional)
     * @param args.vendor - New vendor name. (optional)
     * @param args.productType - New product type. (optional)
     * @param args.tags - New comma-separated tags (replaces existing tags). (optional)
     * @param args.status - New status: "active", "archived", or "draft". (optional)
     * @returns Promise<ShopifyUpdateProductResult> Typed response with IDE autocomplete
     */
    updateProduct: async (args: ShopifyUpdateProductArgs): Promise<ShopifyUpdateProductResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'updateProduct',
        params: args || {}
      });
    },

    /**
     * Permanently delete a product from the Shopify store. This action cannot be undone.
     * @param args.productId - The Shopify product ID to delete.
     * @returns Promise<ShopifyDeleteProductResult> Typed response with IDE autocomplete
     */
    deleteProduct: async (args: ShopifyDeleteProductArgs): Promise<ShopifyDeleteProductResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'deleteProduct',
        params: args || {}
      });
    },

    /**
     * List orders from the Shopify store with optional filtering. Returns up to 50 orders per page sorted by creation date descending. By default returns open orders.
     * @param args.limit - Number of orders to return per page (1-250). Defaults to 50. (optional)
     * @param args.pageInfo - Cursor for pagination from a previous response. (optional)
     * @param args.status - Filter by order status: "open", "closed", "cancelled", or "any". Defaults to "any". (optional)
     * @param args.financialStatus - Filter by financial status: "authorized", "pending", "paid", "partially_paid", "refunded", "voided", "partially_refunded", "any", "unpaid". (optional)
     * @param args.fulfillmentStatus - Filter by fulfillment status: "shipped", "partial", "unshipped", "any", "unfulfilled". (optional)
     * @param args.sinceId - Return orders after this order ID. (optional)
     * @param args.createdAtMin - Return orders created after this date (ISO 8601 format). (optional)
     * @param args.createdAtMax - Return orders created before this date (ISO 8601 format). (optional)
     * @returns Promise<ShopifyListOrdersResult> Typed response with IDE autocomplete
     */
    listOrders: async (args: ShopifyListOrdersArgs): Promise<ShopifyListOrdersResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listOrders',
        params: args || {}
      });
    },

    /**
     * Get a single order by its Shopify order ID. Returns full order details including line items and customer information.
     * @param args.orderId - The Shopify order ID.
     * @returns Promise<ShopifyGetOrderResult> Typed response with IDE autocomplete
     */
    getOrder: async (args: ShopifyGetOrderArgs): Promise<ShopifyGetOrderResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getOrder',
        params: args || {}
      });
    },

    /**
     * Create a new order in the Shopify store. Requires at least one line item. Can optionally include customer, shipping address, and financial details.
     * @param args.lineItems - Array of line items. Each item needs either variant_id or title+price+quantity. Example: [{ variant_id: "123", quantity: 2 }] or [{ title: "Custom Item", price: "10.00", quantity: 1 }].
     * @param args.email - Customer email address for the order. (optional)
     * @param args.note - An optional note attached to the order. (optional)
     * @param args.tags - Comma-separated tags for the order. (optional)
     * @param args.financialStatus - Financial status: "pending", "authorized", "partially_paid", "paid", "partially_refunded", "refunded", "voided". Defaults to "pending". (optional)
     * @param args.shippingAddress - Shipping address object with first_name, last_name, address1, address2, city, province, country, zip, phone. (optional)
     * @param args.customerId - Associate the order with an existing customer by their Shopify customer ID. (optional)
     * @returns Promise<ShopifyCreateOrderResult> Typed response with IDE autocomplete
     */
    createOrder: async (args: ShopifyCreateOrderArgs): Promise<ShopifyCreateOrderResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'createOrder',
        params: args || {}
      });
    },

    /**
     * Cancel an existing order. The order must be open. Optionally specify a reason for cancellation.
     * @param args.orderId - The Shopify order ID to cancel.
     * @param args.reason - Cancellation reason: "customer", "fraud", "inventory", "declined", or "other". (optional)
     * @param args.email - Whether to send a cancellation email to the customer. Defaults to true. (optional)
     * @returns Promise<ShopifyCancelOrderResult> Typed response with IDE autocomplete
     */
    cancelOrder: async (args: ShopifyCancelOrderArgs): Promise<ShopifyCancelOrderResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'cancelOrder',
        params: args || {}
      });
    },

    /**
     * Close an open order. A closed order is one that has no more work to be done (e.g., fully fulfilled and paid).
     * @param args.orderId - The Shopify order ID to close.
     * @returns Promise<ShopifyCloseOrderResult> Typed response with IDE autocomplete
     */
    closeOrder: async (args: ShopifyCloseOrderArgs): Promise<ShopifyCloseOrderResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'closeOrder',
        params: args || {}
      });
    },

    /**
     * List customers from the Shopify store with optional pagination. Returns up to 50 customers per page.
     * @param args.limit - Number of customers to return per page (1-250). Defaults to 50. (optional)
     * @param args.pageInfo - Cursor for pagination from a previous response. (optional)
     * @param args.sinceId - Return customers after this customer ID. (optional)
     * @param args.createdAtMin - Return customers created after this date (ISO 8601 format). (optional)
     * @param args.createdAtMax - Return customers created before this date (ISO 8601 format). (optional)
     * @returns Promise<ShopifyListCustomersResult> Typed response with IDE autocomplete
     */
    listCustomers: async (args: ShopifyListCustomersArgs): Promise<ShopifyListCustomersResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listCustomers',
        params: args || {}
      });
    },

    /**
     * Get a single customer by their Shopify customer ID. Returns full customer details including addresses.
     * @param args.customerId - The Shopify customer ID.
     * @returns Promise<ShopifyGetCustomerResult> Typed response with IDE autocomplete
     */
    getCustomer: async (args: ShopifyGetCustomerArgs): Promise<ShopifyGetCustomerResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getCustomer',
        params: args || {}
      });
    },

    /**
     * Create a new customer in the Shopify store. At minimum, either an email or a phone number is required.
     * @param args.firstName - Customer first name. (optional)
     * @param args.lastName - Customer last name. (optional)
     * @param args.email - Customer email address. Required if phone is not provided. (optional)
     * @param args.phone - Customer phone number in E.164 format. Required if email is not provided. (optional)
     * @param args.tags - Comma-separated tags for the customer. (optional)
     * @param args.note - A note about the customer. (optional)
     * @param args.addresses - Array of address objects with address1, city, province, country, zip, phone. (optional)
     * @returns Promise<ShopifyCreateCustomerResult> Typed response with IDE autocomplete
     */
    createCustomer: async (args: ShopifyCreateCustomerArgs): Promise<ShopifyCreateCustomerResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'createCustomer',
        params: args || {}
      });
    },

    /**
     * Update an existing customer. Only the fields you provide will be updated.
     * @param args.customerId - The Shopify customer ID to update.
     * @param args.firstName - New first name. (optional)
     * @param args.lastName - New last name. (optional)
     * @param args.email - New email address. (optional)
     * @param args.phone - New phone number in E.164 format. (optional)
     * @param args.tags - New comma-separated tags (replaces existing). (optional)
     * @param args.note - New note about the customer. (optional)
     * @returns Promise<ShopifyUpdateCustomerResult> Typed response with IDE autocomplete
     */
    updateCustomer: async (args: ShopifyUpdateCustomerArgs): Promise<ShopifyUpdateCustomerResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'updateCustomer',
        params: args || {}
      });
    },

    /**
     * Search customers by a query string. Searches across email, name, and other fields. Returns up to 50 results.
     * @param args.query - Search query string. Examples: "email:john@example.com", "first_name:John", or freeform text like "john doe".
     * @param args.limit - Number of results to return (1-250). Defaults to 50. (optional)
     * @returns Promise<ShopifySearchCustomersResult> Typed response with IDE autocomplete
     */
    searchCustomers: async (args: ShopifySearchCustomersArgs): Promise<ShopifySearchCustomersResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'searchCustomers',
        params: args || {}
      });
    },

    /**
     * Get inventory levels for items at specific locations. You must provide either inventoryItemIds or locationIds (at least one is required).
     * @param args.inventoryItemIds - Comma-separated list of inventory item IDs to query. (optional)
     * @param args.locationIds - Comma-separated list of location IDs to query. (optional)
     * @param args.limit - Number of results to return (1-250). Defaults to 50. (optional)
     * @returns Promise<ShopifyGetInventoryLevelsResult> Typed response with IDE autocomplete
     */
    getInventoryLevels: async (args: ShopifyGetInventoryLevelsArgs): Promise<ShopifyGetInventoryLevelsResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getInventoryLevels',
        params: args || {}
      });
    },

    /**
     * Adjust the available inventory quantity for an item at a specific location. The adjustment is relative (e.g., +5 adds 5 units, -3 removes 3 units).
     * @param args.inventoryItemId - The inventory item ID to adjust.
     * @param args.locationId - The location ID where the inventory is stored.
     * @param args.adjustment - The quantity adjustment. Positive to add stock, negative to remove.
     * @returns Promise<ShopifyAdjustInventoryResult> Typed response with IDE autocomplete
     */
    adjustInventory: async (args: ShopifyAdjustInventoryArgs): Promise<ShopifyAdjustInventoryResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'adjustInventory',
        params: args || {}
      });
    },

    /**
     * List collections in the Shopify store. Returns both custom collections and smart collections combined, sorted by title.
     * @param args.limit - Maximum number of collections to return per type (1-250). Defaults to 50. Note: up to this many custom collections AND this many smart collections may be returned. (optional)
     * @param args.pageInfo - Cursor for pagination from a previous response. (optional)
     * @returns Promise<ShopifyListCollectionsResult> Typed response with IDE autocomplete
     */
    listCollections: async (args: ShopifyListCollectionsArgs): Promise<ShopifyListCollectionsResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listCollections',
        params: args || {}
      });
    },

    /**
     * List pages in the Shopify store with optional pagination.
     * @param args.limit - Number of pages per page, 1-250, default 50 (optional)
     * @param args.pageInfo - Cursor for pagination (optional)
     * @returns Promise<ShopifyListPagesResult> Typed response with IDE autocomplete
     */
    listPages: async (args: ShopifyListPagesArgs): Promise<ShopifyListPagesResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listPages',
        params: args || {}
      });
    },

    /**
     * Get a single page by ID.
     * @param args.pageId - The Shopify page ID.
     * @returns Promise<ShopifyGetPageResult> Typed response with IDE autocomplete
     */
    getPage: async (args: ShopifyGetPageArgs): Promise<ShopifyGetPageResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getPage',
        params: args || {}
      });
    },

    /**
     * Create a new page in the Shopify store.
     * @param args.title - The page title.
     * @param args.bodyHtml - HTML body content of the page. (optional)
     * @param args.author - The author of the page. (optional)
     * @param args.templateSuffix - The template suffix for the page. (optional)
     * @param args.published - Whether the page is published. Defaults to true. (optional)
     * @returns Promise<ShopifyCreatePageResult> Typed response with IDE autocomplete
     */
    createPage: async (args: ShopifyCreatePageArgs): Promise<ShopifyCreatePageResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'createPage',
        params: args || {}
      });
    },

    /**
     * Update a page.
     * @param args.pageId - The Shopify page ID to update.
     * @param args.title - New page title. (optional)
     * @param args.bodyHtml - New HTML body content. (optional)
     * @param args.author - New author name. (optional)
     * @param args.templateSuffix - New template suffix. (optional)
     * @param args.published - Whether the page is published. (optional)
     * @returns Promise<ShopifyUpdatePageResult> Typed response with IDE autocomplete
     */
    updatePage: async (args: ShopifyUpdatePageArgs): Promise<ShopifyUpdatePageResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'updatePage',
        params: args || {}
      });
    },

    /**
     * Permanently delete a page.
     * @param args.pageId - The Shopify page ID to delete.
     * @returns Promise<ShopifyDeletePageResult> Typed response with IDE autocomplete
     */
    deletePage: async (args: ShopifyDeletePageArgs): Promise<ShopifyDeletePageResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'deletePage',
        params: args || {}
      });
    },

    /**
     * List blogs in the Shopify store.
     * @param args.limit - Number of blogs per page, 1-250, default 50 (optional)
     * @param args.pageInfo - Cursor for pagination (optional)
     * @returns Promise<ShopifyListBlogsResult> Typed response with IDE autocomplete
     */
    listBlogs: async (args: ShopifyListBlogsArgs): Promise<ShopifyListBlogsResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listBlogs',
        params: args || {}
      });
    },

    /**
     * Get a blog by ID.
     * @param args.blogId - The Shopify blog ID.
     * @returns Promise<ShopifyGetBlogResult> Typed response with IDE autocomplete
     */
    getBlog: async (args: ShopifyGetBlogArgs): Promise<ShopifyGetBlogResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getBlog',
        params: args || {}
      });
    },

    /**
     * Create a blog.
     * @param args.title - The blog title.
     * @param args.commentable - Comment policy: no, moderate, yes (optional)
     * @returns Promise<ShopifyCreateBlogResult> Typed response with IDE autocomplete
     */
    createBlog: async (args: ShopifyCreateBlogArgs): Promise<ShopifyCreateBlogResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'createBlog',
        params: args || {}
      });
    },

    /**
     * Update a blog.
     * @param args.blogId - The Shopify blog ID to update.
     * @param args.title - New blog title. (optional)
     * @param args.commentable - New comment policy: no, moderate, yes (optional)
     * @returns Promise<ShopifyUpdateBlogResult> Typed response with IDE autocomplete
     */
    updateBlog: async (args: ShopifyUpdateBlogArgs): Promise<ShopifyUpdateBlogResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'updateBlog',
        params: args || {}
      });
    },

    /**
     * Delete a blog.
     * @param args.blogId - The Shopify blog ID to delete.
     * @returns Promise<ShopifyDeleteBlogResult> Typed response with IDE autocomplete
     */
    deleteBlog: async (args: ShopifyDeleteBlogArgs): Promise<ShopifyDeleteBlogResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'deleteBlog',
        params: args || {}
      });
    },

    /**
     * List articles in a blog.
     * @param args.blogId - The blog ID to list articles from.
     * @param args.limit - Number of articles per page, 1-250, default 50 (optional)
     * @param args.pageInfo - Cursor for pagination (optional)
     * @returns Promise<ShopifyListArticlesResult> Typed response with IDE autocomplete
     */
    listArticles: async (args: ShopifyListArticlesArgs): Promise<ShopifyListArticlesResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listArticles',
        params: args || {}
      });
    },

    /**
     * Get an article by ID.
     * @param args.articleId - The Shopify article ID.
     * @returns Promise<ShopifyGetArticleResult> Typed response with IDE autocomplete
     */
    getArticle: async (args: ShopifyGetArticleArgs): Promise<ShopifyGetArticleResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getArticle',
        params: args || {}
      });
    },

    /**
     * Create an article in a blog.
     * @param args.blogId - The blog ID to create the article in.
     * @param args.title - The article title.
     * @param args.author - The article author. (optional)
     * @param args.bodyHtml - HTML body content of the article. (optional)
     * @param args.summary - Summary or excerpt of the article. (optional)
     * @param args.tags - Comma-separated list of tags. (optional)
     * @param args.published - Whether the article is published. (optional)
     * @param args.imageUrl - URL of the article featured image. (optional)
     * @param args.imageAlt - Alt text for the article featured image. (optional)
     * @returns Promise<ShopifyCreateArticleResult> Typed response with IDE autocomplete
     */
    createArticle: async (args: ShopifyCreateArticleArgs): Promise<ShopifyCreateArticleResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'createArticle',
        params: args || {}
      });
    },

    /**
     * Update an article.
     * @param args.articleId - The Shopify article ID to update.
     * @param args.title - New article title. (optional)
     * @param args.author - New author name. (optional)
     * @param args.bodyHtml - New HTML body content. (optional)
     * @param args.summary - New summary or excerpt. (optional)
     * @param args.tags - New comma-separated tags. (optional)
     * @param args.published - Whether the article is published. (optional)
     * @returns Promise<ShopifyUpdateArticleResult> Typed response with IDE autocomplete
     */
    updateArticle: async (args: ShopifyUpdateArticleArgs): Promise<ShopifyUpdateArticleResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'updateArticle',
        params: args || {}
      });
    },

    /**
     * Delete an article.
     * @param args.articleId - The Shopify article ID to delete.
     * @returns Promise<ShopifyDeleteArticleResult> Typed response with IDE autocomplete
     */
    deleteArticle: async (args: ShopifyDeleteArticleArgs): Promise<ShopifyDeleteArticleResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'deleteArticle',
        params: args || {}
      });
    },

    /**
     * List all themes in the Shopify store.
     * @returns Promise<ShopifyListThemesResult> Typed response with IDE autocomplete
     */
    listThemes: async (args?: {}): Promise<ShopifyListThemesResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listThemes',
        params: args || {}
      });
    },

    /**
     * Get a theme by ID.
     * @param args.themeId - The Shopify theme ID.
     * @returns Promise<ShopifyGetThemeResult> Typed response with IDE autocomplete
     */
    getTheme: async (args: ShopifyGetThemeArgs): Promise<ShopifyGetThemeResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getTheme',
        params: args || {}
      });
    },

    /**
     * Publish (activate) a theme as the main theme.
     * @param args.themeId - The Shopify theme ID to publish.
     * @returns Promise<ShopifyPublishThemeResult> Typed response with IDE autocomplete
     */
    publishTheme: async (args: ShopifyPublishThemeArgs): Promise<ShopifyPublishThemeResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'publishTheme',
        params: args || {}
      });
    },

    /**
     * List files in a theme.
     * @param args.themeId - The Shopify theme ID.
     * @param args.filenames - Comma-separated glob patterns like templates/*.json (optional)
     * @returns Promise<ShopifyListThemeFilesResult> Typed response with IDE autocomplete
     */
    listThemeFiles: async (args: ShopifyListThemeFilesArgs): Promise<ShopifyListThemeFilesResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listThemeFiles',
        params: args || {}
      });
    },

    /**
     * Get a single theme file with its content.
     * @param args.themeId - The Shopify theme ID.
     * @param args.filename - The filename/path of the theme file (e.g., "templates/index.json").
     * @returns Promise<ShopifyGetThemeFileResult> Typed response with IDE autocomplete
     */
    getThemeFile: async (args: ShopifyGetThemeFileArgs): Promise<ShopifyGetThemeFileResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getThemeFile',
        params: args || {}
      });
    },

    /**
     * Create or update theme files.
     * @param args.themeId - The Shopify theme ID.
     * @param args.files - Array of {filename, body} objects
     * @returns Promise<ShopifyUpsertThemeFilesResult> Typed response with IDE autocomplete
     */
    upsertThemeFiles: async (args: ShopifyUpsertThemeFilesArgs): Promise<ShopifyUpsertThemeFilesResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'upsertThemeFiles',
        params: args || {}
      });
    },

    /**
     * Delete theme files.
     * @param args.themeId - The Shopify theme ID.
     * @param args.filenames - Array of filenames to delete
     * @returns Promise<ShopifyDeleteThemeFilesResult> Typed response with IDE autocomplete
     */
    deleteThemeFiles: async (args: ShopifyDeleteThemeFilesArgs): Promise<ShopifyDeleteThemeFilesResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'deleteThemeFiles',
        params: args || {}
      });
    },

    /**
     * List navigation menus.
     * @param args.limit - Number of menus per page, 1-250, default 50 (optional)
     * @param args.pageInfo - Cursor for pagination (optional)
     * @returns Promise<ShopifyListMenusResult> Typed response with IDE autocomplete
     */
    listMenus: async (args: ShopifyListMenusArgs): Promise<ShopifyListMenusResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listMenus',
        params: args || {}
      });
    },

    /**
     * Get a menu by ID.
     * @param args.menuId - The Shopify menu ID.
     * @returns Promise<ShopifyGetMenuResult> Typed response with IDE autocomplete
     */
    getMenu: async (args: ShopifyGetMenuArgs): Promise<ShopifyGetMenuResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'getMenu',
        params: args || {}
      });
    },

    /**
     * Create a navigation menu.
     * @param args.title - The menu title.
     * @param args.handle - The menu handle (URL-friendly identifier). (optional)
     * @param args.items - Array of menu item objects with title, url, type, resourceId (optional)
     * @returns Promise<ShopifyCreateMenuResult> Typed response with IDE autocomplete
     */
    createMenu: async (args: ShopifyCreateMenuArgs): Promise<ShopifyCreateMenuResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'createMenu',
        params: args || {}
      });
    },

    /**
     * Update a menu.
     * @param args.menuId - The Shopify menu ID to update.
     * @param args.title - New menu title. (optional)
     * @param args.handle - New menu handle. (optional)
     * @param args.items - New array of menu item objects with title, url, type, resourceId (optional)
     * @returns Promise<ShopifyUpdateMenuResult> Typed response with IDE autocomplete
     */
    updateMenu: async (args: ShopifyUpdateMenuArgs): Promise<ShopifyUpdateMenuResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'updateMenu',
        params: args || {}
      });
    },

    /**
     * Delete a menu.
     * @param args.menuId - The Shopify menu ID to delete.
     * @returns Promise<ShopifyDeleteMenuResult> Typed response with IDE autocomplete
     */
    deleteMenu: async (args: ShopifyDeleteMenuArgs): Promise<ShopifyDeleteMenuResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'deleteMenu',
        params: args || {}
      });
    },

    /**
     * List URL redirects.
     * @param args.limit - Number of redirects per page, 1-250, default 50 (optional)
     * @param args.pageInfo - Cursor for pagination (optional)
     * @returns Promise<ShopifyListRedirectsResult> Typed response with IDE autocomplete
     */
    listRedirects: async (args: ShopifyListRedirectsArgs): Promise<ShopifyListRedirectsResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'listRedirects',
        params: args || {}
      });
    },

    /**
     * Create a URL redirect.
     * @param args.path - The old path to redirect from
     * @param args.target - The new URL to redirect to
     * @returns Promise<ShopifyCreateRedirectResult> Typed response with IDE autocomplete
     */
    createRedirect: async (args: ShopifyCreateRedirectArgs): Promise<ShopifyCreateRedirectResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'createRedirect',
        params: args || {}
      });
    },

    /**
     * Update a redirect.
     * @param args.redirectId - The Shopify redirect ID to update.
     * @param args.path - New path to redirect from. (optional)
     * @param args.target - New URL to redirect to. (optional)
     * @returns Promise<ShopifyUpdateRedirectResult> Typed response with IDE autocomplete
     */
    updateRedirect: async (args: ShopifyUpdateRedirectArgs): Promise<ShopifyUpdateRedirectResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'updateRedirect',
        params: args || {}
      });
    },

    /**
     * Delete a redirect.
     * @param args.redirectId - The Shopify redirect ID to delete.
     * @returns Promise<ShopifyDeleteRedirectResult> Typed response with IDE autocomplete
     */
    deleteRedirect: async (args: ShopifyDeleteRedirectArgs): Promise<ShopifyDeleteRedirectResult> => {
      return sdk.resources.call({
        resourceId: 'shopify',
        method: 'deleteRedirect',
        params: args || {}
      });
    }
  };
}

/**
 * Data Adapter
 * Category: internal
 */
function createDataAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new data collection (schema). Define the fields and their types. A slug is auto-generated from the name if not provided.
     * @param args.name - Human-readable name for the collection (e.g. "Contacts", "Sales Metrics")
     * @param args.slug - URL-safe identifier (lowercase, underscores). Auto-generated from name if omitted. (optional)
     * @param args.fields - Array of field definitions. Each field has: name (string), type ("string"|"number"|"boolean"|"date"|"array"|"object"), required (boolean), description (optional string).
     * @param args.description - Optional description of what this collection stores (optional)
     */
    defineCollection: async (args: DataDefineCollectionArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'defineCollection',
        params: args || {}
      });
    },

    /**
     * List all data collections for the current context. Optionally filter by status.
     * @param args.status - Filter by status: "active" (default) or "archived" (optional)
     */
    listCollections: async (args: DataListCollectionsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'listCollections',
        params: args || {}
      });
    },

    /**
     * Get a single collection schema by its slug.
     * @param args.slug - The collection slug (e.g. "contacts")
     */
    getCollection: async (args: DataGetCollectionArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'getCollection',
        params: args || {}
      });
    },

    /**
     * Update a collection schema. Add new fields, remove existing fields, or update the description. Field changes are non-destructive -- existing records are not modified.
     * @param args.slug - The collection slug to update
     * @param args.addFields - New fields to add to the collection (optional)
     * @param args.removeFields - Field names to remove from the collection (optional)
     * @param args.description - New description for the collection (optional)
     */
    updateCollection: async (args: DataUpdateCollectionArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'updateCollection',
        params: args || {}
      });
    },

    /**
     * Archive a collection and delete all its records. The schema is marked as archived and all associated records are permanently deleted. Quota is decremented.
     * @param args.slug - The collection slug to drop
     */
    dropCollection: async (args: DataDropCollectionArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'dropCollection',
        params: args || {}
      });
    },

    /**
     * Insert a single record into a collection. Data is validated against the collection schema. Quota is checked before writing.
     * @param args.collection - The collection slug to insert into
     * @param args.data - The record data -- keys must match the collection fields
     */
    insertRecord: async (args: DataInsertRecordArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'insertRecord',
        params: args || {}
      });
    },

    /**
     * Batch insert multiple records into a collection. All records are validated against the schema. Quota is checked for the total size.
     * @param args.collection - The collection slug to insert into
     * @param args.records - Array of record data objects to insert
     */
    insertRecords: async (args: DataInsertRecordsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'insertRecords',
        params: args || {}
      });
    },

    /**
     * Query records from a collection with optional filtering, sorting, and pagination. Filters use MongoDB-style syntax (e.g. { revenue: { $gt: 10000 } }).
     * @param args.collection - The collection slug to query
     * @param args.filter - MongoDB-style filter object. Supports $eq, $ne, $gt, $gte, $lt, $lte, $in, $regex. Filter keys are automatically prefixed with "data." so use field names directly. (optional)
     * @param args.sort - Sort object, e.g. { revenue: -1 } for descending. Keys are auto-prefixed with "data.". (optional)
     * @param args.limit - Max records to return (default 50, max 200) (optional)
     * @param args.offset - Number of records to skip (for pagination) (optional)
     */
    queryRecords: async (args: DataQueryRecordsArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'queryRecords',
        params: args || {}
      });
    },

    /**
     * Update a single record by its ID. Data is validated against the collection schema.
     * @param args.collection - The collection slug
     * @param args.recordId - The record _id to update
     * @param args.data - Partial record data to merge/update
     */
    updateRecord: async (args: DataUpdateRecordArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'updateRecord',
        params: args || {}
      });
    },

    /**
     * Delete a single record by its ID. Quota is decremented by the record size.
     * @param args.collection - The collection slug
     * @param args.recordId - The record _id to delete
     */
    deleteRecord: async (args: DataDeleteRecordArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'deleteRecord',
        params: args || {}
      });
    },

    /**
     * Run aggregation on a collection. Supports sum, avg, count, min, max grouped by a field.
     * @param args.collection - The collection slug
     * @param args.groupBy - Field name to group by. Omit for overall aggregation. (optional)
     * @param args.metrics - Array of { field, op } where op is one of "sum", "avg", "count", "min", "max". For "count", field can be omitted.
     */
    aggregate: async (args: DataAggregateArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'aggregate',
        params: args || {}
      });
    },

    /**
     * Get the current storage quota usage for this context.
     */
    getQuotaUsage: async (args?: {}): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'data',
        method: 'getQuotaUsage',
        params: args || {}
      });
    }
  };
}

/**
 * Pages Adapter
 * Category: internal
 */
function createPagesAdapter(sdk: MirraSDK) {
  return {
    /**
     * Create a new page with JSX code. The code is compiled to HTML with React, Tailwind CSS, Recharts, and Lucide icons available as globals. Define a top-level `function App()` component as the entry point. Do NOT use import/require statements — all libraries are pre-loaded via CDN. Use Recharts components directly (e.g. `<BarChart>`, `<ResponsiveContainer>`) and Lucide icons via `lucide.IconName`.
     * @param args.path - URL path for the page (e.g. "/dashboard"). Must start with /, lowercase alphanumeric and hyphens only, 2-50 chars.
     * @param args.title - Display title for the page
     * @param args.code - JSX source code. Must define a top-level function App() component. Do NOT use import/require — React, ReactDOM, Recharts (BarChart, PieChart, LineChart, ResponsiveContainer, etc.), lucide-react, and Tailwind CSS are all pre-loaded globals.
     * @param args.description - Optional description of the page (optional)
     * @param args.visibility - Page visibility: "private" (default) or "public" (optional)
     */
    createPage: async (args: PagesCreatePageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'createPage',
        params: args || {}
      });
    },

    /**
     * Edit a page using search-and-replace. Each edit replaces one exact match of oldCode with newCode in the current source. Much more efficient than updatePage for small changes — only send the parts that change. Use getPage first to read the current code. The old_code string must appear exactly once in the source.
     * @param args.pageId - The page ID to edit
     * @param args.edits - Array of search-and-replace edits. Each edit has oldCode (exact string to find) and newCode (replacement string). Applied sequentially.
     */
    editPage: async (args: PagesEditPageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'editPage',
        params: args || {}
      });
    },

    /**
     * Replace the entire page code. Use editPage instead for small changes — it is more efficient. Only use updatePage when rewriting most of the page.
     * @param args.pageId - The page ID to update
     * @param args.code - New JSX source code (optional)
     * @param args.title - New title (optional)
     * @param args.description - New description (optional)
     */
    updatePage: async (args: PagesUpdatePageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'updatePage',
        params: args || {}
      });
    },

    /**
     * Revert a page to a previous version. The current code becomes a new version entry.
     * @param args.pageId - The page ID to revert
     * @param args.versionIndex - Index of the version to restore (0 = most recent saved version)
     */
    revertPage: async (args: PagesRevertPageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'revertPage',
        params: args || {}
      });
    },

    /**
     * Get a page by its ID or by path within the current graph. Returns page metadata and current code.
     * @param args.pageId - The page ID (optional)
     * @param args.path - The page path (e.g. "/dashboard"). Used with the current graphId. (optional)
     */
    getPage: async (args: PagesGetPageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'getPage',
        params: args || {}
      });
    },

    /**
     * List all pages for the current graph. Optionally filter by status.
     * @param args.status - Filter by status: "active" (default) or "deleted" (optional)
     */
    listPages: async (args: PagesListPagesArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'listPages',
        params: args || {}
      });
    },

    /**
     * Soft-delete a page by setting its status to "deleted".
     * @param args.pageId - The page ID to delete
     */
    deletePage: async (args: PagesDeletePageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'deletePage',
        params: args || {}
      });
    },

    /**
     * Publish a page, making it publicly accessible. Generates an API key for the page.
     * @param args.pageId - The page ID to publish
     * @param args.publicCollections - Optional array of collection tags for public discovery (optional)
     */
    publishPage: async (args: PagesPublishPageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'publishPage',
        params: args || {}
      });
    },

    /**
     * Unpublish a page, making it private.
     * @param args.pageId - The page ID to unpublish
     */
    unpublishPage: async (args: PagesUnpublishPageArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'unpublishPage',
        params: args || {}
      });
    },

    /**
     * Get the public URL for a page.
     * @param args.pageId - The page ID
     */
    getPageUrl: async (args: PagesGetPageUrlArgs): Promise<any> => {
      return sdk.resources.call({
        resourceId: 'pages',
        method: 'getPageUrl',
        params: args || {}
      });
    }
  };
}


// ============================================================================
// Exports
// ============================================================================

export const generatedAdapters = {
  flows: createFlowsAdapter,
  user: createUserAdapter,
  contacts: createContactsAdapter,
  memory: createMemoryAdapter,
  ai: createAiAdapter,
  document: createDocumentAdapter,
  feedItems: createFeedItemsAdapter,
  telegram: createTelegramAdapter,
  googleGmail: createGoogleGmailAdapter,
  googleCalendar: createGoogleCalendarAdapter,
  googleDrive: createGoogleDriveAdapter,
  googleSheets: createGoogleSheetsAdapter,
  googleDocs: createGoogleDocsAdapter,
  jira: createJiraAdapter,
  twitter: createTwitterAdapter,
  trello: createTrelloAdapter,
  jupiter: createJupiterAdapter,
  crypto: createCryptoAdapter,
  scripts: createScriptsAdapter,
  feedback: createFeedbackAdapter,
  mirraMessaging: createMirraMessagingAdapter,
  moltbook: createMoltbookAdapter,
  tunnel: createTunnelAdapter,
  polymarket: createPolymarketAdapter,
  hypertrade: createHypertradeAdapter,
  desktop: createDesktopAdapter,
  shopify: createShopifyAdapter,
  data: createDataAdapter,
  pages: createPagesAdapter
};